<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvBuffer Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v6.4.0.6670 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_pv_buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_pv_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a block of GigE Vision or USB3 Vision data in memory.  
 <a href="class_pv_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_pv_buffer_8h_source.html">PvBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aec685815f08f9a47e7f8df24f8d90547"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aec685815f08f9a47e7f8df24f8d90547">PvBuffer</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType=<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a>)</td></tr>
<tr class="memdesc:aec685815f08f9a47e7f8df24f8d90547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_pv_buffer.html#aec685815f08f9a47e7f8df24f8d90547">More...</a><br /></td></tr>
<tr class="separator:aec685815f08f9a47e7f8df24f8d90547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035a8711b365606fd6ec2d9b609b6b37"><td class="memItemLeft" align="right" valign="top"><a id="a035a8711b365606fd6ec2d9b609b6b37"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a035a8711b365606fd6ec2d9b609b6b37">~PvBuffer</a> ()</td></tr>
<tr class="memdesc:a035a8711b365606fd6ec2d9b609b6b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a035a8711b365606fd6ec2d9b609b6b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da48cd0feb9f44fa354e30cd06ec748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a0da48cd0feb9f44fa354e30cd06ec748">GetPayloadType</a> () const</td></tr>
<tr class="memdesc:a0da48cd0feb9f44fa354e30cd06ec748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the payload type currently used by the buffer.  <a href="class_pv_buffer.html#a0da48cd0feb9f44fa354e30cd06ec748">More...</a><br /></td></tr>
<tr class="separator:a0da48cd0feb9f44fa354e30cd06ec748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e84f98d2c01c33aa6d58343fc242fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_image.html">PvImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc">GetImage</a> ()</td></tr>
<tr class="memdesc:aa0e84f98d2c01c33aa6d58343fc242fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface to the buffer.  <a href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc">More...</a><br /></td></tr>
<tr class="separator:aa0e84f98d2c01c33aa6d58343fc242fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d64476c86d4db2a4aa60d8bb1ae7f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_pv_image.html">PvImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a55d64476c86d4db2a4aa60d8bb1ae7f0">GetImage</a> () const</td></tr>
<tr class="memdesc:a55d64476c86d4db2a4aa60d8bb1ae7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface to the buffer.  <a href="class_pv_buffer.html#a55d64476c86d4db2a4aa60d8bb1ae7f0">More...</a><br /></td></tr>
<tr class="separator:a55d64476c86d4db2a4aa60d8bb1ae7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecd2a17dd53ef52ad1873bdb63df1b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_raw_data.html">PvRawData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aeecd2a17dd53ef52ad1873bdb63df1b4">GetRawData</a> ()</td></tr>
<tr class="memdesc:aeecd2a17dd53ef52ad1873bdb63df1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface to the buffer.  <a href="class_pv_buffer.html#aeecd2a17dd53ef52ad1873bdb63df1b4">More...</a><br /></td></tr>
<tr class="separator:aeecd2a17dd53ef52ad1873bdb63df1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1243108931822c8f4149546ffbb081ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_pv_raw_data.html">PvRawData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a1243108931822c8f4149546ffbb081ac">GetRawData</a> () const</td></tr>
<tr class="memdesc:a1243108931822c8f4149546ffbb081ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface to the buffer.  <a href="class_pv_buffer.html#a1243108931822c8f4149546ffbb081ac">More...</a><br /></td></tr>
<tr class="separator:a1243108931822c8f4149546ffbb081ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9302a71fa4bd8541862a085f686d5583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_pleora_compressed.html">PvPleoraCompressed</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a9302a71fa4bd8541862a085f686d5583">GetPleoraCompressed</a> ()</td></tr>
<tr class="memdesc:a9302a71fa4bd8541862a085f686d5583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_pleora_compressed.html" title="Pleora compressed interface to a PvBuffer.">PvPleoraCompressed</a> interface to the buffer.  <a href="class_pv_buffer.html#a9302a71fa4bd8541862a085f686d5583">More...</a><br /></td></tr>
<tr class="separator:a9302a71fa4bd8541862a085f686d5583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e51926ba97155ff817639bf976cfbb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_pv_pleora_compressed.html">PvPleoraCompressed</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a33e51926ba97155ff817639bf976cfbb">GetPleoraCompressed</a> () const</td></tr>
<tr class="memdesc:a33e51926ba97155ff817639bf976cfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_pleora_compressed.html" title="Pleora compressed interface to a PvBuffer.">PvPleoraCompressed</a> interface to the buffer.  <a href="class_pv_buffer.html#a33e51926ba97155ff817639bf976cfbb">More...</a><br /></td></tr>
<tr class="separator:a33e51926ba97155ff817639bf976cfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1223464a644a765f10a387a4576298bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_chunk_data.html">PvChunkData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a1223464a644a765f10a387a4576298bb">GetChunkData</a> ()</td></tr>
<tr class="memdesc:a1223464a644a765f10a387a4576298bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface to the buffer.  <a href="class_pv_buffer.html#a1223464a644a765f10a387a4576298bb">More...</a><br /></td></tr>
<tr class="separator:a1223464a644a765f10a387a4576298bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf182866d3ee27bbf54b35ff020fc81"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_pv_chunk_data.html">PvChunkData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a7cf182866d3ee27bbf54b35ff020fc81">GetChunkData</a> () const</td></tr>
<tr class="memdesc:a7cf182866d3ee27bbf54b35ff020fc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface to the buffer.  <a href="class_pv_buffer.html#a7cf182866d3ee27bbf54b35ff020fc81">More...</a><br /></td></tr>
<tr class="separator:a7cf182866d3ee27bbf54b35ff020fc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adf6ff1a75e7431dac15d3f0fde2f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv_multi_part_container.html">IPvMultiPartContainer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a0adf6ff1a75e7431dac15d3f0fde2f08">GetMultiPartContainer</a> ()</td></tr>
<tr class="memdesc:a0adf6ff1a75e7431dac15d3f0fde2f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface to the buffer.  <a href="class_pv_buffer.html#a0adf6ff1a75e7431dac15d3f0fde2f08">More...</a><br /></td></tr>
<tr class="separator:a0adf6ff1a75e7431dac15d3f0fde2f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c0f64a0660f7ae28a3ef8fbc9df47e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_i_pv_multi_part_container.html">IPvMultiPartContainer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a50c0f64a0660f7ae28a3ef8fbc9df47e">GetMultiPartContainer</a> () const</td></tr>
<tr class="memdesc:a50c0f64a0660f7ae28a3ef8fbc9df47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface to the buffer.  <a href="class_pv_buffer.html#a50c0f64a0660f7ae28a3ef8fbc9df47e">More...</a><br /></td></tr>
<tr class="separator:a50c0f64a0660f7ae28a3ef8fbc9df47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aef226e5e5651ceaf083975b71df6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_pv_h264_access_unit.html">IPvH264AccessUnit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a60aef226e5e5651ceaf083975b71df6a">GetH264AccessUnit</a> ()</td></tr>
<tr class="memdesc:a60aef226e5e5651ceaf083975b71df6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_i_pv_h264_access_unit.html" title="Generic, read-only H264 access unit interface.">IPvH264AccessUnit</a> interface to the buffer.  <a href="class_pv_buffer.html#a60aef226e5e5651ceaf083975b71df6a">More...</a><br /></td></tr>
<tr class="separator:a60aef226e5e5651ceaf083975b71df6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456f9511b055720315854be30314c0d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_i_pv_h264_access_unit.html">IPvH264AccessUnit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a456f9511b055720315854be30314c0d8">GetH264AccessUnit</a> () const</td></tr>
<tr class="memdesc:a456f9511b055720315854be30314c0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_i_pv_h264_access_unit.html" title="Generic, read-only H264 access unit interface.">IPvH264AccessUnit</a> interface to the buffer.  <a href="class_pv_buffer.html#a456f9511b055720315854be30314c0d8">More...</a><br /></td></tr>
<tr class="separator:a456f9511b055720315854be30314c0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911c7e091bc69acfdfe4c5be0935520a"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a911c7e091bc69acfdfe4c5be0935520a">GetDataPointer</a> () const</td></tr>
<tr class="memdesc:a911c7e091bc69acfdfe4c5be0935520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's data pointer.  <a href="class_pv_buffer.html#a911c7e091bc69acfdfe4c5be0935520a">More...</a><br /></td></tr>
<tr class="separator:a911c7e091bc69acfdfe4c5be0935520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569db0d7b1b3d79f28b7216407483795"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a569db0d7b1b3d79f28b7216407483795">GetDataPointer</a> ()</td></tr>
<tr class="memdesc:a569db0d7b1b3d79f28b7216407483795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's data pointer.  <a href="class_pv_buffer.html#a569db0d7b1b3d79f28b7216407483795">More...</a><br /></td></tr>
<tr class="separator:a569db0d7b1b3d79f28b7216407483795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd800d7b16dc1a41207dee5ec71401b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a9fd800d7b16dc1a41207dee5ec71401b">GetID</a> () const</td></tr>
<tr class="memdesc:a9fd800d7b16dc1a41207dee5ec71401b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's ID.  <a href="class_pv_buffer.html#a9fd800d7b16dc1a41207dee5ec71401b">More...</a><br /></td></tr>
<tr class="separator:a9fd800d7b16dc1a41207dee5ec71401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd62220f283c5b3c42444360390d2fdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#acd62220f283c5b3c42444360390d2fdf">SetID</a> (uint64_t aValue)</td></tr>
<tr class="memdesc:acd62220f283c5b3c42444360390d2fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer's ID.  <a href="class_pv_buffer.html#acd62220f283c5b3c42444360390d2fdf">More...</a><br /></td></tr>
<tr class="separator:acd62220f283c5b3c42444360390d2fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635552196657d56c074d13481c3091e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a635552196657d56c074d13481c3091e1">IsExtendedID</a> () const</td></tr>
<tr class="memdesc:a635552196657d56c074d13481c3091e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer is currently in extended ID mode.  <a href="class_pv_buffer.html#a635552196657d56c074d13481c3091e1">More...</a><br /></td></tr>
<tr class="separator:a635552196657d56c074d13481c3091e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa74a345a9164c61a68583340e22d41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a2fa74a345a9164c61a68583340e22d41">IsAttached</a> () const</td></tr>
<tr class="memdesc:a2fa74a345a9164c61a68583340e22d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the buffer has been attached (instead of allocated)  <a href="class_pv_buffer.html#a2fa74a345a9164c61a68583340e22d41">More...</a><br /></td></tr>
<tr class="separator:a2fa74a345a9164c61a68583340e22d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba8e0e95a75596be71db9141e9b290e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a8ba8e0e95a75596be71db9141e9b290e">IsAllocated</a> () const</td></tr>
<tr class="memdesc:a8ba8e0e95a75596be71db9141e9b290e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the buffer has been attached (instead of attached)  <a href="class_pv_buffer.html#a8ba8e0e95a75596be71db9141e9b290e">More...</a><br /></td></tr>
<tr class="separator:a8ba8e0e95a75596be71db9141e9b290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0444a28d226889f82106254bfb9758be"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a0444a28d226889f82106254bfb9758be">GetAcquiredSize</a> () const</td></tr>
<tr class="memdesc:a0444a28d226889f82106254bfb9758be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size in bytes of the block received by the data receiver including, if present, additional chunk data and headers, optional padding.  <a href="class_pv_buffer.html#a0444a28d226889f82106254bfb9758be">More...</a><br /></td></tr>
<tr class="separator:a0444a28d226889f82106254bfb9758be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8057927115456bedbbc4c4a5631c1653"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a8057927115456bedbbc4c4a5631c1653">GetRequiredSize</a> () const</td></tr>
<tr class="memdesc:a8057927115456bedbbc4c4a5631c1653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of buffer required to hold the acquired block including, if present, additional chunk data and headers, padding.  <a href="class_pv_buffer.html#a8057927115456bedbbc4c4a5631c1653">More...</a><br /></td></tr>
<tr class="separator:a8057927115456bedbbc4c4a5631c1653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64117db4752422cac6c02360a061190"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ae64117db4752422cac6c02360a061190">GetSize</a> () const</td></tr>
<tr class="memdesc:ae64117db4752422cac6c02360a061190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's allocated or attached size (total capacity) in bytes.  <a href="class_pv_buffer.html#ae64117db4752422cac6c02360a061190">More...</a><br /></td></tr>
<tr class="separator:ae64117db4752422cac6c02360a061190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec5abd18467aa4855a6ba46e22c6b02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a1ec5abd18467aa4855a6ba46e22c6b02">Reset</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType=<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a>)</td></tr>
<tr class="memdesc:a1ec5abd18467aa4855a6ba46e22c6b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstruct the object with a new payload type.  <a href="class_pv_buffer.html#a1ec5abd18467aa4855a6ba46e22c6b02">More...</a><br /></td></tr>
<tr class="separator:a1ec5abd18467aa4855a6ba46e22c6b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29ff9092536ed20f600b53d151df653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653">Alloc</a> (uint32_t aSize)</td></tr>
<tr class="memdesc:ae29ff9092536ed20f600b53d151df653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>.  <a href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653">More...</a><br /></td></tr>
<tr class="separator:ae29ff9092536ed20f600b53d151df653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5218f57bc2053b160d77e4943958bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#af5218f57bc2053b160d77e4943958bbe">AllocChunk</a> (uint32_t aSize)</td></tr>
<tr class="memdesc:af5218f57bc2053b160d77e4943958bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alloc a separate space for chunk data in this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>.  <a href="class_pv_buffer.html#af5218f57bc2053b160d77e4943958bbe">More...</a><br /></td></tr>
<tr class="separator:af5218f57bc2053b160d77e4943958bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897632d211ffca6e730d13f58447d1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a897632d211ffca6e730d13f58447d1d9">Free</a> ()</td></tr>
<tr class="memdesc:a897632d211ffca6e730d13f58447d1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees (de-allocates) the buffer's internal memory.  <a href="class_pv_buffer.html#a897632d211ffca6e730d13f58447d1d9">More...</a><br /></td></tr>
<tr class="separator:a897632d211ffca6e730d13f58447d1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad782ba5e249d2cb64195d9fe87c4a087"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ad782ba5e249d2cb64195d9fe87c4a087">FreeChunk</a> ()</td></tr>
<tr class="memdesc:ad782ba5e249d2cb64195d9fe87c4a087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees (de-allocates) an attached memory buffer of chunk data.  <a href="class_pv_buffer.html#ad782ba5e249d2cb64195d9fe87c4a087">More...</a><br /></td></tr>
<tr class="separator:ad782ba5e249d2cb64195d9fe87c4a087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88205cb108badafa8c268600fdaaa197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a88205cb108badafa8c268600fdaaa197">Attach</a> (void *aBuffer, uint32_t aSize)</td></tr>
<tr class="memdesc:a88205cb108badafa8c268600fdaaa197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> to an external memory buffer.  <a href="class_pv_buffer.html#a88205cb108badafa8c268600fdaaa197">More...</a><br /></td></tr>
<tr class="separator:a88205cb108badafa8c268600fdaaa197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ba206acb0a787322b1028ff67adb2a"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a96ba206acb0a787322b1028ff67adb2a">Detach</a> ()</td></tr>
<tr class="memdesc:a96ba206acb0a787322b1028ff67adb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attached memory buffer.  <a href="class_pv_buffer.html#a96ba206acb0a787322b1028ff67adb2a">More...</a><br /></td></tr>
<tr class="separator:a96ba206acb0a787322b1028ff67adb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1765f8778b5c7ee2198ce258ba354a0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ad1765f8778b5c7ee2198ce258ba354a0">GetBlockID</a> () const</td></tr>
<tr class="memdesc:ad1765f8778b5c7ee2198ce258ba354a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the block ID.  <a href="class_pv_buffer.html#ad1765f8778b5c7ee2198ce258ba354a0">More...</a><br /></td></tr>
<tr class="separator:ad1765f8778b5c7ee2198ce258ba354a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09304df721a8589f49d83cb9d50223c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ac09304df721a8589f49d83cb9d50223c">GetOperationResult</a> () const</td></tr>
<tr class="memdesc:ac09304df721a8589f49d83cb9d50223c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of aOperationResult when this buffer was last received through a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter.">PvStream</a>.  <a href="class_pv_buffer.html#ac09304df721a8589f49d83cb9d50223c">More...</a><br /></td></tr>
<tr class="separator:ac09304df721a8589f49d83cb9d50223c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f121b973ec5edff3bf78577a8f9925"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a81f121b973ec5edff3bf78577a8f9925">GetTimestamp</a> () const</td></tr>
<tr class="memdesc:a81f121b973ec5edff3bf78577a8f9925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's timestamp.  <a href="class_pv_buffer.html#a81f121b973ec5edff3bf78577a8f9925">More...</a><br /></td></tr>
<tr class="separator:a81f121b973ec5edff3bf78577a8f9925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd786b7f3b978f10f9853d439998f09a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#acd786b7f3b978f10f9853d439998f09a">GetReceptionTime</a> () const</td></tr>
<tr class="memdesc:acd786b7f3b978f10f9853d439998f09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's reception timestamp.  <a href="class_pv_buffer.html#acd786b7f3b978f10f9853d439998f09a">More...</a><br /></td></tr>
<tr class="separator:acd786b7f3b978f10f9853d439998f09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222bb43bb6a858e02b9173f04ebe6c63"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a222bb43bb6a858e02b9173f04ebe6c63">GetDuration</a> () const</td></tr>
<tr class="memdesc:a222bb43bb6a858e02b9173f04ebe6c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's duration.  <a href="class_pv_buffer.html#a222bb43bb6a858e02b9173f04ebe6c63">More...</a><br /></td></tr>
<tr class="separator:a222bb43bb6a858e02b9173f04ebe6c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7359326b0c36f66f2a09f842d50186c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a7359326b0c36f66f2a09f842d50186c0">SetTimestamp</a> (uint64_t aTimestamp)</td></tr>
<tr class="memdesc:a7359326b0c36f66f2a09f842d50186c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timestamp to place in the block leader.  <a href="class_pv_buffer.html#a7359326b0c36f66f2a09f842d50186c0">More...</a><br /></td></tr>
<tr class="separator:a7359326b0c36f66f2a09f842d50186c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4abb2345a30a55ea674e8879805879b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aa4abb2345a30a55ea674e8879805879b">SetDuration</a> (uint64_t aDuration)</td></tr>
<tr class="memdesc:aa4abb2345a30a55ea674e8879805879b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the duration of the buffer in the context of a stream.  <a href="class_pv_buffer.html#aa4abb2345a30a55ea674e8879805879b">More...</a><br /></td></tr>
<tr class="separator:aa4abb2345a30a55ea674e8879805879b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f19132c1de2e3ebb39f55b9bedc6c22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a6f19132c1de2e3ebb39f55b9bedc6c22">SetBlockID</a> (uint64_t aBlockID)</td></tr>
<tr class="memdesc:a6f19132c1de2e3ebb39f55b9bedc6c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the block ID of a buffer.  <a href="class_pv_buffer.html#a6f19132c1de2e3ebb39f55b9bedc6c22">More...</a><br /></td></tr>
<tr class="separator:a6f19132c1de2e3ebb39f55b9bedc6c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7480cad4aae78dc166ffb88121258506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a7480cad4aae78dc166ffb88121258506">SetReceptionTime</a> (uint64_t aReceptionTime)</td></tr>
<tr class="memdesc:a7480cad4aae78dc166ffb88121258506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reception time of a buffer.  <a href="class_pv_buffer.html#a7480cad4aae78dc166ffb88121258506">More...</a><br /></td></tr>
<tr class="separator:a7480cad4aae78dc166ffb88121258506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f8a62a7159ebe10af6fb66c4507657"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a68f8a62a7159ebe10af6fb66c4507657">GetPacketsRecoveredCount</a> () const</td></tr>
<tr class="memdesc:a68f8a62a7159ebe10af6fb66c4507657"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of lost packets successfully recovered by packet resend requests. Duplicate received packets are not counted.  <a href="class_pv_buffer.html#a68f8a62a7159ebe10af6fb66c4507657">More...</a><br /></td></tr>
<tr class="separator:a68f8a62a7159ebe10af6fb66c4507657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c345aa6f2ae0582ee05d7f16753170"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a14c345aa6f2ae0582ee05d7f16753170">GetPacketsRecoveredSingleResendCount</a> () const</td></tr>
<tr class="memdesc:a14c345aa6f2ae0582ee05d7f16753170"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of lost packets successfully recovered by packet resend requests without any resend request retries.  <a href="class_pv_buffer.html#a14c345aa6f2ae0582ee05d7f16753170">More...</a><br /></td></tr>
<tr class="separator:a14c345aa6f2ae0582ee05d7f16753170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeccf7f2a251bfe25a7fe58aae612723"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aeeccf7f2a251bfe25a7fe58aae612723">GetResendGroupRequestedCount</a> () const</td></tr>
<tr class="memdesc:aeeccf7f2a251bfe25a7fe58aae612723"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of resend requests issued by the data receiver.  <a href="class_pv_buffer.html#aeeccf7f2a251bfe25a7fe58aae612723">More...</a><br /></td></tr>
<tr class="separator:aeeccf7f2a251bfe25a7fe58aae612723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9783751415a933120dffdee2b97749f7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a9783751415a933120dffdee2b97749f7">GetResendPacketRequestedCount</a> () const</td></tr>
<tr class="memdesc:a9783751415a933120dffdee2b97749f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of packets the data receiver requests with ResendGroupRequested.  <a href="class_pv_buffer.html#a9783751415a933120dffdee2b97749f7">More...</a><br /></td></tr>
<tr class="separator:a9783751415a933120dffdee2b97749f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166f8b88390ee87c254d026b33cbb7ed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a166f8b88390ee87c254d026b33cbb7ed">GetLostPacketCount</a> () const</td></tr>
<tr class="memdesc:a166f8b88390ee87c254d026b33cbb7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packets that were not successfully delivered when this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> was filled by the data receiver.  <a href="class_pv_buffer.html#a166f8b88390ee87c254d026b33cbb7ed">More...</a><br /></td></tr>
<tr class="separator:a166f8b88390ee87c254d026b33cbb7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8a7603da07acdeb210d0f5e18c65c4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a5a8a7603da07acdeb210d0f5e18c65c4">GetIgnoredPacketCount</a> () const</td></tr>
<tr class="memdesc:a5a8a7603da07acdeb210d0f5e18c65c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packets received that were ignored when this buffer was filled by the data receiver.  <a href="class_pv_buffer.html#a5a8a7603da07acdeb210d0f5e18c65c4">More...</a><br /></td></tr>
<tr class="separator:a5a8a7603da07acdeb210d0f5e18c65c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe57e96e81d3b5367be11a9d3755091b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#abe57e96e81d3b5367be11a9d3755091b">GetRedundantPacketCount</a> () const</td></tr>
<tr class="memdesc:abe57e96e81d3b5367be11a9d3755091b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of packets received more than once.  <a href="class_pv_buffer.html#abe57e96e81d3b5367be11a9d3755091b">More...</a><br /></td></tr>
<tr class="separator:abe57e96e81d3b5367be11a9d3755091b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c48a96b93ac6c79aec69947981144d8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a3c48a96b93ac6c79aec69947981144d8">GetPacketOutOfOrderCount</a> () const</td></tr>
<tr class="memdesc:a3c48a96b93ac6c79aec69947981144d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of packets received out of order.  <a href="class_pv_buffer.html#a3c48a96b93ac6c79aec69947981144d8">More...</a><br /></td></tr>
<tr class="separator:a3c48a96b93ac6c79aec69947981144d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cd126a8ccf4e9ae24fbadb42738f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a31cd126a8ccf4e9ae24fbadb42738f39">GetMissingPacketIdsCount</a> (uint32_t &amp;aCount)</td></tr>
<tr class="memdesc:a31cd126a8ccf4e9ae24fbadb42738f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of missing packet groups that represent unpopulated areas of memory in this buffer.  <a href="class_pv_buffer.html#a31cd126a8ccf4e9ae24fbadb42738f39">More...</a><br /></td></tr>
<tr class="separator:a31cd126a8ccf4e9ae24fbadb42738f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1cdb64996318a1dceb0be5bf16dc13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a8e1cdb64996318a1dceb0be5bf16dc13">GetMissingPacketIds</a> (uint32_t aIndex, uint32_t &amp;aPacketIdLow, uint32_t &amp;aPacketIdHigh)</td></tr>
<tr class="memdesc:a8e1cdb64996318a1dceb0be5bf16dc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a missing packet group that represents an unpopulated area of memory in this buffer.  <a href="class_pv_buffer.html#a8e1cdb64996318a1dceb0be5bf16dc13">More...</a><br /></td></tr>
<tr class="separator:a8e1cdb64996318a1dceb0be5bf16dc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85ffe3e0c299debda560f22112f98ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aa85ffe3e0c299debda560f22112f98ec">ResetChunks</a> ()</td></tr>
<tr class="memdesc:aa85ffe3e0c299debda560f22112f98ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the internal chunk state.  <a href="class_pv_buffer.html#aa85ffe3e0c299debda560f22112f98ec">More...</a><br /></td></tr>
<tr class="separator:aa85ffe3e0c299debda560f22112f98ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ba6363162024610a5c52c63b4750ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a67ba6363162024610a5c52c63b4750ec">AddChunk</a> (uint32_t aID, const uint8_t *aData, uint32_t aLength)</td></tr>
<tr class="memdesc:a67ba6363162024610a5c52c63b4750ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add chunk data to the buffer.  <a href="class_pv_buffer.html#a67ba6363162024610a5c52c63b4750ec">More...</a><br /></td></tr>
<tr class="separator:a67ba6363162024610a5c52c63b4750ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258bbd9d4acd4ed054dc42ad8b9e71c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a258bbd9d4acd4ed054dc42ad8b9e71c2">SetChunkLayoutID</a> (uint32_t aChunkLayoutID)</td></tr>
<tr class="memdesc:a258bbd9d4acd4ed054dc42ad8b9e71c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the chunk data layout ID.  <a href="class_pv_buffer.html#a258bbd9d4acd4ed054dc42ad8b9e71c2">More...</a><br /></td></tr>
<tr class="separator:a258bbd9d4acd4ed054dc42ad8b9e71c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49759bffd9f1ee0ccb584b6000afb28e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a49759bffd9f1ee0ccb584b6000afb28e">HasChunks</a> () const</td></tr>
<tr class="memdesc:a49759bffd9f1ee0ccb584b6000afb28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the buffer has data chunks.  <a href="class_pv_buffer.html#a49759bffd9f1ee0ccb584b6000afb28e">More...</a><br /></td></tr>
<tr class="separator:a49759bffd9f1ee0ccb584b6000afb28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8586236cfce7b6149a0aeba5530616c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ac8586236cfce7b6149a0aeba5530616c">GetChunkCount</a> ()</td></tr>
<tr class="memdesc:ac8586236cfce7b6149a0aeba5530616c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of data chunks in the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>.  <a href="class_pv_buffer.html#ac8586236cfce7b6149a0aeba5530616c">More...</a><br /></td></tr>
<tr class="separator:ac8586236cfce7b6149a0aeba5530616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8377362f7f1f734dc2c013d280a5937a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a8377362f7f1f734dc2c013d280a5937a">GetChunkIDByIndex</a> (uint32_t aIndex, uint32_t &amp;aID)</td></tr>
<tr class="memdesc:a8377362f7f1f734dc2c013d280a5937a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of a chunk based on its index.  <a href="class_pv_buffer.html#a8377362f7f1f734dc2c013d280a5937a">More...</a><br /></td></tr>
<tr class="separator:a8377362f7f1f734dc2c013d280a5937a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7235900e888c98c167c41db82ac54ac6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a7235900e888c98c167c41db82ac54ac6">GetChunkSizeByIndex</a> (uint32_t aIndex)</td></tr>
<tr class="memdesc:a7235900e888c98c167c41db82ac54ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the data chunk at zero-based aIndex.  <a href="class_pv_buffer.html#a7235900e888c98c167c41db82ac54ac6">More...</a><br /></td></tr>
<tr class="separator:a7235900e888c98c167c41db82ac54ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96371f3d9f3728cd17ecf663b9af7ec"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ae96371f3d9f3728cd17ecf663b9af7ec">GetChunkSizeByID</a> (uint32_t aID)</td></tr>
<tr class="memdesc:ae96371f3d9f3728cd17ecf663b9af7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the data chunk identified by aID.  <a href="class_pv_buffer.html#ae96371f3d9f3728cd17ecf663b9af7ec">More...</a><br /></td></tr>
<tr class="separator:ae96371f3d9f3728cd17ecf663b9af7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffd2ac9e5755b95263be72b331e5176"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#afffd2ac9e5755b95263be72b331e5176">GetChunkRawDataByIndex</a> (uint32_t aIndex)</td></tr>
<tr class="memdesc:afffd2ac9e5755b95263be72b331e5176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the data chunk at zero-based aIndex.  <a href="class_pv_buffer.html#afffd2ac9e5755b95263be72b331e5176">More...</a><br /></td></tr>
<tr class="separator:afffd2ac9e5755b95263be72b331e5176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a00dd94c912ff14e487debf9599f7ae"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a1a00dd94c912ff14e487debf9599f7ae">GetChunkRawDataByID</a> (uint32_t aID)</td></tr>
<tr class="memdesc:a1a00dd94c912ff14e487debf9599f7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the data chunk with its ID matching aID.  <a href="class_pv_buffer.html#a1a00dd94c912ff14e487debf9599f7ae">More...</a><br /></td></tr>
<tr class="separator:a1a00dd94c912ff14e487debf9599f7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d72b9201deaef35ca428b8c532f7c0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a29d72b9201deaef35ca428b8c532f7c0">GetPayloadSize</a> () const</td></tr>
<tr class="memdesc:a29d72b9201deaef35ca428b8c532f7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns payload size in bytes, excluding any extra padding.  <a href="class_pv_buffer.html#a29d72b9201deaef35ca428b8c532f7c0">More...</a><br /></td></tr>
<tr class="separator:a29d72b9201deaef35ca428b8c532f7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060941455775fc8a712ae9af82709f95"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a060941455775fc8a712ae9af82709f95">GetChunkLayoutID</a> ()</td></tr>
<tr class="memdesc:a060941455775fc8a712ae9af82709f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chunk data layout ID.  <a href="class_pv_buffer.html#a060941455775fc8a712ae9af82709f95">More...</a><br /></td></tr>
<tr class="separator:a060941455775fc8a712ae9af82709f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aebdfa906085d5b0a344c329c8580a4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a1aebdfa906085d5b0a344c329c8580a4">GetChunkDataSize</a> () const</td></tr>
<tr class="memdesc:a1aebdfa906085d5b0a344c329c8580a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current chunk data size.  <a href="class_pv_buffer.html#a1aebdfa906085d5b0a344c329c8580a4">More...</a><br /></td></tr>
<tr class="separator:a1aebdfa906085d5b0a344c329c8580a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3e5e475344222ae30f1a043a12c234"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aeb3e5e475344222ae30f1a043a12c234">GetChunkDataCapacity</a> () const</td></tr>
<tr class="memdesc:aeb3e5e475344222ae30f1a043a12c234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current chunk data capacity.  <a href="class_pv_buffer.html#aeb3e5e475344222ae30f1a043a12c234">More...</a><br /></td></tr>
<tr class="separator:aeb3e5e475344222ae30f1a043a12c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b54e9eccbc8b23016cce121d3a20b43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a6b54e9eccbc8b23016cce121d3a20b43">IsHeaderValid</a> () const</td></tr>
<tr class="memdesc:a6b54e9eccbc8b23016cce121d3a20b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this buffer has valid header (GVSP) information.  <a href="class_pv_buffer.html#a6b54e9eccbc8b23016cce121d3a20b43">More...</a><br /></td></tr>
<tr class="separator:a6b54e9eccbc8b23016cce121d3a20b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f4fbd483b18c72c4b017df5a69ce3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#af1f4fbd483b18c72c4b017df5a69ce3e">IsTrailerValid</a> () const</td></tr>
<tr class="memdesc:af1f4fbd483b18c72c4b017df5a69ce3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this buffer has valid trailer (GVSP) information.  <a href="class_pv_buffer.html#af1f4fbd483b18c72c4b017df5a69ce3e">More...</a><br /></td></tr>
<tr class="separator:af1f4fbd483b18c72c4b017df5a69ce3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0d8f73ee036de311250ae5407907de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aff0d8f73ee036de311250ae5407907de">IsLargeLeaderTrailerEnabled</a> () const</td></tr>
<tr class="memdesc:aff0d8f73ee036de311250ae5407907de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this buffer has large data leader and data trailer enabled.  <a href="class_pv_buffer.html#aff0d8f73ee036de311250ae5407907de">More...</a><br /></td></tr>
<tr class="separator:aff0d8f73ee036de311250ae5407907de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afbebe17463fe09a03e19c5ac67193db8"><td class="memItemLeft" align="right" valign="top"><a id="afbebe17463fe09a03e19c5ac67193db8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvPipeline</b></td></tr>
<tr class="separator:afbebe17463fe09a03e19c5ac67193db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aba78b7171fe59591d8221ded00e204"><td class="memItemLeft" align="right" valign="top"><a id="a5aba78b7171fe59591d8221ded00e204"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvStream</b></td></tr>
<tr class="separator:a5aba78b7171fe59591d8221ded00e204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7bc3879443389244a8500bf7e99744"><td class="memItemLeft" align="right" valign="top"><a id="acd7bc3879443389244a8500bf7e99744"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvBufferConverter</b></td></tr>
<tr class="separator:acd7bc3879443389244a8500bf7e99744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fa79f796027b5c5d1f0462ec149ce7"><td class="memItemLeft" align="right" valign="top"><a id="ab1fa79f796027b5c5d1f0462ec149ce7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvBufferConverterRGBFilter</b></td></tr>
<tr class="separator:ab1fa79f796027b5c5d1f0462ec149ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf38d0d115717022f41fc66848ff4e71"><td class="memItemLeft" align="right" valign="top"><a id="abf38d0d115717022f41fc66848ff4e71"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvDeInterlacer</b></td></tr>
<tr class="separator:abf38d0d115717022f41fc66848ff4e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7b918eec3852cf47fde67a519f6308"><td class="memItemLeft" align="right" valign="top"><a id="acb7b918eec3852cf47fde67a519f6308"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvTransmitterGEV</b></td></tr>
<tr class="separator:acb7b918eec3852cf47fde67a519f6308"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a block of GigE Vision or USB3 Vision data in memory. </p>
<p>A <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> object is typically used to receive data from a GigE Vision or USB3 Vision transmitter or to transmit data to a GigE Vision receiver. To learn about receiving data from a GigE Vision or USB3 Vision transmitter, see <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter.">PvStream</a>. To learn about transmitting GigE Vision data to a GigE Vision receiver, see <a class="el" href="class_pv_transmitter_g_e_v.html" title="Class for transmitting blocks using the GigE Vision streaming protocol.">PvTransmitterGEV</a>.</p>
<p>A block of GigE Vision or USB3 Vision data has an associated payload which can be an image, raw data, file, chunk data, extended chunk data or device specific.</p>
<p>In order to access the payload specific data, use methods like <a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc" title="Returns the PvImage interface to the buffer.">PvBuffer::GetImage</a> in order to get a pointer to an interface giving you access to payload specific methods and properties.</p>
<p>The current payload type of a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> can be determined by using the <a class="el" href="class_pv_buffer.html#a0da48cd0feb9f44fa354e30cd06ec748" title="Returns the payload type currently used by the buffer.">PvBuffer::GetPayloadType</a> method.</p>
<p>In this section:</p><ul>
<li><a href="#configuring">Creating and configuring buffers</a></li>
<li><a href="#accessing">Accessing payload type specific data</a></li>
<li><a href="#processing">Processing images</a></li>
</ul>
<h2 id="configuring">Creating and configuring buffers</h2>
<p><b>To create and configure buffers:</b></p><ul>
<li>Create several buffers using the default constructor.</li>
<li>Set the size of the buffer. The method you use depends on whether you want to use an internally or externally controlled block of memory:<ul>
<li>To use memory that the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> object allocates and owns, use <a class="el" href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653" title="Allocates memory for this PvBuffer.">Alloc</a>.</li>
<li>To use memory that you control (external to the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> object), use <a class="el" href="class_pv_buffer.html#a88205cb108badafa8c268600fdaaa197" title="Attach this PvBuffer to an external memory buffer.">Attach</a>.</li>
</ul>
</li>
</ul>
<h2 id="accessing">Accessing payload type specific data</h2>
<p><b>To determine the payload type and access payload type specific data:</b></p><ul>
<li>Retrieve the <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type.">PvPayloadType</a> using <a class="el" href="class_pv_buffer.html#a0da48cd0feb9f44fa354e30cd06ec748" title="Returns the payload type currently used by the buffer.">PvBuffer::GetPayloadType</a></li>
<li>If <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type.">PvPayloadType</a> is <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a>, retrieve <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer from your <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a></li>
<li>Access image specific data through the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer, like <a class="el" href="class_i_pv_image.html#ad67d59f46291ca108647ea3f0a252468" title="Get the image&#39;s width.">PvImage::GetWidth</a>, <a class="el" href="class_i_pv_image.html#a2ce112d02586150fc53f05ed96258e8f" title="Get the image&#39;s height.">PvImage::GetHeight</a>, etc.</li>
<li>There is no need to release or delete the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> exists.</li>
</ul>
<h2 id="processing">Processing images</h2>
<p><b>To process an image:</b></p><ul>
<li>Retrieve a <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface to the buffer use <a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc" title="Returns the PvImage interface to the buffer.">GetImage</a></li>
<li>Test the success of the image acquisition. Use the <em>aOperationResult</em> parameter in <a class="el" href="class_pv_stream.html#a8bcce3d5c1f0b35e1db259fa82640e40" title="Attempt to retrieve a queued buffer.">PvStream::RetrieveBuffer</a> or <a class="el" href="class_pv_buffer.html#ac09304df721a8589f49d83cb9d50223c" title="Returns the value of aOperationResult when this buffer was last received through a PvStream.">PvBuffer::GetOperationResult</a></li>
<li>Process the image using your own code. You may process the image in place, if you wish. Use:<ul>
<li>#PvImage::GetAcquiredSize</li>
<li><a class="el" href="class_i_pv_image.html#a2ce112d02586150fc53f05ed96258e8f" title="Get the image&#39;s height.">PvImage::GetHeight</a> and <a class="el" href="class_i_pv_image.html#ad67d59f46291ca108647ea3f0a252468" title="Get the image&#39;s width.">PvImage::GetWidth</a></li>
<li><a class="el" href="class_i_pv_image.html#adbc19fcca5d4b06f85a9d8ca6eed17b1" title="Get the image&#39;s horizontal offset.">PvImage::GetOffsetX</a> and <a class="el" href="class_i_pv_image.html#a1d0db2ae7f766f943a30d914efe6fd64" title="Get the image&#39;s vertical offset.">PvImage::GetOffsetY</a> </li>
</ul>
</li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aec685815f08f9a47e7f8df24f8d90547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec685815f08f9a47e7f8df24f8d90547">&#9670;&nbsp;</a></span>PvBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvBuffer::PvBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&#160;</td>
          <td class="paramname"><em>aPayloadType</em> = <code><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPayloadType</td><td>The block type (default PvPayloadTypeImage). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a67ba6363162024610a5c52c63b4750ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ba6363162024610a5c52c63b4750ec">&#9670;&nbsp;</a></span>AddChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::AddChunk </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>aData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add chunk data to the buffer. </p>
<p>Add chunk data to the buffer payload section by specifying the ID of the chunk data.</p>
<p>See <a class="el" href="class_pv_buffer.html#aa85ffe3e0c299debda560f22112f98ec" title="Resets the internal chunk state.">ResetChunks</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>Chunk data ID for aIndex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aData</td><td>Payload data of the chunk data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aLength</td><td>Length of the payload data of the chunk, in bytes. Must be a multiple of 4 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_pv_result.html" title="Result information.">PvResult</a> is used to capture the success or failure of the operation:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca37cf2b6eb84b2f3286393bc9108cfab4">PvResult::Code::BUFFER_TOO_SMALL</a> There is not enough space in the buffer to add the chunk data.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> One of the input arguments is invalid. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#a925f91bdf279a04768a20f6666323d82">IPvChunkData</a>.</p>

</div>
</div>
<a id="ae29ff9092536ed20f600b53d151df653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29ff9092536ed20f600b53d151df653">&#9670;&nbsp;</a></span>Alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::Alloc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aSize</td><td>The size of the buffer, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cac194e39fb420655ac75525f53714bc2c">PvResult::Code::NOT_ENOUGH_MEMORY</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af5218f57bc2053b160d77e4943958bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5218f57bc2053b160d77e4943958bbe">&#9670;&nbsp;</a></span>AllocChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::AllocChunk </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alloc a separate space for chunk data in this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>. </p>
<p>Designed for use when attaching external data buffers that cannot be resized to accomodate chunk data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aSize</td><td>The size, in bytes, required for the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_pv_buffer.html#ad782ba5e249d2cb64195d9fe87c4a087" title="Frees (de-allocates) an attached memory buffer of chunk data.">FreeChunk</a> </dd></dl>

</div>
</div>
<a id="a88205cb108badafa8c268600fdaaa197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88205cb108badafa8c268600fdaaa197">&#9670;&nbsp;</a></span>Attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::Attach </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> to an external memory buffer. </p>
<p>To use an internal memory buffer, use <a class="el" href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653" title="Allocates memory for this PvBuffer.">Alloc</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffer</td><td>A pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSize</td><td>The size, in bytes, of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_pv_buffer.html#a96ba206acb0a787322b1028ff67adb2a" title="Releases an attached memory buffer.">Detach</a> </dd></dl>

</div>
</div>
<a id="a96ba206acb0a787322b1028ff67adb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ba206acb0a787322b1028ff67adb2a">&#9670;&nbsp;</a></span>Detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * PvBuffer::Detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases an attached memory buffer. </p>
<p>Does nothing other then resetting the memory buffer pointer to NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's location in memory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_pv_buffer.html#a88205cb108badafa8c268600fdaaa197" title="Attach this PvBuffer to an external memory buffer.">Attach</a> </dd></dl>

</div>
</div>
<a id="a897632d211ffca6e730d13f58447d1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897632d211ffca6e730d13f58447d1d9">&#9670;&nbsp;</a></span>Free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvBuffer::Free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees (de-allocates) the buffer's internal memory. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653" title="Allocates memory for this PvBuffer.">Alloc</a> </dd></dl>

</div>
</div>
<a id="ad782ba5e249d2cb64195d9fe87c4a087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad782ba5e249d2cb64195d9fe87c4a087">&#9670;&nbsp;</a></span>FreeChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvBuffer::FreeChunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees (de-allocates) an attached memory buffer of chunk data. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_pv_buffer.html#af5218f57bc2053b160d77e4943958bbe" title="Alloc a separate space for chunk data in this PvBuffer.">AllocChunk</a> </dd></dl>

</div>
</div>
<a id="a0444a28d226889f82106254bfb9758be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0444a28d226889f82106254bfb9758be">&#9670;&nbsp;</a></span>GetAcquiredSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetAcquiredSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size in bytes of the block received by the data receiver including, if present, additional chunk data and headers, optional padding. </p>
<dl class="section return"><dt>Returns</dt><dd>The size, in bytes, of bytes received for this buffer. </dd></dl>

</div>
</div>
<a id="ad1765f8778b5c7ee2198ce258ba354a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1765f8778b5c7ee2198ce258ba354a0">&#9670;&nbsp;</a></span>GetBlockID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvBuffer::GetBlockID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the block ID. </p>
<p>This method returns the block ID. The GigE Vision or USB3 Vision transmitter typically increments the value by 1 for each new image. You can use this value to ensure the blocks are in order and that none are missing. The value is unsigned and wraps around to 1 (skipping 0) when it reaches 65536 (for legacy 16bit Block ID mode) or 2^64 (for 64 bit Extended Block ID mode).</p>
<dl class="section return"><dt>Returns</dt><dd>The block ID </dd></dl>

</div>
</div>
<a id="ac8586236cfce7b6149a0aeba5530616c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8586236cfce7b6149a0aeba5530616c">&#9670;&nbsp;</a></span>GetChunkCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetChunkCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of data chunks in the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>. </p>
<p>If no data chunks are available, 0 is returned.</p>
<p>Counting chunks requires the chunks to be parsed and resolved which has a performance hit.</p>
<p>If you need to access chunks directly, you need to use this method to enumerate the chunks. If you access the chunks through GenICam, just use HasChunks to see if you need to attach the buffer the GenICam parameter array of the device.</p>
<dl class="section return"><dt>Returns</dt><dd>Data chunks count. 0 if no chunks are available. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#ad1e09c02b3cb16cbab36a93b25c2bbe5">IPvChunkData</a>.</p>

</div>
</div>
<a id="a1223464a644a765f10a387a4576298bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1223464a644a765f10a387a4576298bb">&#9670;&nbsp;</a></span>GetChunkData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_chunk_data.html">PvChunkData</a> * PvBuffer::GetChunkData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface to the buffer. </p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is PvPayloadTypeChunkData, a pointer to the <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface of the buffer is returned.</p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is NOT PvPayloadTypeChunkData, a NULL pointer is returned.</p>
<p>This <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> exists.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="a7cf182866d3ee27bbf54b35ff020fc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf182866d3ee27bbf54b35ff020fc81">&#9670;&nbsp;</a></span>GetChunkData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_pv_chunk_data.html">PvChunkData</a> * PvBuffer::GetChunkData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface to the buffer. </p>
<p>Const version.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="aeb3e5e475344222ae30f1a043a12c234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3e5e475344222ae30f1a043a12c234">&#9670;&nbsp;</a></span>GetChunkDataCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetChunkDataCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current chunk data capacity. </p>
<p>In a transmission context where you create the buffer, memory is allocated for chunks. This method returns how many bytes can still be added as chunk data.</p>
<p>One chunk is always made of 8-bytes of headers plus the chunk data length. You also need to reserve another 8-bytes for the main chunk (typically the image) unless you buffer only contains chunk data.</p>
<p>This method has no use in a reception context where the data receiver delivers the buffer. Use either the direct chunk access methods or the GenApi interface of the device to access chunk data.</p>
<dl class="section return"><dt>Returns</dt><dd>Chunk data capacity. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#aab9a7830547d36777fe6e8a4884aaf0f">IPvChunkData</a>.</p>

</div>
</div>
<a id="a1aebdfa906085d5b0a344c329c8580a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aebdfa906085d5b0a344c329c8580a4">&#9670;&nbsp;</a></span>GetChunkDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetChunkDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current chunk data size. </p>
<p>In a transmission context this method returns how many bytes are used for extra chunk data. It includes the chunk headers for all chunk data and if applicable the chunk header for the main chunk (typically the image).</p>
<p>This method has no use in a reception context where the data receiver delivers the buffer. Use either the direct chunk access methods or the GenApi interface of the device to access chunk data.</p>
<dl class="section return"><dt>Returns</dt><dd>Chunk data size in bytes. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#ae40c6ecf3525a265319b30b8a385c2c6">IPvChunkData</a>.</p>

</div>
</div>
<a id="a8377362f7f1f734dc2c013d280a5937a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8377362f7f1f734dc2c013d280a5937a">&#9670;&nbsp;</a></span>GetChunkIDByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::GetChunkIDByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ID of a chunk based on its index. </p>
<p>If the index is out of range or the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> does not have any data chunk 0 is returned in aID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aID</td><td>Data chunk ID for aIndex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_pv_result.html" title="Result information.">PvResult</a> is used to captured the success or failure of the operation as 0 can be a valid chunk ID:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa4357271e02951867594e0cc932c12f8">PvResult::Code::NOT_FOUND</a> if the index is out of range or the buffer does not have any chunks </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#adbcfcc0ab9ccdff61a55739356e8e5ad">IPvChunkData</a>.</p>

</div>
</div>
<a id="a060941455775fc8a712ae9af82709f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060941455775fc8a712ae9af82709f95">&#9670;&nbsp;</a></span>GetChunkLayoutID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetChunkLayoutID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the chunk data layout ID. </p>
<dl class="section return"><dt>Returns</dt><dd>The current chunk data layout ID. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#ac5907bd3acebd3b00e920861b4e6184f">IPvChunkData</a>.</p>

</div>
</div>
<a id="a1a00dd94c912ff14e487debf9599f7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a00dd94c912ff14e487debf9599f7ae">&#9670;&nbsp;</a></span>GetChunkRawDataByID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * PvBuffer::GetChunkRawDataByID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer to the data chunk with its ID matching aID. </p>
<p>If the aID chunk is not found or the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> does not have any chunks NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>Data chunk ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point to chunk data. NULL if the chunk ID is not found. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#aac016035ce32928e7ec56ea72d8513fa">IPvChunkData</a>.</p>

</div>
</div>
<a id="afffd2ac9e5755b95263be72b331e5176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffd2ac9e5755b95263be72b331e5176">&#9670;&nbsp;</a></span>GetChunkRawDataByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * PvBuffer::GetChunkRawDataByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer to the data chunk at zero-based aIndex. </p>
<p>Chunks are enumerated from the end of the payload data to its beginning. If the index is out of range or the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> does not have any data chunk NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point to chunk data. NULL if the index is out of range. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#a6e159b890b58b5dfa3ce44c5c92cacbe">IPvChunkData</a>.</p>

</div>
</div>
<a id="ae96371f3d9f3728cd17ecf663b9af7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96371f3d9f3728cd17ecf663b9af7ec">&#9670;&nbsp;</a></span>GetChunkSizeByID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetChunkSizeByID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size in bytes of the data chunk identified by aID. </p>
<p>If the aID chunk is not found or the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> does not have any chunks 0 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>Data chunk ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data chunk size. 0 if the chunk ID is not found. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#aa50a5624a81cd3ceca82f9e6c798c89e">IPvChunkData</a>.</p>

</div>
</div>
<a id="a7235900e888c98c167c41db82ac54ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7235900e888c98c167c41db82ac54ac6">&#9670;&nbsp;</a></span>GetChunkSizeByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetChunkSizeByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size in bytes of the data chunk at zero-based aIndex. </p>
<p>Chunks are enumerated from the end of the payload data to its beginning. If the index is out of range or the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> does not have any data chunk 0 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data chunk size. 0 if the index is out of range. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#a6a2019db32a8ae41a6709b3bb050be23">IPvChunkData</a>.</p>

</div>
</div>
<a id="a569db0d7b1b3d79f28b7216407483795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569db0d7b1b3d79f28b7216407483795">&#9670;&nbsp;</a></span>GetDataPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * PvBuffer::GetDataPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's data pointer. </p>
<p>Get the buffer's data.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the memory pointer. </dd></dl>

</div>
</div>
<a id="a911c7e091bc69acfdfe4c5be0935520a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911c7e091bc69acfdfe4c5be0935520a">&#9670;&nbsp;</a></span>GetDataPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * PvBuffer::GetDataPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's data pointer. </p>
<p>The <a class="el" href="class_pv_buffer.html#a911c7e091bc69acfdfe4c5be0935520a" title="Get the buffer&#39;s data pointer.">GetDataPointer</a> method returns a pointer to the buffer. To set the memory location, use <a class="el" href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653" title="Allocates memory for this PvBuffer.">Alloc</a> or <a class="el" href="class_pv_buffer.html#a88205cb108badafa8c268600fdaaa197" title="Attach this PvBuffer to an external memory buffer.">Attach</a>.</p>
<p>Const version.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the memory pointer. </dd></dl>

</div>
</div>
<a id="a222bb43bb6a858e02b9173f04ebe6c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222bb43bb6a858e02b9173f04ebe6c63">&#9670;&nbsp;</a></span>GetDuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvBuffer::GetDuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's duration. </p>
<p>Buffer duration when applicable. Typically used by stream decoders to control frame rate of a sequence of frames.</p>
<dl class="section return"><dt>Returns</dt><dd>Buffer duration. </dd></dl>

</div>
</div>
<a id="a60aef226e5e5651ceaf083975b71df6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60aef226e5e5651ceaf083975b71df6a">&#9670;&nbsp;</a></span>GetH264AccessUnit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv_h264_access_unit.html">IPvH264AccessUnit</a> * PvBuffer::GetH264AccessUnit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_i_pv_h264_access_unit.html" title="Generic, read-only H264 access unit interface.">IPvH264AccessUnit</a> interface to the buffer. </p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is PvPayloadTypeH264, a pointer to the <a class="el" href="class_i_pv_h264_access_unit.html" title="Generic, read-only H264 access unit interface.">IPvH264AccessUnit</a> interface of the buffer is returned.</p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is NOT <a class="el" href="class_i_pv_h264_access_unit.html" title="Generic, read-only H264 access unit interface.">IPvH264AccessUnit</a>, a NULL pointer is returned.</p>
<p>This <a class="el" href="class_i_pv_h264_access_unit.html" title="Generic, read-only H264 access unit interface.">IPvH264AccessUnit</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> exists.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_i_pv_h264_access_unit.html" title="Generic, read-only H264 access unit interface.">IPvH264AccessUnit</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="a456f9511b055720315854be30314c0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456f9511b055720315854be30314c0d8">&#9670;&nbsp;</a></span>GetH264AccessUnit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_i_pv_h264_access_unit.html">IPvH264AccessUnit</a> * PvBuffer::GetH264AccessUnit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_i_pv_h264_access_unit.html" title="Generic, read-only H264 access unit interface.">IPvH264AccessUnit</a> interface to the buffer. </p>
<p>Const version.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_i_pv_h264_access_unit.html" title="Generic, read-only H264 access unit interface.">IPvH264AccessUnit</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="a9fd800d7b16dc1a41207dee5ec71401b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd800d7b16dc1a41207dee5ec71401b">&#9670;&nbsp;</a></span>GetID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvBuffer::GetID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's ID. </p>
<p>See <a class="el" href="class_pv_buffer.html#acd62220f283c5b3c42444360390d2fdf" title="Set the buffer&#39;s ID.">SetID</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's ID. See <a class="el" href="class_pv_buffer.html#acd62220f283c5b3c42444360390d2fdf" title="Set the buffer&#39;s ID.">SetID</a>. </dd></dl>

</div>
</div>
<a id="a5a8a7603da07acdeb210d0f5e18c65c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8a7603da07acdeb210d0f5e18c65c4">&#9670;&nbsp;</a></span>GetIgnoredPacketCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetIgnoredPacketCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packets received that were ignored when this buffer was filled by the data receiver. </p>
<dl class="section return"><dt>Returns</dt><dd>The ignored packet count </dd></dl>

</div>
</div>
<a id="aa0e84f98d2c01c33aa6d58343fc242fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e84f98d2c01c33aa6d58343fc242fc">&#9670;&nbsp;</a></span>GetImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_image.html">PvImage</a> * PvBuffer::GetImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface to the buffer. </p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is PvPayloadTypeImage, a pointer to the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface of the buffer is returned.</p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is NOT PvPayloadTypeImage, a NULL pointer is returned.</p>
<p>This <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> exists.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="a55d64476c86d4db2a4aa60d8bb1ae7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d64476c86d4db2a4aa60d8bb1ae7f0">&#9670;&nbsp;</a></span>GetImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_pv_image.html">PvImage</a> * PvBuffer::GetImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface to the buffer. </p>
<p>Const version.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="a166f8b88390ee87c254d026b33cbb7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166f8b88390ee87c254d026b33cbb7ed">&#9670;&nbsp;</a></span>GetLostPacketCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetLostPacketCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packets that were not successfully delivered when this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> was filled by the data receiver. </p>
<dl class="section return"><dt>Returns</dt><dd>The lost packet count </dd></dl>

</div>
</div>
<a id="a8e1cdb64996318a1dceb0be5bf16dc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1cdb64996318a1dceb0be5bf16dc13">&#9670;&nbsp;</a></span>GetMissingPacketIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::GetMissingPacketIds </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aPacketIdLow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aPacketIdHigh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a missing packet group that represents an unpopulated area of memory in this buffer. </p>
<dl class="section note"><dt>Note</dt><dd>This is an advanced feature that requires knowledge of how GigE Vision data is transmitted. Refer to <a class="el" href="class_pv_buffer.html#a31cd126a8ccf4e9ae24fbadb42738f39" title="Get the number of missing packet groups that represent unpopulated areas of memory in this buffer.">GetMissingPacketIdsCount</a> for further details on how this feature is used.</dd>
<dd>
Does not apply to USB3 Vision devices which do not have the concept of packet resends.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>The index of the missing packet group being retrieved. </td></tr>
    <tr><td class="paramname">aPacketIdLow</td><td>The first packet of a range of missing packets. </td></tr>
    <tr><td class="paramname">aPacketIdHigh</td><td>The last packet of a range of missing packets. A value of 0xFFFFFF ( or 0xFFFFFFFF for ExtendedID ) indicates that the last packet of the block went missing and therefore the actual size of the block is unknown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> or <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca79f3ef17e3d22d3ac8a6840007ba261d">PvResult::Code::NOT_IMPLEMENTED</a>. </dd></dl>

</div>
</div>
<a id="a31cd126a8ccf4e9ae24fbadb42738f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cd126a8ccf4e9ae24fbadb42738f39">&#9670;&nbsp;</a></span>GetMissingPacketIdsCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::GetMissingPacketIdsCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of missing packet groups that represent unpopulated areas of memory in this buffer. </p>
<dl class="section note"><dt>Note</dt><dd>This is an advanced feature that requires knowledge of how GigE Vision data is transmitted.</dd>
<dd>
Does not apply to USB3 Vision devices which do not have the concept of packet resends.</dd></dl>
<p>When receiving data from a GigE Vision transmitter, network conditions may prevent the successful delivery of all the data for a given block. Although the eBUS data receiver provides a mechanism for requesting lost packets, there are cases when it is desirable to ignore missing packets and make use of a buffer that contains missing information. In some cases, there are portions of a block that are less important and can thus be disregarded. <a class="el" href="class_pv_buffer.html#a31cd126a8ccf4e9ae24fbadb42738f39" title="Get the number of missing packet groups that represent unpopulated areas of memory in this buffer.">GetMissingPacketIdsCount</a> and <a class="el" href="class_pv_buffer.html#a8e1cdb64996318a1dceb0be5bf16dc13" title="Get a missing packet group that represents an unpopulated area of memory in this buffer.">GetMissingPacketIds</a> can provide information about which packets were lost. To use this feature take note of the following procedure: </p><pre class="fragment">- Enable the feature that causes the data receiver to keep track of missing packets 
    (see the &lt;a href=streamparametersGEV.html#EnableMissingPacketsList&gt;EnableMissingPacketsList&lt;/a&gt; property of #PvStream).
- Optionally disable the mechanism that requests lost packets 
    (see the &lt;a href=streamparametersGEV.html#RequestMissingPackets&gt;RequestMissingPackets&lt;/a&gt; property of #PvStream).
- Check the operation result when a new block is received (see #PvBuffer::GetOperationResult).
- If the operation result is #PvResult::Code::MISSING_PACKETS, call #GetMissingPacketIdsCount to determine how many groups of packets are missing.
- Iterate through the missing packet groups using #GetMissingPacketIds.
- Note that there is no particular order to the missing packet groups that are returned.
- Take note of the packet size set on the GigE Vision transmitter from which you are receiving 
    to determine the areas of the payload where information is missing.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCount</td><td>The number of missing packet groups that represent unpopulated areas of memory in this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> or <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca79f3ef17e3d22d3ac8a6840007ba261d">PvResult::Code::NOT_IMPLEMENTED</a>. </dd></dl>

</div>
</div>
<a id="a0adf6ff1a75e7431dac15d3f0fde2f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adf6ff1a75e7431dac15d3f0fde2f08">&#9670;&nbsp;</a></span>GetMultiPartContainer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_pv_multi_part_container.html">IPvMultiPartContainer</a> * PvBuffer::GetMultiPartContainer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface to the buffer. </p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is PvPayloadTypeCunkData, a pointer to the <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface of the buffer is returned.</p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is NOT PvPayloadTypeChunkData, a NULL pointer is returned.</p>
<p>This <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> exists.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="a50c0f64a0660f7ae28a3ef8fbc9df47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c0f64a0660f7ae28a3ef8fbc9df47e">&#9670;&nbsp;</a></span>GetMultiPartContainer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_i_pv_multi_part_container.html">IPvMultiPartContainer</a> * PvBuffer::GetMultiPartContainer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface to the buffer. </p>
<p>Const version.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="ac09304df721a8589f49d83cb9d50223c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09304df721a8589f49d83cb9d50223c">&#9670;&nbsp;</a></span>GetOperationResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::GetOperationResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of aOperationResult when this buffer was last received through a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter.">PvStream</a>. </p>
<p>Buffers with BUFFER_TOO_SMALL, ABORTED, NOT_CONNECTED and NO_MORE_ITEM operation results are never returned to the user with <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter.">PvPipeline</a>. <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter.">PvPipeline</a> handles these operation results internally without returning the buffers. Buffers with these operation results can only reach the user when using <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter.">PvStream</a> directly.</p>
<dl class="section return"><dt>Returns</dt><dd>Result of the acquisition operation; Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca57f682171369be7611392e0fe458de73">PvResult::Code::NOT_INITIALIZED</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca8044711331afcc8f9607defdeb4f897f">PvResult::Code::TIMEOUT</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca02e7e13232d736f9215df059aa92280f">PvResult::Code::ABORTED</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca19573c67c2127b0f06f0031f3549fd2b">PvResult::Code::MISSING_PACKETS</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca37cf2b6eb84b2f3286393bc9108cfab4">PvResult::Code::BUFFER_TOO_SMALL</a>:</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cafe66d844ac9cddeebf0cae1dd0283cd4">PvResult::Code::IMAGE_ERROR</a> for images with grabber issues like data overrun or missing lines (complete or partial)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca57df90fcb05e5b2a6c3ec82b0d1ca7b0">PvResult::Code::RESENDS_FAILURE</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaf1d8836efaecbc4c70e38cbba38a9ad">PvResult::Code::TOO_MANY_RESENDS</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca122dbe89cae082c2990fb7481c000337">PvResult::Code::TOO_MANY_CONSECUTIVE_RESENDS</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa7ae611c1cc27c16e4eb3b05cf988dc6">PvResult::Code::INVALID_DATA_FORMAT</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca4e0a3590808a33d9fa4c4742690397d8">PvResult::Code::AUTO_ABORTED</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca1ba59804e9bbb3c4c7523e2992221d57">PvResult::Code::ERR_OVERFLOW</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_pv_stream.html#a8bcce3d5c1f0b35e1db259fa82640e40" title="Attempt to retrieve a queued buffer.">PvStream::RetrieveBuffer</a>, <a class="el" href="class_pv_pipeline.html#aa1924fc80cff8d6c566f1429e0dc682f" title="Retrieve the next acquired block.">PvPipeline::RetrieveNextBuffer</a> </dd></dl>

</div>
</div>
<a id="a3c48a96b93ac6c79aec69947981144d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c48a96b93ac6c79aec69947981144d8">&#9670;&nbsp;</a></span>GetPacketOutOfOrderCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetPacketOutOfOrderCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of packets received out of order. </p>
<dl class="section return"><dt>Returns</dt><dd>The packet out of order count </dd></dl>

</div>
</div>
<a id="a68f8a62a7159ebe10af6fb66c4507657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f8a62a7159ebe10af6fb66c4507657">&#9670;&nbsp;</a></span>GetPacketsRecoveredCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetPacketsRecoveredCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of lost packets successfully recovered by packet resend requests. Duplicate received packets are not counted. </p>
<dl class="section return"><dt>Returns</dt><dd>The expected resend count </dd></dl>

</div>
</div>
<a id="a14c345aa6f2ae0582ee05d7f16753170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c345aa6f2ae0582ee05d7f16753170">&#9670;&nbsp;</a></span>GetPacketsRecoveredSingleResendCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetPacketsRecoveredSingleResendCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of lost packets successfully recovered by packet resend requests without any resend request retries. </p>
<dl class="section return"><dt>Returns</dt><dd>The expected resend count </dd></dl>

</div>
</div>
<a id="a29d72b9201deaef35ca428b8c532f7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d72b9201deaef35ca428b8c532f7c0">&#9670;&nbsp;</a></span>GetPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetPayloadSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns payload size in bytes, excluding any extra padding. </p>
<p>Gets the size in bytes of the block received by the data receiver including, if present, additional chunk data and headers.</p>
<p>Different than GetAcquiredSize as it does not include optional additional padding when data chunks are present.</p>
<p>If data chunks are not present, this method returns the same value as GetAcquiredSize as extra padding is only an issue when data chunks are present.</p>
<p>This method is required in order to parse the chunk data using GenICam.</p>
<dl class="section return"><dt>Returns</dt><dd>Payload size in bytes, excluding any extra padding. </dd></dl>

</div>
</div>
<a id="a0da48cd0feb9f44fa354e30cd06ec748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da48cd0feb9f44fa354e30cd06ec748">&#9670;&nbsp;</a></span>GetPayloadType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> PvBuffer::GetPayloadType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the payload type currently used by the buffer. </p>
<p>If data chunks are available, the buffer payload type is the same as if no data chunks were available. Use GetChunkCount to determine if chunks are available.</p>
<dl class="section return"><dt>Returns</dt><dd>PvPayloadType The current payload type for the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>. See <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type.">PvPayloadType</a> enum. </dd></dl>

</div>
</div>
<a id="a9302a71fa4bd8541862a085f686d5583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9302a71fa4bd8541862a085f686d5583">&#9670;&nbsp;</a></span>GetPleoraCompressed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_pleora_compressed.html">PvPleoraCompressed</a> * PvBuffer::GetPleoraCompressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_pleora_compressed.html" title="Pleora compressed interface to a PvBuffer.">PvPleoraCompressed</a> interface to the buffer. </p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is PvPayloadTypePleoraCompressed, a pointer to the <a class="el" href="class_pv_pleora_compressed.html" title="Pleora compressed interface to a PvBuffer.">PvPleoraCompressed</a> interface of the buffer is returned.</p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is NOT PvPayloadTypePleoraCompressed, a NULL pointer is returned.</p>
<p>This <a class="el" href="class_pv_pleora_compressed.html" title="Pleora compressed interface to a PvBuffer.">PvPleoraCompressed</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> exists.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_pleora_compressed.html" title="Pleora compressed interface to a PvBuffer.">PvPleoraCompressed</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="a33e51926ba97155ff817639bf976cfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e51926ba97155ff817639bf976cfbb">&#9670;&nbsp;</a></span>GetPleoraCompressed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_pv_pleora_compressed.html">PvPleoraCompressed</a> * PvBuffer::GetPleoraCompressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_pleora_compressed.html" title="Pleora compressed interface to a PvBuffer.">PvPleoraCompressed</a> interface to the buffer. </p>
<p>Const version.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_pleora_compressed.html" title="Pleora compressed interface to a PvBuffer.">PvPleoraCompressed</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="aeecd2a17dd53ef52ad1873bdb63df1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecd2a17dd53ef52ad1873bdb63df1b4">&#9670;&nbsp;</a></span>GetRawData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_raw_data.html">PvRawData</a> * PvBuffer::GetRawData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface to the buffer. </p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is PvPayloadTypeRawData, a pointer to the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface of the buffer is returned.</p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is NOT PvPayloadTypeRawData, a NULL pointer is returned.</p>
<p>This <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> exists.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="a1243108931822c8f4149546ffbb081ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1243108931822c8f4149546ffbb081ac">&#9670;&nbsp;</a></span>GetRawData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_pv_raw_data.html">PvRawData</a> * PvBuffer::GetRawData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface to the buffer. </p>
<p>Const version.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer.">PvRawData</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a id="acd786b7f3b978f10f9853d439998f09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd786b7f3b978f10f9853d439998f09a">&#9670;&nbsp;</a></span>GetReceptionTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvBuffer::GetReceptionTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's reception timestamp. </p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's reception time on the host, in micro seconds. Not an absolute time value. </dd></dl>

</div>
</div>
<a id="abe57e96e81d3b5367be11a9d3755091b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe57e96e81d3b5367be11a9d3755091b">&#9670;&nbsp;</a></span>GetRedundantPacketCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetRedundantPacketCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of packets received more than once. </p>
<dl class="section return"><dt>Returns</dt><dd>The redundant packet count </dd></dl>

</div>
</div>
<a id="a8057927115456bedbbc4c4a5631c1653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8057927115456bedbbc4c4a5631c1653">&#9670;&nbsp;</a></span>GetRequiredSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetRequiredSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of buffer required to hold the acquired block including, if present, additional chunk data and headers, padding. </p>
<dl class="section return"><dt>Returns</dt><dd>The size, in bytes, required to hold the block in this buffer. </dd></dl>

</div>
</div>
<a id="aeeccf7f2a251bfe25a7fe58aae612723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeccf7f2a251bfe25a7fe58aae612723">&#9670;&nbsp;</a></span>GetResendGroupRequestedCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetResendGroupRequestedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of resend requests issued by the data receiver. </p>
<dl class="section return"><dt>Returns</dt><dd>The resend requested count </dd></dl>

</div>
</div>
<a id="a9783751415a933120dffdee2b97749f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9783751415a933120dffdee2b97749f7">&#9670;&nbsp;</a></span>GetResendPacketRequestedCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetResendPacketRequestedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of packets the data receiver requests with ResendGroupRequested. </p>
<dl class="section return"><dt>Returns</dt><dd>The received resend requested packet count </dd></dl>

</div>
</div>
<a id="ae64117db4752422cac6c02360a061190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64117db4752422cac6c02360a061190">&#9670;&nbsp;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's allocated or attached size (total capacity) in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's (allocated or attached) size in bytes </dd></dl>

</div>
</div>
<a id="a81f121b973ec5edff3bf78577a8f9925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f121b973ec5edff3bf78577a8f9925">&#9670;&nbsp;</a></span>GetTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvBuffer::GetTimestamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's timestamp. </p>
<p>With hardware timestamps and GigE Vision devices, the device defines the timestamp tick frequency. The effective value can be retrieved from the GenApi interface of the device.</p>
<p>With hardware timestamps and USB3 Vision devices, timestamps are always defined in nanoseconds.</p>
<p>With software timestamps the timestamps are in micro seconds.</p>
<p>Use the <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter.">PvStream</a> GenApi interface to configure whether hardware or software time stamps are used.</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's hardware timestamp; For Pleora devices, this is the value of the relative timestamp clock when the grabber began receiving data from the camera head - on the rising edge of the FVAL. </dd></dl>

</div>
</div>
<a id="a49759bffd9f1ee0ccb584b6000afb28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49759bffd9f1ee0ccb584b6000afb28e">&#9670;&nbsp;</a></span>HasChunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::HasChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the buffer has data chunks. </p>
<p>Unlike GetChunkCount, chunks do not need to be parsed or resolved with this method.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the buffer holds data chunks, false if not. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#af6d7d3b304116a7bfa1a16d89b973c37">IPvChunkData</a>.</p>

</div>
</div>
<a id="a8ba8e0e95a75596be71db9141e9b290e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba8e0e95a75596be71db9141e9b290e">&#9670;&nbsp;</a></span>IsAllocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsAllocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the buffer has been attached (instead of attached) </p>
<dl class="section return"><dt>Returns</dt><dd>True if allocated. </dd></dl>

</div>
</div>
<a id="a2fa74a345a9164c61a68583340e22d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa74a345a9164c61a68583340e22d41">&#9670;&nbsp;</a></span>IsAttached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsAttached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the buffer has been attached (instead of allocated) </p>
<dl class="section return"><dt>Returns</dt><dd>True if attached. </dd></dl>

</div>
</div>
<a id="a635552196657d56c074d13481c3091e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635552196657d56c074d13481c3091e1">&#9670;&nbsp;</a></span>IsExtendedID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsExtendedID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the buffer is currently in extended ID mode. </p>
<p>When the extended ID mode is not enabled, the maximum block ID is 0xFFFFFF and the maximum packet ID is 0xFFFFFF as per the GEV 1.X specification. When the extended ID mode is enabled, the maximum block ID is 0xFFFFFFFFFFFFFFFF and the maximum packet ID is 0xFFFFFFFF as per the GEV 2.X specification.</p>
<p>When a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is received, the extended ID mode is initialized based on the information received by <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter.">PvStream</a>. When a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> is sent, the extended ID mode will be initialized by the <a class="el" href="class_pv_transmitter_g_e_v.html#a69c8cf9d29815558782c3b9cebad93f1" title="Constructor.">PvTransmitterGEV::PvTransmitterGEV</a> according to its configuration.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the extended if mode is in usage: </dd></dl>

</div>
</div>
<a id="a6b54e9eccbc8b23016cce121d3a20b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b54e9eccbc8b23016cce121d3a20b43">&#9670;&nbsp;</a></span>IsHeaderValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsHeaderValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this buffer has valid header (GVSP) information. </p>
<p>If the buffer header is not valid (missing) the buffer has to be manipulated with extreme caution. To start with, it is impossible to confirm the payload type. The timestamp and other shared header information is not valid. Finally, information specific to some payload types (like with, height, pixel format, etc. for the image payload type) is not available or valid this buffer.</p>
<p>When a buffer is attached or allocated for use other than receiving GVSP data, this attribute evaluates to true in order to appear as valid.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the GVSP header is valid. </dd></dl>

</div>
</div>
<a id="aff0d8f73ee036de311250ae5407907de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0d8f73ee036de311250ae5407907de">&#9670;&nbsp;</a></span>IsLargeLeaderTrailerEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsLargeLeaderTrailerEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this buffer has large data leader and data trailer enabled. </p>
<p>Return whether this buffer has MultiPart LargeLeaderTrailer.</p>
<p>If the buffer is used for Multi-Part streaming, the maximum allowed number of parts is limited by whether Large data leader and trailer is enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the Large Data Leader and Trailer is enabled on the buffer which contains Multi-part. </dd></dl>

</div>
</div>
<a id="af1f4fbd483b18c72c4b017df5a69ce3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f4fbd483b18c72c4b017df5a69ce3e">&#9670;&nbsp;</a></span>IsTrailerValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsTrailerValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this buffer has valid trailer (GVSP) information. </p>
<p>If the buffer trailer is not valid (missing) some information about the buffer could be missing. As an example, the image payload type confirms the number of lines received in the trailer.</p>
<p>When a buffer is attached or allocated for use other than receiving GVSP data, this attribute evaluates to true in order to appear as valid.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the GVSP header is valid. </dd></dl>

</div>
</div>
<a id="a1ec5abd18467aa4855a6ba46e22c6b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec5abd18467aa4855a6ba46e22c6b02">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&#160;</td>
          <td class="paramname"><em>aPayloadType</em> = <code><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstruct the object with a new payload type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPayloadType</td><td>The payload type to reset the buffer to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<a id="aa85ffe3e0c299debda560f22112f98ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85ffe3e0c299debda560f22112f98ec">&#9670;&nbsp;</a></span>ResetChunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvBuffer::ResetChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the internal chunk state. </p>
<p>Used when creating <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> with chunks for transmission. This method should always be called before adding the first chunk block to a buffer. It removes chunk data from the previous sequence of AddChunk.</p>
<p>If you are adding more than one chunk block to a buffer, you would normally perform this sequence for every buffer setup for transmission: </p><pre class="fragment">- lBuffer-&gt;ResetChunks();
- lBuffer-&gt;SetChunkLayoutID( CHUNKLAYOUTID );
- lBuffer-&gt;AddChunk( CHUNKID1, lData1, sizeof( lData1 ) );
- lBuffer-&gt;AddChunk( CHUNKID2, lData2, sizeof( lData2 ) );
</pre> 
<p>Implements <a class="el" href="class_i_pv_chunk_data.html#aaf2aa453fdc92066e4a491f8f52dda38">IPvChunkData</a>.</p>

</div>
</div>
<a id="a6f19132c1de2e3ebb39f55b9bedc6c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f19132c1de2e3ebb39f55b9bedc6c22">&#9670;&nbsp;</a></span>SetBlockID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::SetBlockID </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>aBlockID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the block ID of a buffer. </p>
<p>Should only be used for creating synthetic test PvBuffers or copies of a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> which caries some information over from the original.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aBlockID</td><td>Block ID to assign to the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<a id="a258bbd9d4acd4ed054dc42ad8b9e71c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258bbd9d4acd4ed054dc42ad8b9e71c2">&#9670;&nbsp;</a></span>SetChunkLayoutID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvBuffer::SetChunkLayoutID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aChunkLayoutID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the chunk data layout ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aChunkLayoutID</td><td>Chunk data layout ID. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_pv_chunk_data.html#a0ea33b069bc01272e029d59c73f3a301">IPvChunkData</a>.</p>

</div>
</div>
<a id="aa4abb2345a30a55ea674e8879805879b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4abb2345a30a55ea674e8879805879b">&#9670;&nbsp;</a></span>SetDuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::SetDuration </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>aDuration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the duration of the buffer in the context of a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aDuration</td><td>Duration of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<a id="acd62220f283c5b3c42444360390d2fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd62220f283c5b3c42444360390d2fdf">&#9670;&nbsp;</a></span>SetID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvBuffer::SetID </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>aValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buffer's ID. </p>
<p>The <a class="el" href="class_pv_buffer.html#acd62220f283c5b3c42444360390d2fdf" title="Set the buffer&#39;s ID.">SetID</a> method lets you assign an arbitrary number to a buffer. When you retrieve the buffer later, you can also recover the number you assigned.</p>
<p>The ID is completely arbitrary and solely available for your own use. It can be useful to keep track of buffers in an application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>The buffer's ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7480cad4aae78dc166ffb88121258506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7480cad4aae78dc166ffb88121258506">&#9670;&nbsp;</a></span>SetReceptionTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::SetReceptionTime </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>aReceptionTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the reception time of a buffer. </p>
<p>Should only be used for creating synthetic test PvBuffers or copies of a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> which caries some information over from the original.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aReceptionTime</td><td>Reception tiome to assign to the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<a id="a7359326b0c36f66f2a09f842d50186c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7359326b0c36f66f2a09f842d50186c0">&#9670;&nbsp;</a></span>SetTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::SetTimestamp </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>aTimestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the timestamp to place in the block leader. </p>
<p>When transmitting blocks to a GigE Vision receiver, by default, the timestamp on outgoing blocks is zero. However, the calling application may set a timestamp on the outgoing blocks if desired by calling <a class="el" href="class_pv_buffer.html#a7359326b0c36f66f2a09f842d50186c0" title="Set the timestamp to place in the block leader.">SetTimestamp</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aTimestamp</td><td>The timestamp to set in the block leader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_buffer_8h_source.html">PvBuffer.h</a></li>
<li>PvBuffer.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2024 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
