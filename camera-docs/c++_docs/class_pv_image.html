<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvImage Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v6.4.0.6670 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_pv_image.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_pv_image-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvImage Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Image interface to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>.  
 <a href="class_pv_image.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_pv_image_8h_source.html">PvImage.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9aed3afbfd2a31a4c433ed22ec417136"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a9aed3afbfd2a31a4c433ed22ec417136">GetMaximumChunkLength</a> () const =0</td></tr>
<tr class="memdesc:a9aed3afbfd2a31a4c433ed22ec417136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum chunk length possible for the currently allocated memory vs image attributes.  <a href="class_pv_image.html#a9aed3afbfd2a31a4c433ed22ec417136">More...</a><br /></td></tr>
<tr class="separator:a9aed3afbfd2a31a4c433ed22ec417136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70939ec96dd997f9591e5d5f9ee8546"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#af70939ec96dd997f9591e5d5f9ee8546">GetRequiredSize</a> () const =0</td></tr>
<tr class="memdesc:af70939ec96dd997f9591e5d5f9ee8546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of buffer required to hold the acquired image.  <a href="class_pv_image.html#af70939ec96dd997f9591e5d5f9ee8546">More...</a><br /></td></tr>
<tr class="separator:af70939ec96dd997f9591e5d5f9ee8546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dcc6fc3eb803a363de515ef5cd6677"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a99dcc6fc3eb803a363de515ef5cd6677">GetEffectiveImageSize</a> () const =0</td></tr>
<tr class="memdesc:a99dcc6fc3eb803a363de515ef5cd6677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effective image size.  <a href="class_pv_image.html#a99dcc6fc3eb803a363de515ef5cd6677">More...</a><br /></td></tr>
<tr class="separator:a99dcc6fc3eb803a363de515ef5cd6677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f1e383b4daa6844da6fcff05f53b4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ab8f1e383b4daa6844da6fcff05f53b4d">SetOffsetX</a> (uint32_t aValue)=0</td></tr>
<tr class="memdesc:ab8f1e383b4daa6844da6fcff05f53b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Offset X attribute of the image.  <a href="class_pv_image.html#ab8f1e383b4daa6844da6fcff05f53b4d">More...</a><br /></td></tr>
<tr class="separator:ab8f1e383b4daa6844da6fcff05f53b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e630284925b3e9564a82176fc7bb33d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a9e630284925b3e9564a82176fc7bb33d">SetOffsetY</a> (uint32_t aValue)=0</td></tr>
<tr class="memdesc:a9e630284925b3e9564a82176fc7bb33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Offset X attribute of the image.  <a href="class_pv_image.html#a9e630284925b3e9564a82176fc7bb33d">More...</a><br /></td></tr>
<tr class="separator:a9e630284925b3e9564a82176fc7bb33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c197b02052c8099a9b36ba98146c97"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a68c197b02052c8099a9b36ba98146c97">Alloc</a> (uint32_t aSizeX, uint32_t aSizeY, <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType, uint16_t aPaddingX=0, uint16_t aPaddingY=0, uint32_t aMaximumChunkLength=0)=0</td></tr>
<tr class="memdesc:a68c197b02052c8099a9b36ba98146c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a>.  <a href="class_pv_image.html#a68c197b02052c8099a9b36ba98146c97">More...</a><br /></td></tr>
<tr class="separator:a68c197b02052c8099a9b36ba98146c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67571501558ca7b1fe1ed9e0e0167ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#af67571501558ca7b1fe1ed9e0e0167ac">Free</a> ()=0</td></tr>
<tr class="memdesc:af67571501558ca7b1fe1ed9e0e0167ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees (de-allocates) the buffer's internal memory.  <a href="class_pv_image.html#af67571501558ca7b1fe1ed9e0e0167ac">More...</a><br /></td></tr>
<tr class="separator:af67571501558ca7b1fe1ed9e0e0167ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba682973d97f8d1fdf2ba1507130c2d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a4ba682973d97f8d1fdf2ba1507130c2d">Attach</a> (void *aRawBuffer, uint32_t aSizeX, uint32_t aSizeY, <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType, uint16_t aPaddingX=0, uint16_t aPaddingY=0, uint32_t aMaximumChunkLength=0)=0</td></tr>
<tr class="memdesc:a4ba682973d97f8d1fdf2ba1507130c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> to an external memory buffer.  <a href="class_pv_image.html#a4ba682973d97f8d1fdf2ba1507130c2d">More...</a><br /></td></tr>
<tr class="separator:a4ba682973d97f8d1fdf2ba1507130c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c979e5a90f89c0e861cb8763af6204"><td class="memItemLeft" align="right" valign="top">virtual uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#af2c979e5a90f89c0e861cb8763af6204">Detach</a> ()=0</td></tr>
<tr class="memdesc:af2c979e5a90f89c0e861cb8763af6204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attached memory buffer.  <a href="class_pv_image.html#af2c979e5a90f89c0e861cb8763af6204">More...</a><br /></td></tr>
<tr class="separator:af2c979e5a90f89c0e861cb8763af6204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f934725a4f94a73991e674e76f2f98"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#aa8f934725a4f94a73991e674e76f2f98">IsPartialLineMissing</a> () const =0</td></tr>
<tr class="memdesc:aa8f934725a4f94a73991e674e76f2f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, the grabber (on the device) was missing at least one pixel in at least one of the lines when the frame was grabbed.  <a href="class_pv_image.html#aa8f934725a4f94a73991e674e76f2f98">More...</a><br /></td></tr>
<tr class="separator:aa8f934725a4f94a73991e674e76f2f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1c5dbb0eaa652370e63f1833c0153f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a7b1c5dbb0eaa652370e63f1833c0153f">IsFullLineMissing</a> () const =0</td></tr>
<tr class="memdesc:a7b1c5dbb0eaa652370e63f1833c0153f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, the grabber (on the device) was missing at least one line when the frame was grabbed.  <a href="class_pv_image.html#a7b1c5dbb0eaa652370e63f1833c0153f">More...</a><br /></td></tr>
<tr class="separator:a7b1c5dbb0eaa652370e63f1833c0153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968f711726beaa527f60acc223d058e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a968f711726beaa527f60acc223d058e4">SetEOFByLineCount</a> (bool aValue=true)=0</td></tr>
<tr class="memdesc:a968f711726beaa527f60acc223d058e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates the EOFByLineCount used by Pleora video interfaces.  <a href="class_pv_image.html#a968f711726beaa527f60acc223d058e4">More...</a><br /></td></tr>
<tr class="separator:a968f711726beaa527f60acc223d058e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b3a2c69399df8e40024dae89f113dc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a49b3a2c69399df8e40024dae89f113dc">IsEOFByLineCount</a> () const =0</td></tr>
<tr class="memdesc:a49b3a2c69399df8e40024dae89f113dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Frame by Line Count status bit.  <a href="class_pv_image.html#a49b3a2c69399df8e40024dae89f113dc">More...</a><br /></td></tr>
<tr class="separator:a49b3a2c69399df8e40024dae89f113dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b84103b3d3aad04435151e1484314b2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a0b84103b3d3aad04435151e1484314b2">IsInterlacedEven</a> () const =0</td></tr>
<tr class="memdesc:a0b84103b3d3aad04435151e1484314b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> is an interlaced Even field.  <a href="class_pv_image.html#a0b84103b3d3aad04435151e1484314b2">More...</a><br /></td></tr>
<tr class="separator:a0b84103b3d3aad04435151e1484314b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db2a061b1209812e21e5765f1fc708d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a1db2a061b1209812e21e5765f1fc708d">IsInterlacedOdd</a> () const =0</td></tr>
<tr class="memdesc:a1db2a061b1209812e21e5765f1fc708d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> is an interlaced Odd field.  <a href="class_pv_image.html#a1db2a061b1209812e21e5765f1fc708d">More...</a><br /></td></tr>
<tr class="separator:a1db2a061b1209812e21e5765f1fc708d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e596b7b5d815ad86563bfc1adcec94"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a74e596b7b5d815ad86563bfc1adcec94">IsImageDropped</a> () const =0</td></tr>
<tr class="memdesc:a74e596b7b5d815ad86563bfc1adcec94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image dropped status bit.  <a href="class_pv_image.html#a74e596b7b5d815ad86563bfc1adcec94">More...</a><br /></td></tr>
<tr class="separator:a74e596b7b5d815ad86563bfc1adcec94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d13d07a3914acc0cec2878dc7db90a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a79d13d07a3914acc0cec2878dc7db90a">IsDataOverrun</a> () const =0</td></tr>
<tr class="memdesc:a79d13d07a3914acc0cec2878dc7db90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data overrun status bit.  <a href="class_pv_image.html#a79d13d07a3914acc0cec2878dc7db90a">More...</a><br /></td></tr>
<tr class="separator:a79d13d07a3914acc0cec2878dc7db90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d1a54ca842826bb07b4bd41734889e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#af6d1a54ca842826bb07b4bd41734889e">GetBuffer</a> ()=0</td></tr>
<tr class="memdesc:af6d1a54ca842826bb07b4bd41734889e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> belongs to.  <a href="class_pv_image.html#af6d1a54ca842826bb07b4bd41734889e">More...</a><br /></td></tr>
<tr class="separator:af6d1a54ca842826bb07b4bd41734889e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6b8fcde5c19d5e97eea5b213cf0468"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a2b6b8fcde5c19d5e97eea5b213cf0468">HasWatermark</a> () const =0</td></tr>
<tr class="memdesc:a2b6b8fcde5c19d5e97eea5b213cf0468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the watermark tag.  <a href="class_pv_image.html#a2b6b8fcde5c19d5e97eea5b213cf0468">More...</a><br /></td></tr>
<tr class="separator:a2b6b8fcde5c19d5e97eea5b213cf0468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_pv_image"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_pv_image')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_pv_image.html">IPvImage</a></td></tr>
<tr class="memitem:a63bab05a26fcd4b073141f978557fd76 inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#a63bab05a26fcd4b073141f978557fd76">GetDataPointer</a> () const =0</td></tr>
<tr class="memdesc:a63bab05a26fcd4b073141f978557fd76 inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image's data pointer.  <a href="class_i_pv_image.html#a63bab05a26fcd4b073141f978557fd76">More...</a><br /></td></tr>
<tr class="separator:a63bab05a26fcd4b073141f978557fd76 inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1212878a2a49438762a4c63b0cb0d2f4 inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#a1212878a2a49438762a4c63b0cb0d2f4">GetDataPointer</a> ()=0</td></tr>
<tr class="memdesc:a1212878a2a49438762a4c63b0cb0d2f4 inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image's data pointer.  <a href="class_i_pv_image.html#a1212878a2a49438762a4c63b0cb0d2f4">More...</a><br /></td></tr>
<tr class="separator:a1212878a2a49438762a4c63b0cb0d2f4 inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f7a501765de4efcb2b5731a1cd489b inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#aa5f7a501765de4efcb2b5731a1cd489b">GetImageSize</a> () const =0</td></tr>
<tr class="memdesc:aa5f7a501765de4efcb2b5731a1cd489b inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual image size within the payload or buffer.  <a href="class_i_pv_image.html#aa5f7a501765de4efcb2b5731a1cd489b">More...</a><br /></td></tr>
<tr class="separator:aa5f7a501765de4efcb2b5731a1cd489b inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67d59f46291ca108647ea3f0a252468 inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#ad67d59f46291ca108647ea3f0a252468">GetWidth</a> () const =0</td></tr>
<tr class="memdesc:ad67d59f46291ca108647ea3f0a252468 inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image's width.  <a href="class_i_pv_image.html#ad67d59f46291ca108647ea3f0a252468">More...</a><br /></td></tr>
<tr class="separator:ad67d59f46291ca108647ea3f0a252468 inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce112d02586150fc53f05ed96258e8f inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#a2ce112d02586150fc53f05ed96258e8f">GetHeight</a> () const =0</td></tr>
<tr class="memdesc:a2ce112d02586150fc53f05ed96258e8f inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image's height.  <a href="class_i_pv_image.html#a2ce112d02586150fc53f05ed96258e8f">More...</a><br /></td></tr>
<tr class="separator:a2ce112d02586150fc53f05ed96258e8f inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92e8ead027b939985c7b7db8954ca79 inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#ad92e8ead027b939985c7b7db8954ca79">GetPixelType</a> () const =0</td></tr>
<tr class="memdesc:ad92e8ead027b939985c7b7db8954ca79 inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer's pixel type.  <a href="class_i_pv_image.html#ad92e8ead027b939985c7b7db8954ca79">More...</a><br /></td></tr>
<tr class="separator:ad92e8ead027b939985c7b7db8954ca79 inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bb2b0995758104e350f331d6576738 inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#ae8bb2b0995758104e350f331d6576738">GetBitsPerPixel</a> () const =0</td></tr>
<tr class="memdesc:ae8bb2b0995758104e350f331d6576738 inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many bits are required to hold a pixel using the current buffer's pixel type.  <a href="class_i_pv_image.html#ae8bb2b0995758104e350f331d6576738">More...</a><br /></td></tr>
<tr class="separator:ae8bb2b0995758104e350f331d6576738 inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc19fcca5d4b06f85a9d8ca6eed17b1 inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#adbc19fcca5d4b06f85a9d8ca6eed17b1">GetOffsetX</a> () const =0</td></tr>
<tr class="memdesc:adbc19fcca5d4b06f85a9d8ca6eed17b1 inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image's horizontal offset.  <a href="class_i_pv_image.html#adbc19fcca5d4b06f85a9d8ca6eed17b1">More...</a><br /></td></tr>
<tr class="separator:adbc19fcca5d4b06f85a9d8ca6eed17b1 inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0db2ae7f766f943a30d914efe6fd64 inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#a1d0db2ae7f766f943a30d914efe6fd64">GetOffsetY</a> () const =0</td></tr>
<tr class="memdesc:a1d0db2ae7f766f943a30d914efe6fd64 inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image's vertical offset.  <a href="class_i_pv_image.html#a1d0db2ae7f766f943a30d914efe6fd64">More...</a><br /></td></tr>
<tr class="separator:a1d0db2ae7f766f943a30d914efe6fd64 inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9d053fc39bc5c53f2bfccb4ffa1fdc inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#a7c9d053fc39bc5c53f2bfccb4ffa1fdc">GetPaddingX</a> () const =0</td></tr>
<tr class="memdesc:a7c9d053fc39bc5c53f2bfccb4ffa1fdc inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the horizontal image padding.  <a href="class_i_pv_image.html#a7c9d053fc39bc5c53f2bfccb4ffa1fdc">More...</a><br /></td></tr>
<tr class="separator:a7c9d053fc39bc5c53f2bfccb4ffa1fdc inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5b61b03e94f0e17591c77bb3722439 inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#adf5b61b03e94f0e17591c77bb3722439">GetPaddingY</a> () const =0</td></tr>
<tr class="memdesc:adf5b61b03e94f0e17591c77bb3722439 inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vertical image padding.  <a href="class_i_pv_image.html#adf5b61b03e94f0e17591c77bb3722439">More...</a><br /></td></tr>
<tr class="separator:adf5b61b03e94f0e17591c77bb3722439 inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82034e824dd5a741bc8b358c76814b8e inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#a82034e824dd5a741bc8b358c76814b8e">GetBlockID</a> () const =0</td></tr>
<tr class="memdesc:a82034e824dd5a741bc8b358c76814b8e inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the block ID.  <a href="class_i_pv_image.html#a82034e824dd5a741bc8b358c76814b8e">More...</a><br /></td></tr>
<tr class="separator:a82034e824dd5a741bc8b358c76814b8e inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9246a41d8b364965a5a39963ffbfe6e8 inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#a9246a41d8b364965a5a39963ffbfe6e8">GetTimestamp</a> () const =0</td></tr>
<tr class="memdesc:a9246a41d8b364965a5a39963ffbfe6e8 inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image's timestamp.  <a href="class_i_pv_image.html#a9246a41d8b364965a5a39963ffbfe6e8">More...</a><br /></td></tr>
<tr class="separator:a9246a41d8b364965a5a39963ffbfe6e8 inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd71b07aae0a8d0683c159ba44e0a062 inherit pub_methods_class_i_pv_image"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_image.html#afd71b07aae0a8d0683c159ba44e0a062">GetReceptionTime</a> () const =0</td></tr>
<tr class="memdesc:afd71b07aae0a8d0683c159ba44e0a062 inherit pub_methods_class_i_pv_image"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's reception timestamp.  <a href="class_i_pv_image.html#afd71b07aae0a8d0683c159ba44e0a062">More...</a><br /></td></tr>
<tr class="separator:afd71b07aae0a8d0683c159ba44e0a062 inherit pub_methods_class_i_pv_image"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aff436f997e7bf40a79a8972e186130ef"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#aff436f997e7bf40a79a8972e186130ef">GetPixelSize</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)</td></tr>
<tr class="memdesc:aff436f997e7bf40a79a8972e186130ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method returning the pixel size in bits for a specific pixel type.  <a href="class_pv_image.html#aff436f997e7bf40a79a8972e186130ef">More...</a><br /></td></tr>
<tr class="separator:aff436f997e7bf40a79a8972e186130ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9d41a325260130856f7c1e24dc5996"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#afe9d41a325260130856f7c1e24dc5996">IsPixelColor</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)</td></tr>
<tr class="memdesc:afe9d41a325260130856f7c1e24dc5996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method returning whether a pixel type is color or not.  <a href="class_pv_image.html#afe9d41a325260130856f7c1e24dc5996">More...</a><br /></td></tr>
<tr class="separator:afe9d41a325260130856f7c1e24dc5996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819302e1e982f867941a5bf11ce248ec"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a819302e1e982f867941a5bf11ce248ec">IsPixelHighRes</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)</td></tr>
<tr class="memdesc:a819302e1e982f867941a5bf11ce248ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method returning whether a pixel type is higher than 8-bit per channel or not.  <a href="class_pv_image.html#a819302e1e982f867941a5bf11ce248ec">More...</a><br /></td></tr>
<tr class="separator:a819302e1e982f867941a5bf11ce248ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac14e08fb6c14614f1f0f78d5ccad129"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#aac14e08fb6c14614f1f0f78d5ccad129">GetBitsPerComponent</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)</td></tr>
<tr class="memdesc:aac14e08fb6c14614f1f0f78d5ccad129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method returning the number of bit per components for a pixel type.  <a href="class_pv_image.html#aac14e08fb6c14614f1f0f78d5ccad129">More...</a><br /></td></tr>
<tr class="separator:aac14e08fb6c14614f1f0f78d5ccad129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8e6a3d234f68547debc99cb5b453f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_pv_string.html">PvString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#acc8e6a3d234f68547debc99cb5b453f3">PixelTypeToString</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)</td></tr>
<tr class="memdesc:acc8e6a3d234f68547debc99cb5b453f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method returning a string representation of a pixel type.  <a href="class_pv_image.html#acc8e6a3d234f68547debc99cb5b453f3">More...</a><br /></td></tr>
<tr class="separator:acc8e6a3d234f68547debc99cb5b453f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a41f14acd0cb6c490187a1b9adeac7774"><td class="memItemLeft" align="right" valign="top"><a id="a41f14acd0cb6c490187a1b9adeac7774"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvTruesenseConverter</b></td></tr>
<tr class="separator:a41f14acd0cb6c490187a1b9adeac7774"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Image interface to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>. </p>
<p>A <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> represents a generic buffer with no specific payload type. If the payload type is image, the user can obtain a pointer to a <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> buffer interface through <a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc" title="Returns the PvImage interface to the buffer.">PvBuffer::GetImage</a>.</p>
<p>This <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> exists.</p>
<h2 id="accessing">Accessing image specific data</h2>
<p><b>To determinate the payload type and access image specific data:</b></p><ul>
<li>Retrieve the <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type.">PvPayloadType</a> using <a class="el" href="class_pv_buffer.html#a0da48cd0feb9f44fa354e30cd06ec748" title="Returns the payload type currently used by the buffer.">PvBuffer::GetPayloadType</a></li>
<li>If <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type.">PvPayloadType</a> is PvPayloadTypeImage, retrieve <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer from your <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a></li>
<li>Access image specific data through the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer, like <a class="el" href="class_i_pv_image.html#ad67d59f46291ca108647ea3f0a252468" title="Get the image&#39;s width.">PvImage::GetWidth</a>, <a class="el" href="class_i_pv_image.html#a2ce112d02586150fc53f05ed96258e8f" title="Get the image&#39;s height.">PvImage::GetHeight</a>, etc.</li>
<li>There is no need to release or delete the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> pointer. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> exists. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a68c197b02052c8099a9b36ba98146c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c197b02052c8099a9b36ba98146c97">&#9670;&nbsp;</a></span>Alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvImage::Alloc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aPaddingX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aPaddingY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMaximumChunkLength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a>. </p>
<p>Allocs a <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> of specific width, height and pixel format</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aSizeX</td><td>The width of the image, in pixels. See <a class="el" href="class_i_pv_image.html#ad67d59f46291ca108647ea3f0a252468" title="Get the image&#39;s width.">GetWidth</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSizeY</td><td>The height of the image, in pixels. See <a class="el" href="class_i_pv_image.html#a2ce112d02586150fc53f05ed96258e8f" title="Get the image&#39;s height.">GetHeight</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>The GEV pixel type from which the pixel depth is extracted. For supported pixel types, see <a class="el" href="_pv_pixel_type_8h.html">PvPixelType.h</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPaddingX</td><td>The horizontal padding of the image, in pixels. See <a class="el" href="class_i_pv_image.html#a7c9d053fc39bc5c53f2bfccb4ffa1fdc" title="Get the horizontal image padding.">GetPaddingX</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPaddingY</td><td>The vertical padding of the image, in pixels. See <a class="el" href="class_i_pv_image.html#adf5b61b03e94f0e17591c77bb3722439" title="Get the vertical image padding.">GetPaddingY</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aMaximumChunkLength</td><td>The chunk size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cac194e39fb420655ac75525f53714bc2c">PvResult::Code::NOT_ENOUGH_MEMORY</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4ba682973d97f8d1fdf2ba1507130c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba682973d97f8d1fdf2ba1507130c2d">&#9670;&nbsp;</a></span>Attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvImage::Attach </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aRawBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aPaddingX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aPaddingY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMaximumChunkLength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> to an external memory buffer. </p>
<p>This method is identical to <a class="el" href="class_pv_image.html#a68c197b02052c8099a9b36ba98146c97" title="Allocates memory for this PvImage.">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t,uint32_t)</a>, with the following exceptions:</p><ul>
<li>This method uses an external memory buffer, controlled by the caller.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRawBuffer</td><td>A pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSizeX</td><td>See <a class="el" href="class_pv_image.html#a68c197b02052c8099a9b36ba98146c97" title="Allocates memory for this PvImage.">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t,uint32_t)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSizeY</td><td>See <a class="el" href="class_pv_image.html#a68c197b02052c8099a9b36ba98146c97" title="Allocates memory for this PvImage.">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t,uint32_t)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>See <a class="el" href="class_pv_image.html#a68c197b02052c8099a9b36ba98146c97" title="Allocates memory for this PvImage.">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t,uint32_t)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPaddingX</td><td>See <a class="el" href="class_pv_image.html#a68c197b02052c8099a9b36ba98146c97" title="Allocates memory for this PvImage.">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t,uint32_t)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPaddingY</td><td>See <a class="el" href="class_pv_image.html#a68c197b02052c8099a9b36ba98146c97" title="Allocates memory for this PvImage.">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t,uint32_t)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aMaximumChunkLength</td><td>See <a class="el" href="class_pv_image.html#a68c197b02052c8099a9b36ba98146c97" title="Allocates memory for this PvImage.">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t,uint32_t)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af2c979e5a90f89c0e861cb8763af6204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c979e5a90f89c0e861cb8763af6204">&#9670;&nbsp;</a></span>Detach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * PvImage::Detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases an attached memory buffer. </p>
<p>Does nothing other then resetting the memory buffer pointer to NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's location in memory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_pv_image.html#a4ba682973d97f8d1fdf2ba1507130c2d" title="Attach this PvImage to an external memory buffer.">Attach</a> </dd></dl>

</div>
</div>
<a id="af67571501558ca7b1fe1ed9e0e0167ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67571501558ca7b1fe1ed9e0e0167ac">&#9670;&nbsp;</a></span>Free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvImage::Free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees (de-allocates) the buffer's internal memory. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_pv_image.html#a68c197b02052c8099a9b36ba98146c97" title="Allocates memory for this PvImage.">Alloc</a> </dd></dl>

</div>
</div>
<a id="aac14e08fb6c14614f1f0f78d5ccad129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac14e08fb6c14614f1f0f78d5ccad129">&#9670;&nbsp;</a></span>GetBitsPerComponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetBitsPerComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method returning the number of bit per components for a pixel type. </p>
<p>PvPixelMono8 and PvPixelRGBa8 would be 8. Mono16, PvPixelRGB16, PvPixelBayerRG16 would be 16, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>Pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if higher than 8 bit per channel. </dd></dl>

</div>
</div>
<a id="af6d1a54ca842826bb07b4bd41734889e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d1a54ca842826bb07b4bd41734889e">&#9670;&nbsp;</a></span>GetBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_buffer.html">PvBuffer</a> * PvImage::GetBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> belongs to. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>. </dd></dl>

</div>
</div>
<a id="a99dcc6fc3eb803a363de515ef5cd6677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dcc6fc3eb803a363de515ef5cd6677">&#9670;&nbsp;</a></span>GetEffectiveImageSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetEffectiveImageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Effective image size. </p>
<p>Uses same size x and y as <a class="el" href="class_i_pv_image.html#aa5f7a501765de4efcb2b5731a1cd489b" title="Actual image size within the payload or buffer.">GetImageSize()</a> but excludes all padding.</p>
<dl class="section return"><dt>Returns</dt><dd>The effective image size </dd></dl>

</div>
</div>
<a id="a9aed3afbfd2a31a4c433ed22ec417136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aed3afbfd2a31a4c433ed22ec417136">&#9670;&nbsp;</a></span>GetMaximumChunkLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetMaximumChunkLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum chunk length possible for the currently allocated memory vs image attributes. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum chunk length, in bytes. </dd></dl>

</div>
</div>
<a id="aff436f997e7bf40a79a8972e186130ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff436f997e7bf40a79a8972e186130ef">&#9670;&nbsp;</a></span>GetPixelSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetPixelSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method returning the pixel size in bits for a specific pixel type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>Pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pixel size, in bits. </dd></dl>

</div>
</div>
<a id="af70939ec96dd997f9591e5d5f9ee8546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70939ec96dd997f9591e5d5f9ee8546">&#9670;&nbsp;</a></span>GetRequiredSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetRequiredSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of buffer required to hold the acquired image. </p>
<p>This attribute is valid if the last image acquisition was successful or if it failed because the buffer was too small. It can be used to re-allocate the acquisition buffers if the acquisition failed because the buffer was too small.</p>
<p>The required size is only computed for the last image - based on the number of lines as provided in the GigE Vision or USB3 Vision streaming protocol trailer.</p>
<p>It is possible that with devices outputting images of varying length (like line scan cameras) that the last image required size may be smaller than the maximum possible size.</p>
<p>In order to be 100% sure of allocating buffers correctly, you should either hard code the buffer size to known big enough sizes or use the device GenICam GevPayloadSize parameter for dynamic cases.</p>
<dl class="section return"><dt>Returns</dt><dd>The size, in bytes, required to hold the image in this buffer. </dd></dl>

</div>
</div>
<a id="a2b6b8fcde5c19d5e97eea5b213cf0468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6b8fcde5c19d5e97eea5b213cf0468">&#9670;&nbsp;</a></span>HasWatermark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::HasWatermark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the watermark tag. </p>
<p>A watermark is applied onto the image if the system is not provided with a valid eBUS receiver license.</p>
<p>Use this method to check if a watermark was applied to the image or not.</p>
<dl class="section return"><dt>Returns</dt><dd>The watermark tag. </dd></dl>

</div>
</div>
<a id="a79d13d07a3914acc0cec2878dc7db90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d13d07a3914acc0cec2878dc7db90a">&#9670;&nbsp;</a></span>IsDataOverrun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsDataOverrun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data overrun status bit. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there was a data overrun. False otherwise. </dd></dl>

</div>
</div>
<a id="a49b3a2c69399df8e40024dae89f113dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b3a2c69399df8e40024dae89f113dc">&#9670;&nbsp;</a></span>IsEOFByLineCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsEOFByLineCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End of Frame by Line Count status bit. </p>
<dl class="section return"><dt>Returns</dt><dd>True if previous frame was NOT the last one of a sequence of sub frames. False otherwise. </dd></dl>

</div>
</div>
<a id="a7b1c5dbb0eaa652370e63f1833c0153f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1c5dbb0eaa652370e63f1833c0153f">&#9670;&nbsp;</a></span>IsFullLineMissing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsFullLineMissing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, the grabber (on the device) was missing at least one line when the frame was grabbed. </p>
<dl class="section return"><dt>Returns</dt><dd>True if full lines were missing, false otherwise </dd></dl>

</div>
</div>
<a id="a74e596b7b5d815ad86563bfc1adcec94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e596b7b5d815ad86563bfc1adcec94">&#9670;&nbsp;</a></span>IsImageDropped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsImageDropped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Image dropped status bit. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the previous frame was dropped. False otherwise. </dd></dl>

</div>
</div>
<a id="a0b84103b3d3aad04435151e1484314b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b84103b3d3aad04435151e1484314b2">&#9670;&nbsp;</a></span>IsInterlacedEven()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsInterlacedEven </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> is an interlaced Even field. </p>
<dl class="section return"><dt>Returns</dt><dd>True interlaced Even field. False otherwise. </dd></dl>

</div>
</div>
<a id="a1db2a061b1209812e21e5765f1fc708d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db2a061b1209812e21e5765f1fc708d">&#9670;&nbsp;</a></span>IsInterlacedOdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsInterlacedOdd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer.">PvImage</a> is an interlaced Odd field. </p>
<dl class="section return"><dt>Returns</dt><dd>True interlaced Odd field. False otherwise. </dd></dl>

</div>
</div>
<a id="aa8f934725a4f94a73991e674e76f2f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f934725a4f94a73991e674e76f2f98">&#9670;&nbsp;</a></span>IsPartialLineMissing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsPartialLineMissing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, the grabber (on the device) was missing at least one pixel in at least one of the lines when the frame was grabbed. </p>
<dl class="section return"><dt>Returns</dt><dd>True if at least one pixel was missing, false otherwise </dd></dl>

</div>
</div>
<a id="afe9d41a325260130856f7c1e24dc5996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9d41a325260130856f7c1e24dc5996">&#9670;&nbsp;</a></span>IsPixelColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsPixelColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method returning whether a pixel type is color or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>Pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if color. </dd></dl>

</div>
</div>
<a id="a819302e1e982f867941a5bf11ce248ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819302e1e982f867941a5bf11ce248ec">&#9670;&nbsp;</a></span>IsPixelHighRes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsPixelHighRes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method returning whether a pixel type is higher than 8-bit per channel or not. </p>
<p>10, 12, 14 and 16-bit pixel type are considered high resolution. RGB8 counts as 8 so high resolution here means per channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>Pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if higher than 8 bit per channel. </dd></dl>

</div>
</div>
<a id="acc8e6a3d234f68547debc99cb5b453f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8e6a3d234f68547debc99cb5b453f3">&#9670;&nbsp;</a></span>PixelTypeToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_string.html">PvString</a> PvImage::PixelTypeToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method returning a string representation of a pixel type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>Pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation of the pixel type. </dd></dl>

</div>
</div>
<a id="a968f711726beaa527f60acc223d058e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968f711726beaa527f60acc223d058e4">&#9670;&nbsp;</a></span>SetEOFByLineCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvImage::SetEOFByLineCount </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aValue</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simulates the EOFByLineCount used by Pleora video interfaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aValue</td><td>True to enable, false to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8f1e383b4daa6844da6fcff05f53b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f1e383b4daa6844da6fcff05f53b4d">&#9670;&nbsp;</a></span>SetOffsetX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvImage::SetOffsetX </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Offset X attribute of the image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aValue</td><td>New value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e630284925b3e9564a82176fc7bb33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e630284925b3e9564a82176fc7bb33d">&#9670;&nbsp;</a></span>SetOffsetY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvImage::SetOffsetY </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Offset X attribute of the image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aValue</td><td>New value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_image_8h_source.html">PvImage.h</a></li>
<li>PvImage.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2024 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
