<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvTransmitterGEV Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v6.4.0.6670 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_pv_transmitter_g_e_v.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_pv_transmitter_g_e_v-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvTransmitterGEV Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for transmitting blocks using the GigE Vision streaming protocol.  
 <a href="class_pv_transmitter_g_e_v.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69c8cf9d29815558782c3b9cebad93f1"><td class="memItemLeft" align="right" valign="top"><a id="a69c8cf9d29815558782c3b9cebad93f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a69c8cf9d29815558782c3b9cebad93f1">PvTransmitterGEV</a> ()</td></tr>
<tr class="memdesc:a69c8cf9d29815558782c3b9cebad93f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a69c8cf9d29815558782c3b9cebad93f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b07ea9a0141aa28fdee17c0d3fb6875"><td class="memItemLeft" align="right" valign="top"><a id="a4b07ea9a0141aa28fdee17c0d3fb6875"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a4b07ea9a0141aa28fdee17c0d3fb6875">~PvTransmitterGEV</a> ()</td></tr>
<tr class="memdesc:a4b07ea9a0141aa28fdee17c0d3fb6875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a4b07ea9a0141aa28fdee17c0d3fb6875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa35cbac01bd79d250664c5a09bfda3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a0fa35cbac01bd79d250664c5a09bfda3">Open</a> (<a class="el" href="class_pv_string.html">PvString</a> aDestinationIPAddress, uint16_t aDestinationPort, <a class="el" href="class_pv_string.html">PvString</a> aSourceIPAddress=&quot;&quot;, uint16_t aSourcePort=0, bool aDontFrag=true, bool aExtendedIDs=false, uint32_t aBuffersCapacity=64, bool aTimestampWhenSending=false, uint32_t aNumberOfPendingResendRequests=32, uint32_t aNumberOfBuffersHoldForResends=0)</td></tr>
<tr class="memdesc:a0fa35cbac01bd79d250664c5a09bfda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a socket to begin transmitting data.  <a href="class_pv_transmitter_g_e_v.html#a0fa35cbac01bd79d250664c5a09bfda3">More...</a><br /></td></tr>
<tr class="separator:a0fa35cbac01bd79d250664c5a09bfda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cccdb8b355d061ad99b64f888cb14a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a44cccdb8b355d061ad99b64f888cb14a">Close</a> ()</td></tr>
<tr class="memdesc:a44cccdb8b355d061ad99b64f888cb14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop sending data and close the socket.  <a href="class_pv_transmitter_g_e_v.html#a44cccdb8b355d061ad99b64f888cb14a">More...</a><br /></td></tr>
<tr class="separator:a44cccdb8b355d061ad99b64f888cb14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3e2d6577a798686398a37dbe1afd7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a2c3e2d6577a798686398a37dbe1afd7d">LoadBufferPool</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffers, uint32_t aBufferCount)</td></tr>
<tr class="memdesc:a2c3e2d6577a798686398a37dbe1afd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a set of free buffers into the pool.  <a href="class_pv_transmitter_g_e_v.html#a2c3e2d6577a798686398a37dbe1afd7d">More...</a><br /></td></tr>
<tr class="separator:a2c3e2d6577a798686398a37dbe1afd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68d66dcaad6bb4a5ac93a60f890b5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ac68d66dcaad6bb4a5ac93a60f890b5f2">QueueBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)</td></tr>
<tr class="memdesc:ac68d66dcaad6bb4a5ac93a60f890b5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue one buffer in to be transmitted when a connection is available.  <a href="class_pv_transmitter_g_e_v.html#ac68d66dcaad6bb4a5ac93a60f890b5f2">More...</a><br /></td></tr>
<tr class="separator:ac68d66dcaad6bb4a5ac93a60f890b5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819b018308bd20fcb6f54401d0b73e85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a819b018308bd20fcb6f54401d0b73e85">RetrieveFreeBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffer, uint32_t aTimeout=0xFFFFFFFF)</td></tr>
<tr class="memdesc:a819b018308bd20fcb6f54401d0b73e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a free buffer from the list of available buffers.  <a href="class_pv_transmitter_g_e_v.html#a819b018308bd20fcb6f54401d0b73e85">More...</a><br /></td></tr>
<tr class="separator:a819b018308bd20fcb6f54401d0b73e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd57f4bede1eb7ecbb232dd63d35eed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#abd57f4bede1eb7ecbb232dd63d35eed0">AbortQueuedBuffers</a> (uint32_t aTimeout=0xFFFFFFFF, bool *aPartialTransmission=NULL)</td></tr>
<tr class="memdesc:abd57f4bede1eb7ecbb232dd63d35eed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all pending transmission requests.  <a href="class_pv_transmitter_g_e_v.html#abd57f4bede1eb7ecbb232dd63d35eed0">More...</a><br /></td></tr>
<tr class="separator:abd57f4bede1eb7ecbb232dd63d35eed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac632a30e4791ae59488b409a81cb8404"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ac632a30e4791ae59488b409a81cb8404">GetQueuedBufferCount</a> ()</td></tr>
<tr class="memdesc:ac632a30e4791ae59488b409a81cb8404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of buffers queued for transmission including the ones that are currently being sent.  <a href="class_pv_transmitter_g_e_v.html#ac632a30e4791ae59488b409a81cb8404">More...</a><br /></td></tr>
<tr class="separator:ac632a30e4791ae59488b409a81cb8404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3c708dd3aedb9cd8404c7f7e853337"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a3e3c708dd3aedb9cd8404c7f7e853337">GetPacketSize</a> ()</td></tr>
<tr class="memdesc:a3e3c708dd3aedb9cd8404c7f7e853337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum packet size of GVSP payload packets.  <a href="class_pv_transmitter_g_e_v.html#a3e3c708dd3aedb9cd8404c7f7e853337">More...</a><br /></td></tr>
<tr class="separator:a3e3c708dd3aedb9cd8404c7f7e853337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cc530ca94ed0f4e39f3f32fa9bc0c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a13cc530ca94ed0f4e39f3f32fa9bc0c8">SetPacketSize</a> (uint32_t aPacketSize)</td></tr>
<tr class="memdesc:a13cc530ca94ed0f4e39f3f32fa9bc0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum packet size of GVSP payload packets.  <a href="class_pv_transmitter_g_e_v.html#a13cc530ca94ed0f4e39f3f32fa9bc0c8">More...</a><br /></td></tr>
<tr class="separator:a13cc530ca94ed0f4e39f3f32fa9bc0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054102efd21e59e496c1cc222324295f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a054102efd21e59e496c1cc222324295f">GetMaxPayloadThroughput</a> ()</td></tr>
<tr class="memdesc:a054102efd21e59e496c1cc222324295f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum effective throughput in bps.  <a href="class_pv_transmitter_g_e_v.html#a054102efd21e59e496c1cc222324295f">More...</a><br /></td></tr>
<tr class="separator:a054102efd21e59e496c1cc222324295f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6bdd7683f25dd7e8823729bc020b69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a5b6bdd7683f25dd7e8823729bc020b69">SetMaxPayloadThroughput</a> (float aMaxPayloadThroughput)</td></tr>
<tr class="memdesc:a5b6bdd7683f25dd7e8823729bc020b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the desired effective throughput in bps.  <a href="class_pv_transmitter_g_e_v.html#a5b6bdd7683f25dd7e8823729bc020b69">More...</a><br /></td></tr>
<tr class="separator:a5b6bdd7683f25dd7e8823729bc020b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0696be49de252856b0476d39eae6c61"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ac0696be49de252856b0476d39eae6c61">GetSourcePort</a> ()</td></tr>
<tr class="memdesc:ac0696be49de252856b0476d39eae6c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the port from which blocks are transmitted.  <a href="class_pv_transmitter_g_e_v.html#ac0696be49de252856b0476d39eae6c61">More...</a><br /></td></tr>
<tr class="separator:ac0696be49de252856b0476d39eae6c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fcf632bdc8537ccbecdbf202cd9722"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a58fcf632bdc8537ccbecdbf202cd9722">GetDestinationPort</a> ()</td></tr>
<tr class="memdesc:a58fcf632bdc8537ccbecdbf202cd9722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the port to which blocks are transmitted.  <a href="class_pv_transmitter_g_e_v.html#a58fcf632bdc8537ccbecdbf202cd9722">More...</a><br /></td></tr>
<tr class="separator:a58fcf632bdc8537ccbecdbf202cd9722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd11686f94146a6398d33290dd45c7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_string.html">PvString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a7bd11686f94146a6398d33290dd45c7e">GetDestinationIPAddress</a> ()</td></tr>
<tr class="memdesc:a7bd11686f94146a6398d33290dd45c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IP address to which blocks are transmitted.  <a href="class_pv_transmitter_g_e_v.html#a7bd11686f94146a6398d33290dd45c7e">More...</a><br /></td></tr>
<tr class="separator:a7bd11686f94146a6398d33290dd45c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f28172042dc0ae9143f8779b2b07255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_string.html">PvString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a2f28172042dc0ae9143f8779b2b07255">GetSourceIPAddress</a> ()</td></tr>
<tr class="memdesc:a2f28172042dc0ae9143f8779b2b07255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IP address from which blocks are transmitted.  <a href="class_pv_transmitter_g_e_v.html#a2f28172042dc0ae9143f8779b2b07255">More...</a><br /></td></tr>
<tr class="separator:a2f28172042dc0ae9143f8779b2b07255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318aab879c5c23bf773f99d593c345e8"><td class="memItemLeft" align="right" valign="top"><a id="a318aab879c5c23bf773f99d593c345e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a318aab879c5c23bf773f99d593c345e8">ResetStats</a> ()</td></tr>
<tr class="memdesc:a318aab879c5c23bf773f99d593c345e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero all running counters. <br /></td></tr>
<tr class="separator:a318aab879c5c23bf773f99d593c345e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa5f18cdb4d6e3fdb171a6b1a968dec"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a5aa5f18cdb4d6e3fdb171a6b1a968dec">GetBlocksTransmitted</a> () const</td></tr>
<tr class="memdesc:a5aa5f18cdb4d6e3fdb171a6b1a968dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of blocks transmitted.  <a href="class_pv_transmitter_g_e_v.html#a5aa5f18cdb4d6e3fdb171a6b1a968dec">More...</a><br /></td></tr>
<tr class="separator:a5aa5f18cdb4d6e3fdb171a6b1a968dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7db27832dfc91365440af1bf80e6cb5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#aa7db27832dfc91365440af1bf80e6cb5">GetSamplingTime</a> () const</td></tr>
<tr class="memdesc:aa7db27832dfc91365440af1bf80e6cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time since last reset.  <a href="class_pv_transmitter_g_e_v.html#aa7db27832dfc91365440af1bf80e6cb5">More...</a><br /></td></tr>
<tr class="separator:aa7db27832dfc91365440af1bf80e6cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6932fde530eabacfb7c9d07c2bec0290"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a6932fde530eabacfb7c9d07c2bec0290">GetPayloadBytesTransmitted</a> () const</td></tr>
<tr class="memdesc:a6932fde530eabacfb7c9d07c2bec0290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of payload bytes transmitted.  <a href="class_pv_transmitter_g_e_v.html#a6932fde530eabacfb7c9d07c2bec0290">More...</a><br /></td></tr>
<tr class="separator:a6932fde530eabacfb7c9d07c2bec0290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadc05e78e7036adde26216b51a6ebf2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#abadc05e78e7036adde26216b51a6ebf2">GetInstantaneousPayloadThroughput</a> () const</td></tr>
<tr class="memdesc:abadc05e78e7036adde26216b51a6ebf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an instantaneous calculation of the payload throughput (in bps).  <a href="class_pv_transmitter_g_e_v.html#abadc05e78e7036adde26216b51a6ebf2">More...</a><br /></td></tr>
<tr class="separator:abadc05e78e7036adde26216b51a6ebf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb23b1bca231093885e15e3b36e0b156"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#acb23b1bca231093885e15e3b36e0b156">GetAveragePayloadThroughput</a> () const</td></tr>
<tr class="memdesc:acb23b1bca231093885e15e3b36e0b156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the average payload throughput (in bps).  <a href="class_pv_transmitter_g_e_v.html#acb23b1bca231093885e15e3b36e0b156">More...</a><br /></td></tr>
<tr class="separator:acb23b1bca231093885e15e3b36e0b156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2ce4edd1b4a127dd6c630a7b3723cd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a3f2ce4edd1b4a127dd6c630a7b3723cd">GetInstantaneousTransmissionRate</a> () const</td></tr>
<tr class="memdesc:a3f2ce4edd1b4a127dd6c630a7b3723cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the instantaneous transmission rate (in blocks/second).  <a href="class_pv_transmitter_g_e_v.html#a3f2ce4edd1b4a127dd6c630a7b3723cd">More...</a><br /></td></tr>
<tr class="separator:a3f2ce4edd1b4a127dd6c630a7b3723cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93362bcd22095c60792290bef05eebd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ab93362bcd22095c60792290bef05eebd">GetAverageTransmissionRate</a> () const</td></tr>
<tr class="memdesc:ab93362bcd22095c60792290bef05eebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the average transmission rate (in blocks/second).  <a href="class_pv_transmitter_g_e_v.html#ab93362bcd22095c60792290bef05eebd">More...</a><br /></td></tr>
<tr class="separator:ab93362bcd22095c60792290bef05eebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb93e81bcf7e738d5fb9c2c48829d911"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#adb93e81bcf7e738d5fb9c2c48829d911">GetNumberOfResendRequests</a> () const</td></tr>
<tr class="memdesc:adb93e81bcf7e738d5fb9c2c48829d911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of resend requests.  <a href="class_pv_transmitter_g_e_v.html#adb93e81bcf7e738d5fb9c2c48829d911">More...</a><br /></td></tr>
<tr class="separator:adb93e81bcf7e738d5fb9c2c48829d911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8719a26f5bd286c052e6f53ff9075d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a1c8719a26f5bd286c052e6f53ff9075d">SetSentBuffersTimeout</a> (uint32_t aTimeout)</td></tr>
<tr class="memdesc:a1c8719a26f5bd286c052e6f53ff9075d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set how long the transmitter keeps a buffer available for resend requests.  <a href="class_pv_transmitter_g_e_v.html#a1c8719a26f5bd286c052e6f53ff9075d">More...</a><br /></td></tr>
<tr class="separator:a1c8719a26f5bd286c052e6f53ff9075d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540e17dbae926e603bc0ccec36af4e33"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a540e17dbae926e603bc0ccec36af4e33">GetSentBuffersTimeout</a> () const</td></tr>
<tr class="memdesc:a540e17dbae926e603bc0ccec36af4e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the timeout used to keep the buffers in the transmitter after they are sent.  <a href="class_pv_transmitter_g_e_v.html#a540e17dbae926e603bc0ccec36af4e33">More...</a><br /></td></tr>
<tr class="separator:a540e17dbae926e603bc0ccec36af4e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae904f1c6a740458197169971f2fe17f7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ae904f1c6a740458197169971f2fe17f7">IsOpen</a> () const</td></tr>
<tr class="memdesc:ae904f1c6a740458197169971f2fe17f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a connection is available to begin transmitting blocks.  <a href="class_pv_transmitter_g_e_v.html#ae904f1c6a740458197169971f2fe17f7">More...</a><br /></td></tr>
<tr class="separator:ae904f1c6a740458197169971f2fe17f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e507ff9b41df30ca97227b3b6b1174b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a8e507ff9b41df30ca97227b3b6b1174b">IsTransmitting</a> () const</td></tr>
<tr class="memdesc:a8e507ff9b41df30ca97227b3b6b1174b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the transmitter has started transmitting blocks.  <a href="class_pv_transmitter_g_e_v.html#a8e507ff9b41df30ca97227b3b6b1174b">More...</a><br /></td></tr>
<tr class="separator:a8e507ff9b41df30ca97227b3b6b1174b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9cfcd2e3c1cc05e6e517487c6f31e5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a5b9cfcd2e3c1cc05e6e517487c6f31e5">GetExtendedIDs</a> () const</td></tr>
<tr class="memdesc:a5b9cfcd2e3c1cc05e6e517487c6f31e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether extended IDs are used.  <a href="class_pv_transmitter_g_e_v.html#a5b9cfcd2e3c1cc05e6e517487c6f31e5">More...</a><br /></td></tr>
<tr class="separator:a5b9cfcd2e3c1cc05e6e517487c6f31e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3c4c926194cf31e1524406e8487a62"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a2a3c4c926194cf31e1524406e8487a62">SetExtendedIDs</a> (bool aExtendedID)</td></tr>
<tr class="memdesc:a2a3c4c926194cf31e1524406e8487a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the transmitter to use extended (64-bit) block IDs, as specified in GigE Vision 2.0. For receivers that are compliant with earlier versions of GigE Vision, set this to false to use standard (32-bit) block IDs. This parameter should only be used with GigE Vision 2.0 compliant receivers.  <a href="class_pv_transmitter_g_e_v.html#a2a3c4c926194cf31e1524406e8487a62">More...</a><br /></td></tr>
<tr class="separator:a2a3c4c926194cf31e1524406e8487a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463db6134f9bfa74d33cff62f7a45dd4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a463db6134f9bfa74d33cff62f7a45dd4">QueuePacketResend</a> (uint64_t aBlockID, uint32_t aFirstPacketID, uint32_t aLastPacketID)</td></tr>
<tr class="memdesc:a463db6134f9bfa74d33cff62f7a45dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is for internal eBUS SDK use. It allows a virtual GigE Vision device to execute resend requests. Your application should not call this function.  <a href="class_pv_transmitter_g_e_v.html#a463db6134f9bfa74d33cff62f7a45dd4">More...</a><br /></td></tr>
<tr class="separator:a463db6134f9bfa74d33cff62f7a45dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5e5dac48a72ad978109a1ecfa08833"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#aec5e5dac48a72ad978109a1ecfa08833">GetUserModeTransmitterThreadPriority</a> () const</td></tr>
<tr class="memdesc:aec5e5dac48a72ad978109a1ecfa08833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority of the thread in charge of sending the packets on the network.  <a href="class_pv_transmitter_g_e_v.html#aec5e5dac48a72ad978109a1ecfa08833">More...</a><br /></td></tr>
<tr class="separator:aec5e5dac48a72ad978109a1ecfa08833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ae686fb754a415e3a6d8ea92afeb4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ad8ae686fb754a415e3a6d8ea92afeb4d">SetUserModeTransmitterThreadPriority</a> (uint32_t aPriority)</td></tr>
<tr class="memdesc:ad8ae686fb754a415e3a6d8ea92afeb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of the thread in charge of sending the packets on the network.  <a href="class_pv_transmitter_g_e_v.html#ad8ae686fb754a415e3a6d8ea92afeb4d">More...</a><br /></td></tr>
<tr class="separator:ad8ae686fb754a415e3a6d8ea92afeb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efa09320648e881266a042495f0fb09"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a9efa09320648e881266a042495f0fb09">GetBufferPoolThreadPriority</a> () const</td></tr>
<tr class="memdesc:a9efa09320648e881266a042495f0fb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority of the thread used to manage the buffer of the buffer pool.  <a href="class_pv_transmitter_g_e_v.html#a9efa09320648e881266a042495f0fb09">More...</a><br /></td></tr>
<tr class="separator:a9efa09320648e881266a042495f0fb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7e0170148bec8c62c2f685997e2cc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a1d7e0170148bec8c62c2f685997e2cc2">SetBufferPoolThreadPriority</a> (uint32_t aPriority)</td></tr>
<tr class="memdesc:a1d7e0170148bec8c62c2f685997e2cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of the thread used to manage the buffer of the buffer pool.  <a href="class_pv_transmitter_g_e_v.html#a1d7e0170148bec8c62c2f685997e2cc2">More...</a><br /></td></tr>
<tr class="separator:a1d7e0170148bec8c62c2f685997e2cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for transmitting blocks using the GigE Vision streaming protocol. </p>
<p><b>Procedure for transmitting blocks (images or raw data) with the eBUS SDK:</b></p>
<ul>
<li>Ensure that the transmitter knows where to send blocks by calling <a class="el" href="class_pv_transmitter_g_e_v.html#a0fa35cbac01bd79d250664c5a09bfda3" title="Initialize a socket to begin transmitting data.">Open</a>.</li>
<li>Initialize the transmitter with a set of free buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> objects) by calling <a class="el" href="class_pv_transmitter_g_e_v.html#a2c3e2d6577a798686398a37dbe1afd7d" title="Load a set of free buffers into the pool.">LoadBufferPool</a>.</li>
<li>Retrieve a free buffer to populate by calling <a class="el" href="class_pv_transmitter_g_e_v.html#a819b018308bd20fcb6f54401d0b73e85" title="Retrieve a free buffer from the list of available buffers.">RetrieveFreeBuffer</a>.</li>
<li>Queue a buffer for transmission by calling <a class="el" href="class_pv_transmitter_g_e_v.html#ac68d66dcaad6bb4a5ac93a60f890b5f2" title="Queue one buffer in to be transmitted when a connection is available.">QueueBuffer</a>.</li>
<li>Once a buffer has been transmitted, it can be retrieved again by calling <a class="el" href="class_pv_transmitter_g_e_v.html#a819b018308bd20fcb6f54401d0b73e85" title="Retrieve a free buffer from the list of available buffers.">RetrieveFreeBuffer</a>.</li>
</ul>
<p>The status of a given <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> object can be retrieved by calling <a class="el" href="class_pv_buffer.html#ac09304df721a8589f49d83cb9d50223c" title="Returns the value of aOperationResult when this buffer was last received through a PvStream.">PvBuffer::GetOperationResult</a>.</p><ul>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> indicates that the buffer was transmitted successfully.</li>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca5709b0ee04f203c1b36965dab780d2e6">PvResult::Code::NETWORK_ERROR</a> indicates that there was a problem transmitting the buffer (likely due to a lack of connectivity).</li>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca02e7e13232d736f9215df059aa92280f">PvResult::Code::ABORTED</a> indicates that the transmission of that buffer was aborted (typically by calling <a class="el" href="class_pv_transmitter_g_e_v.html#abd57f4bede1eb7ecbb232dd63d35eed0" title="Frees all pending transmission requests.">AbortQueuedBuffers</a>).</li>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca243bf1f15a65a48672b6a2916359951a">PvResult::Code::PENDING</a> indicates that the buffer has not yet been fully transmitted.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_pv_transmitter_g_e_v.html" title="Class for transmitting blocks using the GigE Vision streaming protocol.">PvTransmitterGEV</a> is only responsible for transmitting blocks. It does not implement a control channel like a complete GigE Vision device. To receive transmitted blocks with a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter.">PvStream</a> application (such as eBUS Player), the transmitting application must be set up to respond to device discovery requests. Use <a class="el" href="class_pv_virtual_device_g_e_v.html" title="Virtual GigE Vision device.">PvVirtualDeviceGEV</a> to respond to device discovery requests. If using eBUS Player to receive data being transmitted with this class, ensure that the application is set up as <b>Data Receiver Only</b>.</dd></dl>
<p>For an illustration of how this API is used in practice, refer to the following source code samples in the samples directory where the eBUS SDK resides:</p><ul>
<li>TransmitTestPattern - Transmits a test pattern to a given destination. This is the easiest starting point for learning to use <a class="el" href="class_pv_transmitter_g_e_v.html" title="Class for transmitting blocks using the GigE Vision streaming protocol.">PvTransmitterGEV</a>.</li>
<li>TransmitProcessImage - Receives video from a GigE Vision device using <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter.">PvStream</a> and <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter.">PvPipeline</a>, re-samples it and print text on it using OpenCV and finally transmits it using <a class="el" href="class_pv_transmitter_g_e_v.html" title="Class for transmitting blocks using the GigE Vision streaming protocol.">PvTransmitterGEV</a>.</li>
<li>TransmitTiledImagesSample - An MFC GUI application that receives video from multiple GEV transmitters, tiles into one video feed and transmits to a given destination. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abd57f4bede1eb7ecbb232dd63d35eed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd57f4bede1eb7ecbb232dd63d35eed0">&#9670;&nbsp;</a></span>AbortQueuedBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::AbortQueuedBuffers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aTimeout</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>aPartialTransmission</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all pending transmission requests. </p>
<p>Buffers that were aborted will have an operation result set at <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca02e7e13232d736f9215df059aa92280f">PvResult::Code::ABORTED</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aTimeout</td><td>Represents the maximum number of milliseconds to wait for the current transmit operation before returning <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca8044711331afcc8f9607defdeb4f897f">PvResult::Code::TIMEOUT</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPartialTransmission</td><td>Output, set to true if transmission was stopped in the middle of a block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful </dd></dl>

</div>
</div>
<a id="a44cccdb8b355d061ad99b64f888cb14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cccdb8b355d061ad99b64f888cb14a">&#9670;&nbsp;</a></span>Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop sending data and close the socket. </p>
<p>Any buffers that are in the middle of being transmitted are aborted.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful </dd></dl>

</div>
</div>
<a id="acb23b1bca231093885e15e3b36e0b156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb23b1bca231093885e15e3b36e0b156">&#9670;&nbsp;</a></span>GetAveragePayloadThroughput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterGEV::GetAveragePayloadThroughput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the average payload throughput (in bps). </p>
<p>Average payload transmission rate is equivalent to <a class="el" href="class_pv_transmitter_g_e_v.html#a6932fde530eabacfb7c9d07c2bec0290" title="Get the number of payload bytes transmitted.">GetPayloadBytesTransmitted()</a> * 8 / <a class="el" href="class_pv_transmitter_g_e_v.html#aa7db27832dfc91365440af1bf80e6cb5" title="Get the time since last reset.">GetSamplingTime()</a>. Note that this calculation only includes the number of useful data bytes and does not include GVSP, IP and UDP header overhead.</p>
<dl class="section return"><dt>Returns</dt><dd>The average network throughput (in bps) </dd></dl>

</div>
</div>
<a id="ab93362bcd22095c60792290bef05eebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93362bcd22095c60792290bef05eebd">&#9670;&nbsp;</a></span>GetAverageTransmissionRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterGEV::GetAverageTransmissionRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the average transmission rate (in blocks/second). </p>
<p>Average transmission rate is equivalent to <a class="el" href="class_pv_transmitter_g_e_v.html#a5aa5f18cdb4d6e3fdb171a6b1a968dec" title="Get the number of blocks transmitted.">GetBlocksTransmitted()</a> / <a class="el" href="class_pv_transmitter_g_e_v.html#aa7db27832dfc91365440af1bf80e6cb5" title="Get the time since last reset.">GetSamplingTime()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The average transmission rate (in blocks/second) </dd></dl>

</div>
</div>
<a id="a5aa5f18cdb4d6e3fdb171a6b1a968dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa5f18cdb4d6e3fdb171a6b1a968dec">&#9670;&nbsp;</a></span>GetBlocksTransmitted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvTransmitterGEV::GetBlocksTransmitted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of blocks transmitted. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of blocks this object has transmitted. </dd></dl>

</div>
</div>
<a id="a9efa09320648e881266a042495f0fb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efa09320648e881266a042495f0fb09">&#9670;&nbsp;</a></span>GetBufferPoolThreadPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvTransmitterGEV::GetBufferPoolThreadPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the priority of the thread used to manage the buffer of the buffer pool. </p>
<p>See <a class="el" href="class_pv_transmitter_g_e_v.html#a1d7e0170148bec8c62c2f685997e2cc2" title="Set the priority of the thread used to manage the buffer of the buffer pool.">SetBufferPoolThreadPriority</a> for details about the meaning of the values returned</p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the thread </dd></dl>

</div>
</div>
<a id="a7bd11686f94146a6398d33290dd45c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd11686f94146a6398d33290dd45c7e">&#9670;&nbsp;</a></span>GetDestinationIPAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_string.html">PvString</a> PvTransmitterGEV::GetDestinationIPAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the IP address to which blocks are transmitted. </p>
<dl class="section return"><dt>Returns</dt><dd>The ip address to which blocks are transmitted. Returns an empty string when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a id="a58fcf632bdc8537ccbecdbf202cd9722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fcf632bdc8537ccbecdbf202cd9722">&#9670;&nbsp;</a></span>GetDestinationPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t PvTransmitterGEV::GetDestinationPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the port to which blocks are transmitted. </p>
<dl class="section return"><dt>Returns</dt><dd>The port number to which blocks are transmitted. Returns 0 when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a id="a5b9cfcd2e3c1cc05e6e517487c6f31e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9cfcd2e3c1cc05e6e517487c6f31e5">&#9670;&nbsp;</a></span>GetExtendedIDs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvTransmitterGEV::GetExtendedIDs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether extended IDs are used. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="class_pv_transmitter_g_e_v.html#a2a3c4c926194cf31e1524406e8487a62" title="Configures the transmitter to use extended (64-bit) block IDs, as specified in GigE Vision 2....">SetExtendedIDs</a> for information about the return values. </dd></dl>

</div>
</div>
<a id="abadc05e78e7036adde26216b51a6ebf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadc05e78e7036adde26216b51a6ebf2">&#9670;&nbsp;</a></span>GetInstantaneousPayloadThroughput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterGEV::GetInstantaneousPayloadThroughput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an instantaneous calculation of the payload throughput (in bps). </p>
<p>Instantaneous payload transmission rate is measured using a short time frame. Note that this calculation only includes the number of useful data bytes and does not include GVSP, IP and UDP header overhead.</p>
<dl class="section return"><dt>Returns</dt><dd>The payload transmission rate (in bps) </dd></dl>

</div>
</div>
<a id="a3f2ce4edd1b4a127dd6c630a7b3723cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2ce4edd1b4a127dd6c630a7b3723cd">&#9670;&nbsp;</a></span>GetInstantaneousTransmissionRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterGEV::GetInstantaneousTransmissionRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the instantaneous transmission rate (in blocks/second). </p>
<p>Instantaneous transmission rate is measured using a short time frame.</p>
<dl class="section return"><dt>Returns</dt><dd>The instantaneous transmission rate (in blocks/second) </dd></dl>

</div>
</div>
<a id="a054102efd21e59e496c1cc222324295f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054102efd21e59e496c1cc222324295f">&#9670;&nbsp;</a></span>GetMaxPayloadThroughput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterGEV::GetMaxPayloadThroughput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum effective throughput in bps. </p>
<p>An occasional delay is placed between the packets being transmitted to attempt to throttle the effective throughput. This helps to spread out network traffic to optimize bandwidth availability for other applications. A value of 0 (default) indicates that there should be no throttling based on throughput.</p>
<dl class="section return"><dt>Returns</dt><dd>the desired throughput in bps. </dd></dl>

</div>
</div>
<a id="adb93e81bcf7e738d5fb9c2c48829d911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb93e81bcf7e738d5fb9c2c48829d911">&#9670;&nbsp;</a></span>GetNumberOfResendRequests()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvTransmitterGEV::GetNumberOfResendRequests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of resend requests. </p>
<p>This is the number of times the GVSP transmitter has serviced a resend request.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of resend requests. </dd></dl>

</div>
</div>
<a id="a3e3c708dd3aedb9cd8404c7f7e853337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3c708dd3aedb9cd8404c7f7e853337">&#9670;&nbsp;</a></span>GetPacketSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvTransmitterGEV::GetPacketSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum packet size of GVSP payload packets. </p>
<p>When a block is packetized and transmitted, the payload is broken down into packets of a given size. The default value for the maximum packet size is 1440 because that is the size that should work in theory for all network adapters.</p>
<p>For best results, enable jumbo packets in your network adapter properties and increase the maximum packet size to match When sending very small blocks at high frame rates it may sometimes be desirable to set the maximum packet size to a lower number.</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum packet size (in bytes). </dd></dl>

</div>
</div>
<a id="a6932fde530eabacfb7c9d07c2bec0290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6932fde530eabacfb7c9d07c2bec0290">&#9670;&nbsp;</a></span>GetPayloadBytesTransmitted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvTransmitterGEV::GetPayloadBytesTransmitted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of payload bytes transmitted. </p>
<p>Note that this value only includes the number of useful data bytes and does not include GVSP, IP and UDP header overhead.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of payload bytes transmitted. </dd></dl>

</div>
</div>
<a id="ac632a30e4791ae59488b409a81cb8404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac632a30e4791ae59488b409a81cb8404">&#9670;&nbsp;</a></span>GetQueuedBufferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvTransmitterGEV::GetQueuedBufferCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of buffers queued for transmission including the ones that are currently being sent. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of buffers queued for transmission including the ones that are currently being sent. </dd></dl>

</div>
</div>
<a id="aa7db27832dfc91365440af1bf80e6cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7db27832dfc91365440af1bf80e6cb5">&#9670;&nbsp;</a></span>GetSamplingTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvTransmitterGEV::GetSamplingTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time since last reset. </p>
<dl class="section return"><dt>Returns</dt><dd>The time, in ms, since the counters were zeroed; the time since the object was created, the transmitter was opened (using <a class="el" href="class_pv_transmitter_g_e_v.html#a0fa35cbac01bd79d250664c5a09bfda3" title="Initialize a socket to begin transmitting data.">Open</a>), or <a class="el" href="class_pv_transmitter_g_e_v.html#a318aab879c5c23bf773f99d593c345e8" title="Zero all running counters.">ResetStats</a> was called. </dd></dl>

</div>
</div>
<a id="a540e17dbae926e603bc0ccec36af4e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540e17dbae926e603bc0ccec36af4e33">&#9670;&nbsp;</a></span>GetSentBuffersTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvTransmitterGEV::GetSentBuffersTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the timeout used to keep the buffers in the transmitter after they are sent. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="class_pv_transmitter_g_e_v.html#a1c8719a26f5bd286c052e6f53ff9075d" title="Set how long the transmitter keeps a buffer available for resend requests.">SetSentBuffersTimeout</a> for details about the meaning of the values returned </dd></dl>

</div>
</div>
<a id="a2f28172042dc0ae9143f8779b2b07255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f28172042dc0ae9143f8779b2b07255">&#9670;&nbsp;</a></span>GetSourceIPAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_string.html">PvString</a> PvTransmitterGEV::GetSourceIPAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the IP address from which blocks are transmitted. </p>
<dl class="section return"><dt>Returns</dt><dd>The IP address from which blocks are transmitted. Returns an empty string when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a id="ac0696be49de252856b0476d39eae6c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0696be49de252856b0476d39eae6c61">&#9670;&nbsp;</a></span>GetSourcePort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t PvTransmitterGEV::GetSourcePort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the port from which blocks are transmitted. </p>
<dl class="section return"><dt>Returns</dt><dd>The port number from which blocks are transmitted. Returns 0 when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a id="aec5e5dac48a72ad978109a1ecfa08833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5e5dac48a72ad978109a1ecfa08833">&#9670;&nbsp;</a></span>GetUserModeTransmitterThreadPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvTransmitterGEV::GetUserModeTransmitterThreadPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the priority of the thread in charge of sending the packets on the network. </p>
<p>See <a class="el" href="class_pv_transmitter_g_e_v.html#ad8ae686fb754a415e3a6d8ea92afeb4d" title="Set the priority of the thread in charge of sending the packets on the network.">SetUserModeTransmitterThreadPriority</a> for details about the meaning of the values returned</p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the thread </dd></dl>

</div>
</div>
<a id="ae904f1c6a740458197169971f2fe17f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae904f1c6a740458197169971f2fe17f7">&#9670;&nbsp;</a></span>IsOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvTransmitterGEV::IsOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a connection is available to begin transmitting blocks. </p>
<dl class="section return"><dt>Returns</dt><dd>True if a connection is available. False if no connection is available. </dd></dl>

</div>
</div>
<a id="a8e507ff9b41df30ca97227b3b6b1174b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e507ff9b41df30ca97227b3b6b1174b">&#9670;&nbsp;</a></span>IsTransmitting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvTransmitterGEV::IsTransmitting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the transmitter has started transmitting blocks. </p>
<dl class="section return"><dt>Returns</dt><dd>True if transmitting has started. </dd></dl>

</div>
</div>
<a id="a2c3e2d6577a798686398a37dbe1afd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3e2d6577a798686398a37dbe1afd7d">&#9670;&nbsp;</a></span>LoadBufferPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::LoadBufferPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> **&#160;</td>
          <td class="paramname"><em>aBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aBufferCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a set of free buffers into the pool. </p>
<p>This method provides the transmitter with a set of free buffers that can be retrieved immediately by calling <a class="el" href="class_pv_transmitter_g_e_v.html#a819b018308bd20fcb6f54401d0b73e85" title="Retrieve a free buffer from the list of available buffers.">RetrieveFreeBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffers</td><td>An array of pointers to <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aBufferCount</td><td>The number of buffer pointers provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful </dd></dl>

</div>
</div>
<a id="a0fa35cbac01bd79d250664c5a09bfda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa35cbac01bd79d250664c5a09bfda3">&#9670;&nbsp;</a></span>Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_string.html">PvString</a>&#160;</td>
          <td class="paramname"><em>aDestinationIp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aDestinationPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pv_string.html">PvString</a>&#160;</td>
          <td class="paramname"><em>aSourceIp</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aSourcePort</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aDontFrag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aExtendedIDs</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aBuffersCapacity</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aTimestampWhenSending</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aNumberOfPendingResendRequests</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aNumberOfBuffersHoldForResends</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a socket to begin transmitting data. </p>
<p>Once this call is completed successfully, the transmitter will begin sending blocks as soon as the first buffer is queued in by calling <a class="el" href="class_pv_transmitter_g_e_v.html#ac68d66dcaad6bb4a5ac93a60f890b5f2" title="Queue one buffer in to be transmitted when a connection is available.">QueueBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aDestinationIp</td><td>The address to which the transmitter will send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aDestinationPort</td><td>The port to which the transmitter will send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSourceIp</td><td>The address from which the transmitter will send. If the parameter is an empty string (default), the socket will not be bound to a specific local IP address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSourcePort</td><td>The port from which the transmitter will send. If the parameter is 0 (default), the source port will be dynamically assigned by the operating system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aDontFrag</td><td>The value of the Don't Fragment flag in the IP header. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aExtendedIDs</td><td>Uses the extended ID for blocks and packets when set to true. This parameter should only be used with GigE Vision 2.0 compliant receivers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffersCapacity</td><td>Maximum number of buffer that can be stored simultaneously in the lower layer of the transmitter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aTimestampWhenSending</td><td>Set the timestamp in the buffer header before sending the packets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aNumberOfPendingResendRequests</td><td>Number of pending resend requests allowed at the same time. All other resend requests will be ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aNumberOfBuffersHoldForResends</td><td>Number of PvBuffers held in the transmitter to service resend requests after the block is transferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca5709b0ee04f203c1b36965dab780d2e6">PvResult::Code::NETWORK_ERROR</a> if the socket could not be created </dd></dl>

</div>
</div>
<a id="ac68d66dcaad6bb4a5ac93a60f890b5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68d66dcaad6bb4a5ac93a60f890b5f2">&#9670;&nbsp;</a></span>QueueBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::QueueBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td>
          <td class="paramname"><em>aBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue one buffer in to be transmitted when a connection is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffer</td><td>The buffer to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca37cf2b6eb84b2f3286393bc9108cfab4">PvResult::Code::BUFFER_TOO_SMALL</a> if the buffer is empty. </dd></dl>

</div>
</div>
<a id="a463db6134f9bfa74d33cff62f7a45dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463db6134f9bfa74d33cff62f7a45dd4">&#9670;&nbsp;</a></span>QueuePacketResend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvTransmitterGEV::QueuePacketResend </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>aBlockID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aFirstPacketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aLastPacketID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This command is for internal eBUS SDK use. It allows a virtual GigE Vision device to execute resend requests. Your application should not call this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBlockID</td><td>Block ID of the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFirstPacketID</td><td>First packet ID of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aLastPacketID</td><td>Last packet ID of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a819b018308bd20fcb6f54401d0b73e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819b018308bd20fcb6f54401d0b73e85">&#9670;&nbsp;</a></span>RetrieveFreeBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::RetrieveFreeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> **&#160;</td>
          <td class="paramname"><em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aTimeout</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a free buffer from the list of available buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aBuffer</td><td>The buffer that is available to populate and transmit. The pointer is set to NULL if no buffer is available. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aTimeout</td><td>The maximum number of milliseconds to wait for a free buffer to become available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful.or <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca8044711331afcc8f9607defdeb4f897f">PvResult::Code::TIMEOUT</a> if the aTimeout parameter was exceeded while waiting for a buffer to become available. </dd></dl>

</div>
</div>
<a id="a1d7e0170148bec8c62c2f685997e2cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7e0170148bec8c62c2f685997e2cc2">&#9670;&nbsp;</a></span>SetBufferPoolThreadPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::SetBufferPoolThreadPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the priority of the thread used to manage the buffer of the buffer pool. </p>
<p>Only applicable if using a buffer pool ( See <a class="el" href="class_pv_transmitter_g_e_v.html#a2c3e2d6577a798686398a37dbe1afd7d" title="Load a set of free buffers into the pool.">LoadBufferPool</a> ). The thread will manage the buffer exchange with the transmitter.</p>
<p>If you change the thread priorities, it may alterate the stability of the system. For this reason, if you report a bug to Pleora, ensure to clearly mention that you change threads priorities.</p>
<p>See <a class="el" href="class_pv_transmitter_g_e_v.html#a9efa09320648e881266a042495f0fb09" title="Get the priority of the thread used to manage the buffer of the buffer pool.">GetBufferPoolThreadPriority</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPriority</td><td>See <a class="el" href="class_pv_pipeline.html#abee6125a1608074ad5a7b141ed58f52c" title="Set the priority of the pipeline thread.">PvPipeline::SetBufferHandlingThreadPriority</a> for description of the supported values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca75e1d2230eff41caaf8074951249d63c">PvResult::Code::THREAD_ERROR</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2a3c4c926194cf31e1524406e8487a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3c4c926194cf31e1524406e8487a62">&#9670;&nbsp;</a></span>SetExtendedIDs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::SetExtendedIDs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aExtendedID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the transmitter to use extended (64-bit) block IDs, as specified in GigE Vision 2.0. For receivers that are compliant with earlier versions of GigE Vision, set this to false to use standard (32-bit) block IDs. This parameter should only be used with GigE Vision 2.0 compliant receivers. </p>
<dl class="section note"><dt>Note</dt><dd>Can only be changed before the first buffer is queued in the transmitter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aExtendedID</td><td>True to use extended IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cacd9aca205059c59969e31adaaec0e505">PvResult::Code::BUSY</a> buffer(s) were already queued. </dd></dl>

</div>
</div>
<a id="a5b6bdd7683f25dd7e8823729bc020b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6bdd7683f25dd7e8823729bc020b69">&#9670;&nbsp;</a></span>SetMaxPayloadThroughput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::SetMaxPayloadThroughput </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aMaxPayloadThroughput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the desired effective throughput in bps. </p>
<p>An occasional delay is placed between the packets being transmitted to attempt to throttle the effective throughput. This helps to spread out network traffic to optimize bandwidth availability for other applications. A value of 0 (default) indicates that there should be no throttling based on throughput.</p>
<p>The throughput is measured in effective throughput on the content of the transmitted <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> objects. It does not take into account the GigE Vision, UDP, IP and Ethernet protocol overhead of the packetized data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aMaxPayloadThroughput</td><td>The maximum throughput in bps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<a id="a13cc530ca94ed0f4e39f3f32fa9bc0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cc530ca94ed0f4e39f3f32fa9bc0c8">&#9670;&nbsp;</a></span>SetPacketSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::SetPacketSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aPacketSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum packet size of GVSP payload packets. </p>
<p>When a block is packetized and transmitted, the payload is broken down into packets of a given size. The default value for the maximum packet size is 1440 because that is the size that should work in theory for all network adapters.</p>
<p>For best results, enable jumbo packets in your network adapter properties and increase the maximum packet size to match When sending very small blocks at high frame rates it may sometimes be desirable to set the maximum packet size to a lower number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPacketSize</td><td>The maximum packet size (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful, <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> if aPacketSize is less than or equal to 36 </dd></dl>

</div>
</div>
<a id="a1c8719a26f5bd286c052e6f53ff9075d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8719a26f5bd286c052e6f53ff9075d">&#9670;&nbsp;</a></span>SetSentBuffersTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::SetSentBuffersTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aTimeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set how long the transmitter keeps a buffer available for resend requests. </p>
<p>This timeout allows the system to hold the buffer to service the resend requests. The timeout is only checked when each image (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>) is sent, so the accuracy is not exact.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aTimeout</td><td>The timeout value, in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<a id="ad8ae686fb754a415e3a6d8ea92afeb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ae686fb754a415e3a6d8ea92afeb4d">&#9670;&nbsp;</a></span>SetUserModeTransmitterThreadPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::SetUserModeTransmitterThreadPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the priority of the thread in charge of sending the packets on the network. </p>
<p>Only applicable if using a user-mode transmitter. The thread priority of a driver-based transmitter cannot be controlled. Thread that is responsible for breaking buffers in packets and transmitting them.</p>
<p>If you change the thread priorities, it may alterate the stability of the system. For this reason, if you report a bug to Pleora, ensure to clearly mention that you change threads priorities.</p>
<p>See <a class="el" href="class_pv_transmitter_g_e_v.html#aec5e5dac48a72ad978109a1ecfa08833" title="Get the priority of the thread in charge of sending the packets on the network.">GetUserModeTransmitterThreadPriority</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPriority</td><td>See <a class="el" href="class_pv_pipeline.html#abee6125a1608074ad5a7b141ed58f52c" title="Set the priority of the pipeline thread.">PvPipeline::SetBufferHandlingThreadPriority</a> for description of the supported values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca75e1d2230eff41caaf8074951249d63c">PvResult::Code::THREAD_ERROR</a> </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_transmitter_g_e_v_8h_source.html">PvTransmitterGEV.h</a></li>
<li>PvTransmitterGEV.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2024 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
