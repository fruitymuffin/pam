<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvStreamingChannelSourceTrigger Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v6.4.0.6670 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_pv_streaming_channel_source_trigger.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_pv_streaming_channel_source_trigger-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvStreamingChannelSourceTrigger Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An implementation providing Trigger support for the <a class="el" href="class_i_pv_streaming_channel_source.html" title="Interface that is used by PvSoftDeviceGEV to query and report information from a streaming source imp...">IPvStreamingChannelSource</a> interface.  
 <a href="class_pv_streaming_channel_source_trigger.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae3e7fccb2c946104119b6968962fd2b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#ae3e7fccb2c946104119b6968962fd2b7">PvStreamingChannelSourceTrigger</a> (uint32_t mChannel, uint32_t aRegisterBaseAddress)</td></tr>
<tr class="memdesc:ae3e7fccb2c946104119b6968962fd2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_pv_streaming_channel_source_trigger.html#ae3e7fccb2c946104119b6968962fd2b7">More...</a><br /></td></tr>
<tr class="separator:ae3e7fccb2c946104119b6968962fd2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98af5a5383673c6db8377756e0758b3a"><td class="memItemLeft" align="right" valign="top"><a id="a98af5a5383673c6db8377756e0758b3a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#a98af5a5383673c6db8377756e0758b3a">~PvStreamingChannelSourceTrigger</a> ()</td></tr>
<tr class="memdesc:a98af5a5383673c6db8377756e0758b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a98af5a5383673c6db8377756e0758b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca1fce50fcd92d5cfa9fe315df8910d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#acca1fce50fcd92d5cfa9fe315df8910d">OnStreamingStart</a> ()</td></tr>
<tr class="memdesc:acca1fce50fcd92d5cfa9fe315df8910d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that the GigE Vision controller has requested that the device start streaming on this channel.  <a href="class_pv_streaming_channel_source_trigger.html#acca1fce50fcd92d5cfa9fe315df8910d">More...</a><br /></td></tr>
<tr class="separator:acca1fce50fcd92d5cfa9fe315df8910d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3110dca47fe2becb92e37142249068e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#ac3110dca47fe2becb92e37142249068e">OnStreamingStop</a> ()</td></tr>
<tr class="memdesc:ac3110dca47fe2becb92e37142249068e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that the GigE Vision controller has requested that the device stop streaming on this channel.  <a href="class_pv_streaming_channel_source_trigger.html#ac3110dca47fe2becb92e37142249068e">More...</a><br /></td></tr>
<tr class="separator:ac3110dca47fe2becb92e37142249068e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca0ce45493ec5c0ad37fd09c3e8636f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#acca0ce45493ec5c0ad37fd09c3e8636f">PreQueueBufferProc</a> ()</td></tr>
<tr class="separator:acca0ce45493ec5c0ad37fd09c3e8636f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b13db31fa1c6321b72ec1cf62ffce09"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#a7b13db31fa1c6321b72ec1cf62ffce09">PostRetrieveBufferProc</a> ()</td></tr>
<tr class="separator:a7b13db31fa1c6321b72ec1cf62ffce09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af408c53d2bd2c04141fe994fe6a06e4c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#af408c53d2bd2c04141fe994fe6a06e4c">CreateRegisters</a> (<a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *aRegisterMap, <a class="el" href="class_i_pv_register_factory.html">IPvRegisterFactory</a> *aFactory)</td></tr>
<tr class="memdesc:af408c53d2bd2c04141fe994fe6a06e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates all required Trigger-related registers .  <a href="class_pv_streaming_channel_source_trigger.html#af408c53d2bd2c04141fe994fe6a06e4c">More...</a><br /></td></tr>
<tr class="separator:af408c53d2bd2c04141fe994fe6a06e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877af6a22b84ddf36ebc3bb050f4936e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#a877af6a22b84ddf36ebc3bb050f4936e">CreateGenApiFeatures</a> (<a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *aRegisterMap, <a class="el" href="class_i_pv_gen_api_factory.html">IPvGenApiFactory</a> *aFactory)</td></tr>
<tr class="memdesc:a877af6a22b84ddf36ebc3bb050f4936e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates all Trigger-related GenApi parameters if they are needed.  <a href="class_pv_streaming_channel_source_trigger.html#a877af6a22b84ddf36ebc3bb050f4936e">More...</a><br /></td></tr>
<tr class="separator:a877af6a22b84ddf36ebc3bb050f4936e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c44a61d7ffa44666ac1a6031259c0f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#a07c44a61d7ffa44666ac1a6031259c0f">PreRead</a> (<a class="el" href="class_i_pv_register.html">IPvRegister</a> *aRegister)</td></tr>
<tr class="memdesc:a07c44a61d7ffa44666ac1a6031259c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-read register notification.  <a href="class_pv_streaming_channel_source_trigger.html#a07c44a61d7ffa44666ac1a6031259c0f">More...</a><br /></td></tr>
<tr class="separator:a07c44a61d7ffa44666ac1a6031259c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80aa7d394f4d9e737114905598340d5d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#a80aa7d394f4d9e737114905598340d5d">PreWrite</a> (<a class="el" href="class_i_pv_register.html">IPvRegister</a> *aRegister)</td></tr>
<tr class="memdesc:a80aa7d394f4d9e737114905598340d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-write register notification.  <a href="class_pv_streaming_channel_source_trigger.html#a80aa7d394f4d9e737114905598340d5d">More...</a><br /></td></tr>
<tr class="separator:a80aa7d394f4d9e737114905598340d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe52aacbc532160daac21a12728e69e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#afe52aacbc532160daac21a12728e69e8">Persist</a> (<a class="el" href="class_i_pv_register.html">IPvRegister</a> *aRegister, <a class="el" href="class_i_pv_register_store.html">IPvRegisterStore</a> *aStore)</td></tr>
<tr class="memdesc:afe52aacbc532160daac21a12728e69e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peristence request for selected registers for user-sets.  <a href="class_pv_streaming_channel_source_trigger.html#afe52aacbc532160daac21a12728e69e8">More...</a><br /></td></tr>
<tr class="separator:afe52aacbc532160daac21a12728e69e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4480f070c24805ecb37a660bd8dd812"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#ad4480f070c24805ecb37a660bd8dd812">FireTrigger</a> () const</td></tr>
<tr class="memdesc:ad4480f070c24805ecb37a660bd8dd812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software trigger.  <a href="class_pv_streaming_channel_source_trigger.html#ad4480f070c24805ecb37a660bd8dd812">More...</a><br /></td></tr>
<tr class="separator:ad4480f070c24805ecb37a660bd8dd812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c59bb9b70e4cac9aa950f50c975a2fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#a1c59bb9b70e4cac9aa950f50c975a2fe">AddSelector</a> (TriggerSelectorEnum aIndex, SelectorEntry aSelector)</td></tr>
<tr class="memdesc:a1c59bb9b70e4cac9aa950f50c975a2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a TriggerSelector to the map of selectors.  <a href="class_pv_streaming_channel_source_trigger.html#a1c59bb9b70e4cac9aa950f50c975a2fe">More...</a><br /></td></tr>
<tr class="separator:a1c59bb9b70e4cac9aa950f50c975a2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91209a6a86a65da3189a59301f5e5ada"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#a91209a6a86a65da3189a59301f5e5ada">AddSource</a> (uint32_t aIndex, const <a class="el" href="class_pv_string.html">PvString</a> &amp;aName)</td></tr>
<tr class="memdesc:a91209a6a86a65da3189a59301f5e5ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a TriggerSource to the list of sources.  <a href="class_pv_streaming_channel_source_trigger.html#a91209a6a86a65da3189a59301f5e5ada">More...</a><br /></td></tr>
<tr class="separator:a91209a6a86a65da3189a59301f5e5ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa7596f225b6c7b4161a02325b0b82a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#a8aa7596f225b6c7b4161a02325b0b82a">GetMode</a> () const</td></tr>
<tr class="memdesc:a8aa7596f225b6c7b4161a02325b0b82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the TriggerMode of the current TriggerSelector.  <a href="class_pv_streaming_channel_source_trigger.html#a8aa7596f225b6c7b4161a02325b0b82a">More...</a><br /></td></tr>
<tr class="separator:a8aa7596f225b6c7b4161a02325b0b82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17affc3c4eccc84d50e6a2e804b9e74"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_trigger.html#ac17affc3c4eccc84d50e6a2e804b9e74">GetSource</a> () const</td></tr>
<tr class="memdesc:ac17affc3c4eccc84d50e6a2e804b9e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enum entry index of TriggerSource for the current TriggerSelector.  <a href="class_pv_streaming_channel_source_trigger.html#ac17affc3c4eccc84d50e6a2e804b9e74">More...</a><br /></td></tr>
<tr class="separator:ac17affc3c4eccc84d50e6a2e804b9e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_pv_streaming_channel_source"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_pv_streaming_channel_source')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_pv_streaming_channel_source.html">IPvStreamingChannelSource</a></td></tr>
<tr class="memitem:a009f9d92de5d8dab161f319be1e1b073 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top"><a id="a009f9d92de5d8dab161f319be1e1b073"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a009f9d92de5d8dab161f319be1e1b073">~IPvStreamingChannelSource</a> ()</td></tr>
<tr class="memdesc:a009f9d92de5d8dab161f319be1e1b073 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a009f9d92de5d8dab161f319be1e1b073 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e48b02b47d569fa6813cdae708366d inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a75e48b02b47d569fa6813cdae708366d">GetWidth</a> () const =0</td></tr>
<tr class="memdesc:a75e48b02b47d569fa6813cdae708366d inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image width.  <a href="class_i_pv_streaming_channel_source.html#a75e48b02b47d569fa6813cdae708366d">More...</a><br /></td></tr>
<tr class="separator:a75e48b02b47d569fa6813cdae708366d inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e7a77219e025d7dfecf087cb0dcd0f inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a98e7a77219e025d7dfecf087cb0dcd0f">GetHeight</a> () const =0</td></tr>
<tr class="memdesc:a98e7a77219e025d7dfecf087cb0dcd0f inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image height.  <a href="class_i_pv_streaming_channel_source.html#a98e7a77219e025d7dfecf087cb0dcd0f">More...</a><br /></td></tr>
<tr class="separator:a98e7a77219e025d7dfecf087cb0dcd0f inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be122cd1c15190f9e48b2fa9f53f48a inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a1be122cd1c15190f9e48b2fa9f53f48a">GetOffsetX</a> () const =0</td></tr>
<tr class="memdesc:a1be122cd1c15190f9e48b2fa9f53f48a inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image offset X.  <a href="class_i_pv_streaming_channel_source.html#a1be122cd1c15190f9e48b2fa9f53f48a">More...</a><br /></td></tr>
<tr class="separator:a1be122cd1c15190f9e48b2fa9f53f48a inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb4f731aa43007400f746d127973f03 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#abcb4f731aa43007400f746d127973f03">GetOffsetY</a> () const =0</td></tr>
<tr class="memdesc:abcb4f731aa43007400f746d127973f03 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image offset Y.  <a href="class_i_pv_streaming_channel_source.html#abcb4f731aa43007400f746d127973f03">More...</a><br /></td></tr>
<tr class="separator:abcb4f731aa43007400f746d127973f03 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0288e5a39738308217e6404a5e84cfba inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a0288e5a39738308217e6404a5e84cfba">GetPixelType</a> () const =0</td></tr>
<tr class="memdesc:a0288e5a39738308217e6404a5e84cfba inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current pixel type.  <a href="class_i_pv_streaming_channel_source.html#a0288e5a39738308217e6404a5e84cfba">More...</a><br /></td></tr>
<tr class="separator:a0288e5a39738308217e6404a5e84cfba inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541f29284aa630980adb8e136f409082 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a541f29284aa630980adb8e136f409082">GetWidthInfo</a> (uint32_t &amp;aMin, uint32_t &amp;aMax, uint32_t &amp;aInc) const =0</td></tr>
<tr class="memdesc:a541f29284aa630980adb8e136f409082 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stream channel width attributes.  <a href="class_i_pv_streaming_channel_source.html#a541f29284aa630980adb8e136f409082">More...</a><br /></td></tr>
<tr class="separator:a541f29284aa630980adb8e136f409082 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7064bbf89cc93c94f1d38f3266210d7 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#ac7064bbf89cc93c94f1d38f3266210d7">GetHeightInfo</a> (uint32_t &amp;aMin, uint32_t &amp;aMax, uint32_t &amp;aInc) const =0</td></tr>
<tr class="memdesc:ac7064bbf89cc93c94f1d38f3266210d7 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stream channel height attributes.  <a href="class_i_pv_streaming_channel_source.html#ac7064bbf89cc93c94f1d38f3266210d7">More...</a><br /></td></tr>
<tr class="separator:ac7064bbf89cc93c94f1d38f3266210d7 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdea1aa87836d12f8dfc731a7bc2c8be inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#abdea1aa87836d12f8dfc731a7bc2c8be">GetChunksSize</a> () const =0</td></tr>
<tr class="memdesc:abdea1aa87836d12f8dfc731a7bc2c8be inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stream channel chunk size attributes.  <a href="class_i_pv_streaming_channel_source.html#abdea1aa87836d12f8dfc731a7bc2c8be">More...</a><br /></td></tr>
<tr class="separator:abdea1aa87836d12f8dfc731a7bc2c8be inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acea878109ed0aa518dbb620af0493c inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a2acea878109ed0aa518dbb620af0493c">GetPayloadSize</a> () const =0</td></tr>
<tr class="memdesc:a2acea878109ed0aa518dbb620af0493c inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream channel payload size in bytes. Return zero to have it inferred from width, height and pixel format.  <a href="class_i_pv_streaming_channel_source.html#a2acea878109ed0aa518dbb620af0493c">More...</a><br /></td></tr>
<tr class="separator:a2acea878109ed0aa518dbb620af0493c inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9101f68e3fa8d30114bdbb1b4eb4d481 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual PvScanType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a9101f68e3fa8d30114bdbb1b4eb4d481">GetScanType</a> () const =0</td></tr>
<tr class="memdesc:a9101f68e3fa8d30114bdbb1b4eb4d481 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scan type that is used by the streaming source.  <a href="class_i_pv_streaming_channel_source.html#a9101f68e3fa8d30114bdbb1b4eb4d481">More...</a><br /></td></tr>
<tr class="separator:a9101f68e3fa8d30114bdbb1b4eb4d481 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4b27f1c6ac46d738ea90be800a14e1 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#afb4b27f1c6ac46d738ea90be800a14e1">GetChunkModeActive</a> () const =0</td></tr>
<tr class="memdesc:afb4b27f1c6ac46d738ea90be800a14e1 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the current master chunk mode is active.  <a href="class_i_pv_streaming_channel_source.html#afb4b27f1c6ac46d738ea90be800a14e1">More...</a><br /></td></tr>
<tr class="separator:afb4b27f1c6ac46d738ea90be800a14e1 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cfdc32bd4ba2ce0fa7b7663e9a682c inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#ac1cfdc32bd4ba2ce0fa7b7663e9a682c">GetChunkEnable</a> (uint32_t aChunkID) const =0</td></tr>
<tr class="memdesc:ac1cfdc32bd4ba2ce0fa7b7663e9a682c inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current chunk enabled state.  <a href="class_i_pv_streaming_channel_source.html#ac1cfdc32bd4ba2ce0fa7b7663e9a682c">More...</a><br /></td></tr>
<tr class="separator:ac1cfdc32bd4ba2ce0fa7b7663e9a682c inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c82aa29f3c8beef373155074f657df inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#aa7c82aa29f3c8beef373155074f657df">GetSupportedPixelType</a> (int aIndex, <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> &amp;aPixelType) const =0</td></tr>
<tr class="memdesc:aa7c82aa29f3c8beef373155074f657df inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains an index of supported pixel types. Used at <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> time to create the GenICam XML of the device.  <a href="class_i_pv_streaming_channel_source.html#aa7c82aa29f3c8beef373155074f657df">More...</a><br /></td></tr>
<tr class="separator:aa7c82aa29f3c8beef373155074f657df inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1747831496274d6e0b38c6c78e8491 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a5d1747831496274d6e0b38c6c78e8491">GetSupportedChunk</a> (int aIndex, uint32_t &amp;aID, <a class="el" href="class_pv_string.html">PvString</a> &amp;aName) const =0</td></tr>
<tr class="memdesc:a5d1747831496274d6e0b38c6c78e8491 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indexed supported chunk type. Used at <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> time to create the GenICam XML of the device.  <a href="class_i_pv_streaming_channel_source.html#a5d1747831496274d6e0b38c6c78e8491">More...</a><br /></td></tr>
<tr class="separator:a5d1747831496274d6e0b38c6c78e8491 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d0aaf4828da15f77fd4e3f221f000f inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a44d0aaf4828da15f77fd4e3f221f000f">SetWidth</a> (uint32_t aWidth)=0</td></tr>
<tr class="memdesc:a44d0aaf4828da15f77fd4e3f221f000f inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image width.  <a href="class_i_pv_streaming_channel_source.html#a44d0aaf4828da15f77fd4e3f221f000f">More...</a><br /></td></tr>
<tr class="separator:a44d0aaf4828da15f77fd4e3f221f000f inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878cb7d39d9f4c7034a95f14947535d0 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a878cb7d39d9f4c7034a95f14947535d0">SetHeight</a> (uint32_t aHeight)=0</td></tr>
<tr class="memdesc:a878cb7d39d9f4c7034a95f14947535d0 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image height.  <a href="class_i_pv_streaming_channel_source.html#a878cb7d39d9f4c7034a95f14947535d0">More...</a><br /></td></tr>
<tr class="separator:a878cb7d39d9f4c7034a95f14947535d0 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4572d298d03100c8dcd4d92de9eee6c1 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a4572d298d03100c8dcd4d92de9eee6c1">SetOffsetX</a> (uint32_t aOffsetX)=0</td></tr>
<tr class="memdesc:a4572d298d03100c8dcd4d92de9eee6c1 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image offset X.  <a href="class_i_pv_streaming_channel_source.html#a4572d298d03100c8dcd4d92de9eee6c1">More...</a><br /></td></tr>
<tr class="separator:a4572d298d03100c8dcd4d92de9eee6c1 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955f86fae157bb97cf1ad4289b18b52f inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a955f86fae157bb97cf1ad4289b18b52f">SetOffsetY</a> (uint32_t aOffsetY)=0</td></tr>
<tr class="memdesc:a955f86fae157bb97cf1ad4289b18b52f inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image offset Y.  <a href="class_i_pv_streaming_channel_source.html#a955f86fae157bb97cf1ad4289b18b52f">More...</a><br /></td></tr>
<tr class="separator:a955f86fae157bb97cf1ad4289b18b52f inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d437dc2bebce465562dc36a1287c056 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a7d437dc2bebce465562dc36a1287c056">SetPixelType</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)=0</td></tr>
<tr class="memdesc:a7d437dc2bebce465562dc36a1287c056 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image pixel type.  <a href="class_i_pv_streaming_channel_source.html#a7d437dc2bebce465562dc36a1287c056">More...</a><br /></td></tr>
<tr class="separator:a7d437dc2bebce465562dc36a1287c056 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69946f8085eccd27ee06bb75b1d55b74 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a69946f8085eccd27ee06bb75b1d55b74">SetChunkModeActive</a> (bool aEnabled)=0</td></tr>
<tr class="memdesc:a69946f8085eccd27ee06bb75b1d55b74 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the master chunk mode active state.  <a href="class_i_pv_streaming_channel_source.html#a69946f8085eccd27ee06bb75b1d55b74">More...</a><br /></td></tr>
<tr class="separator:a69946f8085eccd27ee06bb75b1d55b74 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8adf8e1bd0b86e990c8a441b41b5447 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#ad8adf8e1bd0b86e990c8a441b41b5447">SetChunkEnable</a> (uint32_t aChunkID, bool aEnabled)=0</td></tr>
<tr class="memdesc:ad8adf8e1bd0b86e990c8a441b41b5447 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the chunk enabled state for a specific chunk type.  <a href="class_i_pv_streaming_channel_source.html#ad8adf8e1bd0b86e990c8a441b41b5447">More...</a><br /></td></tr>
<tr class="separator:ad8adf8e1bd0b86e990c8a441b41b5447 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bf48ef40df3b27f5362fa161cc593b inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a64bf48ef40df3b27f5362fa161cc593b">OnOpen</a> (const <a class="el" href="class_pv_string.html">PvString</a> &amp;aDestIP, uint16_t aDestPort)=0</td></tr>
<tr class="memdesc:a64bf48ef40df3b27f5362fa161cc593b inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> that this streaming channel has been opened.  <a href="class_i_pv_streaming_channel_source.html#a64bf48ef40df3b27f5362fa161cc593b">More...</a><br /></td></tr>
<tr class="separator:a64bf48ef40df3b27f5362fa161cc593b inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17eea70aae262021077dce4ecc22013 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top"><a id="af17eea70aae262021077dce4ecc22013"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#af17eea70aae262021077dce4ecc22013">OnClose</a> ()=0</td></tr>
<tr class="memdesc:af17eea70aae262021077dce4ecc22013 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> that this streaming channel has been closed. <br /></td></tr>
<tr class="separator:af17eea70aae262021077dce4ecc22013 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd95b0fe165ef567dc903ce78f952cb inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a7bd95b0fe165ef567dc903ce78f952cb">AllocBuffer</a> ()=0</td></tr>
<tr class="memdesc:a7bd95b0fe165ef567dc903ce78f952cb inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to allocate a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>.  <a href="class_i_pv_streaming_channel_source.html#a7bd95b0fe165ef567dc903ce78f952cb">More...</a><br /></td></tr>
<tr class="separator:a7bd95b0fe165ef567dc903ce78f952cb inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b95fe82221d67ddfa76e7bdb714d78e inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a0b95fe82221d67ddfa76e7bdb714d78e">FreeBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)=0</td></tr>
<tr class="memdesc:a0b95fe82221d67ddfa76e7bdb714d78e inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to free or release a buffer allocated with AllocBuffer.  <a href="class_i_pv_streaming_channel_source.html#a0b95fe82221d67ddfa76e7bdb714d78e">More...</a><br /></td></tr>
<tr class="separator:a0b95fe82221d67ddfa76e7bdb714d78e inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b5caefc101c6c43b6a6aafe5ca28d6 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#ab3b5caefc101c6c43b6a6aafe5ca28d6">QueueBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)=0</td></tr>
<tr class="memdesc:ab3b5caefc101c6c43b6a6aafe5ca28d6 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to queue a buffer for acquisition.  <a href="class_i_pv_streaming_channel_source.html#ab3b5caefc101c6c43b6a6aafe5ca28d6">More...</a><br /></td></tr>
<tr class="separator:ab3b5caefc101c6c43b6a6aafe5ca28d6 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d9014976bf5911124fa042d2b0cb7a inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a76d9014976bf5911124fa042d2b0cb7a">RetrieveBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffer)=0</td></tr>
<tr class="memdesc:a76d9014976bf5911124fa042d2b0cb7a inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to retrieve a buffer from the streaming source.  <a href="class_i_pv_streaming_channel_source.html#a76d9014976bf5911124fa042d2b0cb7a">More...</a><br /></td></tr>
<tr class="separator:a76d9014976bf5911124fa042d2b0cb7a inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d6d94e883f928107a61b019f15f1bf inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#ac8d6d94e883f928107a61b019f15f1bf">AbortQueuedBuffers</a> ()=0</td></tr>
<tr class="memdesc:ac8d6d94e883f928107a61b019f15f1bf inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to abort all buffers queued for acquisition.  <a href="class_i_pv_streaming_channel_source.html#ac8d6d94e883f928107a61b019f15f1bf">More...</a><br /></td></tr>
<tr class="separator:ac8d6d94e883f928107a61b019f15f1bf inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfb312228bb1cb68a06245294df54eb inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#aebfb312228bb1cb68a06245294df54eb">IsPayloadTypeSupported</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType)</td></tr>
<tr class="memdesc:aebfb312228bb1cb68a06245294df54eb inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, the streaming source has to return whether the specificed payload type is supported or not.  <a href="class_i_pv_streaming_channel_source.html#aebfb312228bb1cb68a06245294df54eb">More...</a><br /></td></tr>
<tr class="separator:aebfb312228bb1cb68a06245294df54eb inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021da3f3c44e1ae2f4a92674566897c0 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a021da3f3c44e1ae2f4a92674566897c0">SetMultiPartAllowed</a> (bool aAllowed)</td></tr>
<tr class="memdesc:a021da3f3c44e1ae2f4a92674566897c0 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the streaming source is allowed or not, but not forced, to transmit multi-part data.  <a href="class_i_pv_streaming_channel_source.html#a021da3f3c44e1ae2f4a92674566897c0">More...</a><br /></td></tr>
<tr class="separator:a021da3f3c44e1ae2f4a92674566897c0 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072c52233051fabb3f5ca3e9237dc8b7 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a072c52233051fabb3f5ca3e9237dc8b7">SetLargeLeaderTrailerEnabled</a> (bool aEnabled, uint32_t aMaxMultiPartCount)</td></tr>
<tr class="memdesc:a072c52233051fabb3f5ca3e9237dc8b7 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the streaming source which transmit multi-part data uses large data leader and trailer packets.  <a href="class_i_pv_streaming_channel_source.html#a072c52233051fabb3f5ca3e9237dc8b7">More...</a><br /></td></tr>
<tr class="separator:a072c52233051fabb3f5ca3e9237dc8b7 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aabac21df5f952506eda964976d4b3 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a01aabac21df5f952506eda964976d4b3">SetTestPayloadFormatMode</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType)</td></tr>
<tr class="memdesc:a01aabac21df5f952506eda964976d4b3 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, the streaming source has to ensure it can stream buffers of the specified payload type.  <a href="class_i_pv_streaming_channel_source.html#a01aabac21df5f952506eda964976d4b3">More...</a><br /></td></tr>
<tr class="separator:a01aabac21df5f952506eda964976d4b3 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_pv_register_event_sink"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_pv_register_event_sink')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_pv_register_event_sink.html">IPvRegisterEventSink</a></td></tr>
<tr class="memitem:a64148cd466b26c04210b94a3af5c0c17 inherit pub_methods_class_i_pv_register_event_sink"><td class="memItemLeft" align="right" valign="top"><a id="a64148cd466b26c04210b94a3af5c0c17"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_register_event_sink.html#a64148cd466b26c04210b94a3af5c0c17">~IPvRegisterEventSink</a> ()</td></tr>
<tr class="memdesc:a64148cd466b26c04210b94a3af5c0c17 inherit pub_methods_class_i_pv_register_event_sink"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a64148cd466b26c04210b94a3af5c0c17 inherit pub_methods_class_i_pv_register_event_sink"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bebc47e7a0c5710476e6c9d8b60fe5 inherit pub_methods_class_i_pv_register_event_sink"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_register_event_sink.html#a57bebc47e7a0c5710476e6c9d8b60fe5">PostRead</a> (<a class="el" href="class_i_pv_register.html">IPvRegister</a> *aRegister)</td></tr>
<tr class="memdesc:a57bebc47e7a0c5710476e6c9d8b60fe5 inherit pub_methods_class_i_pv_register_event_sink"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-read register notification.  <a href="class_i_pv_register_event_sink.html#a57bebc47e7a0c5710476e6c9d8b60fe5">More...</a><br /></td></tr>
<tr class="separator:a57bebc47e7a0c5710476e6c9d8b60fe5 inherit pub_methods_class_i_pv_register_event_sink"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e2eee9d917a47188e14886d5a08a97 inherit pub_methods_class_i_pv_register_event_sink"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_register_event_sink.html#a53e2eee9d917a47188e14886d5a08a97">PostWrite</a> (<a class="el" href="class_i_pv_register.html">IPvRegister</a> *aRegister)</td></tr>
<tr class="memdesc:a53e2eee9d917a47188e14886d5a08a97 inherit pub_methods_class_i_pv_register_event_sink"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-write register notification.  <a href="class_i_pv_register_event_sink.html#a53e2eee9d917a47188e14886d5a08a97">More...</a><br /></td></tr>
<tr class="separator:a53e2eee9d917a47188e14886d5a08a97 inherit pub_methods_class_i_pv_register_event_sink"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation providing Trigger support for the <a class="el" href="class_i_pv_streaming_channel_source.html" title="Interface that is used by PvSoftDeviceGEV to query and report information from a streaming source imp...">IPvStreamingChannelSource</a> interface. </p>
<p><a class="el" href="class_pv_streaming_channel_source_trigger.html" title="An implementation providing Trigger support for the IPvStreamingChannelSource interface.">PvStreamingChannelSourceTrigger</a> provides basic Trigger support, with TriggerSelector such as AcquisitionStart, FrameStart and LineStart. It also provides an API to add/remove custom-made TriggerSelector entries, as well as TriggerSource entries.</p>
<p>When TriggerSource set to TriggerSoftware, there is a trigger fire call available that avoids having to call the TriggerSoftware ICommand. This provides a low-latency mechanism for software trigger.</p>
<p>If you require simple Trigger mechanics, create a class derived from this one (providing the required implementations of pure virtual functions), add any of the already-provided TriggerSelector.</p>
<p>For custom requirements, provide a concrete implementation of ITriggerSelector class and add an object of this class to <a class="el" href="class_pv_streaming_channel_source_trigger.html" title="An implementation providing Trigger support for the IPvStreamingChannelSource interface.">PvStreamingChannelSourceTrigger</a>, which will manage its lifetime. You can also add custom TriggerSource entries. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae3e7fccb2c946104119b6968962fd2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e7fccb2c946104119b6968962fd2b7">&#9670;&nbsp;</a></span>PvStreamingChannelSourceTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvStreamingChannelSourceTrigger::PvStreamingChannelSourceTrigger </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aRegisterBaseAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aChannel</td><td>Index of the current streaming channel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aRegisterBaseAddress</td><td>Base address for all the Trigger-related registers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1c59bb9b70e4cac9aa950f50c975a2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c59bb9b70e4cac9aa950f50c975a2fe">&#9670;&nbsp;</a></span>AddSelector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceTrigger::AddSelector </td>
          <td>(</td>
          <td class="paramtype">TriggerSelectorEnum&#160;</td>
          <td class="paramname"><em>aSelectorIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SelectorEntry&#160;</td>
          <td class="paramname"><em>aSelector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a TriggerSelector to the map of selectors. </p>
<p>This function creates the appropriate GenApi enum entry for the TriggerSelector feature. The enum entry shown is the name given to the ITriggerSelector object.</p>
<p>Newly added selector should not used previously allocated index. If so, the added selector will replace the old one.</p>
<p>Life cycle of added selectors is managed by this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aSelectorIndex</td><td>Index of the selector to add, as per TriggerSelectorEnum. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSelector</td><td>The selector to add to the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91209a6a86a65da3189a59301f5e5ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91209a6a86a65da3189a59301f5e5ada">&#9670;&nbsp;</a></span>AddSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceTrigger::AddSource </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_pv_string.html">PvString</a> &amp;&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a TriggerSource to the list of sources. </p>
<p>This function creates the appropriate GenApi enum entry for the TriggerSource feature.</p>
<p>If required, the 'Software' entry has to be manually added. It also has to have its index set to '0'. All other entries are considered hardware triggers, and do not allow a software trigger to be generated by either call to <a class="el" href="class_pv_streaming_channel_source_trigger.html#ad4480f070c24805ecb37a660bd8dd812" title="Software trigger.">FireTrigger</a>, or TriggerSoftware ICommand.</p>
<p>All distinct entries must have a unique index. Similar entries between streaming channels should share the same index. It is the responsibility of the programmer to maintain the global list of indexes.</p>
<p>For example, if the 'Software' Source entry is assigned index 0, it has to be added in each streaming channel source where it is required by calling: </p><div class="fragment"><div class="line"><a class="code" href="class_pv_streaming_channel_source_trigger.html#a91209a6a86a65da3189a59301f5e5ada">AddSource</a>( 0, <span class="stringliteral">&quot;Software&quot;</span> );</div>
<div class="ttc" id="aclass_pv_streaming_channel_source_trigger_html_a91209a6a86a65da3189a59301f5e5ada"><div class="ttname"><a href="class_pv_streaming_channel_source_trigger.html#a91209a6a86a65da3189a59301f5e5ada">PvStreamingChannelSourceTrigger::AddSource</a></div><div class="ttdeci">void AddSource(uint32_t aIndex, const PvString &amp;aName)</div><div class="ttdoc">Adds a TriggerSource to the list of sources.</div><div class="ttdef"><b>Definition:</b> PvStreamingChannelSourceTrigger.cpp:451</div></div>
</div><!-- fragment --><p> In that case, no other Source entry can be added with the index '0'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Index of the associated enum entry. Must be unique for all distinct entries. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aName</td><td>Name to display for the enum entry in TriggerSource. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a877af6a22b84ddf36ebc3bb050f4936e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877af6a22b84ddf36ebc3bb050f4936e">&#9670;&nbsp;</a></span>CreateGenApiFeatures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceTrigger::CreateGenApiFeatures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *&#160;</td>
          <td class="paramname"><em>aRegisterMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv_gen_api_factory.html">IPvGenApiFactory</a> *&#160;</td>
          <td class="paramname"><em>aFactory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates all Trigger-related GenApi parameters if they are needed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_pv_streaming_channel_source.html#aa53b1fc8526c801f3cf097e7528a21f3" title="When called, the streaming channel source should create its custom GenApi parameters if they are need...">IPvStreamingChannelSource::CreateGenApiFeatures</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRegisterMap</td><td>The register map of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFactory</td><td>GenApi factory used to create the new GenApi features. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_i_pv_streaming_channel_source.html#aa53b1fc8526c801f3cf097e7528a21f3">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="af408c53d2bd2c04141fe994fe6a06e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af408c53d2bd2c04141fe994fe6a06e4c">&#9670;&nbsp;</a></span>CreateRegisters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceTrigger::CreateRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *&#160;</td>
          <td class="paramname"><em>aRegisterMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv_register_factory.html">IPvRegisterFactory</a> *&#160;</td>
          <td class="paramname"><em>aFactory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates all required Trigger-related registers . </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_pv_streaming_channel_source.html#a4d1eb6d88bcfc0c3b40f24493ec6df37" title="When called, the streaming channel source should create its custom registers if they are needed.">IPvStreamingChannelSource::CreateRegisters</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRegisterMap</td><td>The register map of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFactory</td><td>Register factory used to create the new registers. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_i_pv_streaming_channel_source.html#a4d1eb6d88bcfc0c3b40f24493ec6df37">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="ad4480f070c24805ecb37a660bd8dd812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4480f070c24805ecb37a660bd8dd812">&#9670;&nbsp;</a></span>FireTrigger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceTrigger::FireTrigger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Software trigger. </p>
<p>Fires a software trigger for the current TriggerSelector.</p>
<p>Trigger is fired only if TriggerSource is set to 'Software'. </p>

</div>
</div>
<a id="a8aa7596f225b6c7b4161a02325b0b82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa7596f225b6c7b4161a02325b0b82a">&#9670;&nbsp;</a></span>GetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvStreamingChannelSourceTrigger::GetMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the TriggerMode of the current TriggerSelector. </p>
<dl class="section return"><dt>Returns</dt><dd>True if TriggerMode is set to 'On'. </dd></dl>

</div>
</div>
<a id="ac17affc3c4eccc84d50e6a2e804b9e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17affc3c4eccc84d50e6a2e804b9e74">&#9670;&nbsp;</a></span>GetSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvStreamingChannelSourceTrigger::GetSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enum entry index of TriggerSource for the current TriggerSelector. </p>
<p>\ return Index (0-based) of the currently selected TriggerSource. </p>

</div>
</div>
<a id="acca1fce50fcd92d5cfa9fe315df8910d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca1fce50fcd92d5cfa9fe315df8910d">&#9670;&nbsp;</a></span>OnStreamingStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceTrigger::OnStreamingStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notification that the GigE Vision controller has requested that the device start streaming on this channel. </p>
<p>Calls the Start() function of the current TriggerSelector.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_pv_streaming_channel_source.html#a71ce2f5067a95b5687906a2bbe79e239" title="Notification that the GigE Vision controller has requested that the device start streaming on this ch...">IPvStreamingChannelSource::OnStreamingStart</a> </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a71ce2f5067a95b5687906a2bbe79e239">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="ac3110dca47fe2becb92e37142249068e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3110dca47fe2becb92e37142249068e">&#9670;&nbsp;</a></span>OnStreamingStop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceTrigger::OnStreamingStop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notification that the GigE Vision controller has requested that the device stop streaming on this channel. </p>
<p>Calls the Stop() function of the current TriggerSelector.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_pv_streaming_channel_source.html#aadb0d738487d4131aa8898fd209218b9" title="Notification that the GigE Vision controller has requested that the device stop streaming on this cha...">IPvStreamingChannelSource::OnStreamingStop</a> </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#aadb0d738487d4131aa8898fd209218b9">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="afe52aacbc532160daac21a12728e69e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe52aacbc532160daac21a12728e69e8">&#9670;&nbsp;</a></span>Persist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceTrigger::Persist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv_register.html">IPvRegister</a> *&#160;</td>
          <td class="paramname"><em>aRegister</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv_register_store.html">IPvRegisterStore</a> *&#160;</td>
          <td class="paramname"><em>aStore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peristence request for selected registers for user-sets. </p>
<p>This interface callback is invoked when saving to or loading from registers in the context of user-sets.</p>
<p>Some features only use one register which maps to multiple objects or variables depending on the state of its selector(s). Those features require special persistence handling to be properly mapped to user sets.</p>
<p>To persist device-side selected registers the code needs to go through all possible selector values and call <a class="el" href="class_i_pv_register_store.html#a918917ee9e0836094ca98098f3c4cc38" title="Persists a register to the register store using a name suffix.">IPvRegisterStore::Persist</a> with the register, the store and the a suffix to used to make the selected register instance unique. If a register is affected by more than one selector, all possible combinations must be walked-through.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_pv_register_event_sink.html#a74c37e2203dee7850e7e62f8b9dfac1a" title="Peristence request for selected registers for user-sets.">IPvRegisterEventSink::Persist</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRegister</td><td>Register to persist. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aStore</td><td>Register store to use for persistence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if the method successfully handled persistence for the register.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca79f3ef17e3d22d3ac8a6840007ba261d">PvResult::Code::NOT_IMPLEMENTED</a> if the register does not need advanced persistence. Returned by default implementation.</li>
<li>Any other <a class="el" href="class_pv_result.html" title="Result information.">PvResult</a> error code on failure. </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_i_pv_register_event_sink.html#a74c37e2203dee7850e7e62f8b9dfac1a">IPvRegisterEventSink</a>.</p>

</div>
</div>
<a id="a7b13db31fa1c6321b72ec1cf62ffce09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b13db31fa1c6321b72ec1cf62ffce09">&#9670;&nbsp;</a></span>PostRetrieveBufferProc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceTrigger::PostRetrieveBufferProc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an advanced feature used mostly internally. For expert users only. It is higly recommended to not override but use the default implementation. </p>

<p>Reimplemented from <a class="el" href="class_i_pv_streaming_channel_source.html#a1bd138aa4e4b471ea13ff8597f3c0d4a">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="acca0ce45493ec5c0ad37fd09c3e8636f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca0ce45493ec5c0ad37fd09c3e8636f">&#9670;&nbsp;</a></span>PreQueueBufferProc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvStreamingChannelSourceTrigger::PreQueueBufferProc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an advanced feature used mostly internally. For expert users only. It is higly recommended to not override but use the default implementation.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the processing loop can proceed with queueing/retrieving next buffer. </dd></dl>

<p>Reimplemented from <a class="el" href="class_i_pv_streaming_channel_source.html#a147f8770bee5d78e47780d3ba19dfe6b">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a07c44a61d7ffa44666ac1a6031259c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c44a61d7ffa44666ac1a6031259c0f">&#9670;&nbsp;</a></span>PreRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceTrigger::PreRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv_register.html">IPvRegister</a> *&#160;</td>
          <td class="paramname"><em>aRegister</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-read register notification. </p>
<p>Handles the pre-read operations on the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> for Trigger-related registers created in this class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_pv_register_event_sink.html#a87b362a2fe3dcafee78c7f8ef05114ec" title="Pre-read register notification.">IPvRegisterEventSink::PreRead</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRegister</td><td>Register to which the notification applies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li>Any <a class="el" href="class_pv_result.html" title="Result information.">PvResult</a> error code on failure. </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_i_pv_register_event_sink.html#a87b362a2fe3dcafee78c7f8ef05114ec">IPvRegisterEventSink</a>.</p>

</div>
</div>
<a id="a80aa7d394f4d9e737114905598340d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80aa7d394f4d9e737114905598340d5d">&#9670;&nbsp;</a></span>PreWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceTrigger::PreWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv_register.html">IPvRegister</a> *&#160;</td>
          <td class="paramname"><em>aRegister</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-write register notification. </p>
<p>Handles the pre-write operations on the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> for Trigger-related registers created in this class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_pv_register_event_sink.html#a00281cbdc57471179e35bc715a97ff4f" title="Pre-write register notification.">IPvRegisterEventSink::PreWrite</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRegister</td><td>Register to which the notification applies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li>Any <a class="el" href="class_pv_result.html" title="Result information.">PvResult</a> error code on failure. </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_i_pv_register_event_sink.html#a00281cbdc57471179e35bc715a97ff4f">IPvRegisterEventSink</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_streaming_channel_source_trigger_8h_source.html">PvStreamingChannelSourceTrigger.h</a></li>
<li>PvStreamingChannelSourceTrigger.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2024 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
