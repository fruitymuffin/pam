<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>IPvChunkData Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v6.4.0.6670 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_i_pv_chunk_data.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_i_pv_chunk_data-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IPvChunkData Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic chunk data interface.  
 <a href="class_i_pv_chunk_data.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_pv_chunk_data_8h_source.html">PvChunkData.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaf2aa453fdc92066e4a491f8f52dda38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#aaf2aa453fdc92066e4a491f8f52dda38">ResetChunks</a> ()=0</td></tr>
<tr class="memdesc:aaf2aa453fdc92066e4a491f8f52dda38"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#aa85ffe3e0c299debda560f22112f98ec" title="Resets the internal chunk state.">PvBuffer::ResetChunks</a>.  <a href="class_i_pv_chunk_data.html#aaf2aa453fdc92066e4a491f8f52dda38">More...</a><br /></td></tr>
<tr class="separator:aaf2aa453fdc92066e4a491f8f52dda38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f91bdf279a04768a20f6666323d82"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#a925f91bdf279a04768a20f6666323d82">AddChunk</a> (uint32_t aID, const uint8_t *aData, uint32_t aLength)=0</td></tr>
<tr class="memdesc:a925f91bdf279a04768a20f6666323d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a67ba6363162024610a5c52c63b4750ec" title="Add chunk data to the buffer.">PvBuffer::AddChunk</a>.  <a href="class_i_pv_chunk_data.html#a925f91bdf279a04768a20f6666323d82">More...</a><br /></td></tr>
<tr class="separator:a925f91bdf279a04768a20f6666323d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea33b069bc01272e029d59c73f3a301"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#a0ea33b069bc01272e029d59c73f3a301">SetChunkLayoutID</a> (uint32_t aChunkLayoutID)=0</td></tr>
<tr class="memdesc:a0ea33b069bc01272e029d59c73f3a301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the chunk data layout ID.  <a href="class_i_pv_chunk_data.html#a0ea33b069bc01272e029d59c73f3a301">More...</a><br /></td></tr>
<tr class="separator:a0ea33b069bc01272e029d59c73f3a301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d7d3b304116a7bfa1a16d89b973c37"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#af6d7d3b304116a7bfa1a16d89b973c37">HasChunks</a> () const =0</td></tr>
<tr class="memdesc:af6d7d3b304116a7bfa1a16d89b973c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the buffer has data chunks.  <a href="class_i_pv_chunk_data.html#af6d7d3b304116a7bfa1a16d89b973c37">More...</a><br /></td></tr>
<tr class="separator:af6d7d3b304116a7bfa1a16d89b973c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e09c02b3cb16cbab36a93b25c2bbe5"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#ad1e09c02b3cb16cbab36a93b25c2bbe5">GetChunkCount</a> ()=0</td></tr>
<tr class="memdesc:ad1e09c02b3cb16cbab36a93b25c2bbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#ac8586236cfce7b6149a0aeba5530616c" title="Returns the number of data chunks in the PvBuffer.">PvBuffer::GetChunkCount</a>.  <a href="class_i_pv_chunk_data.html#ad1e09c02b3cb16cbab36a93b25c2bbe5">More...</a><br /></td></tr>
<tr class="separator:ad1e09c02b3cb16cbab36a93b25c2bbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcfcc0ab9ccdff61a55739356e8e5ad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#adbcfcc0ab9ccdff61a55739356e8e5ad">GetChunkIDByIndex</a> (uint32_t aIndex, uint32_t &amp;aID)=0</td></tr>
<tr class="memdesc:adbcfcc0ab9ccdff61a55739356e8e5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a8377362f7f1f734dc2c013d280a5937a" title="Returns the ID of a chunk based on its index.">PvBuffer::GetChunkIDByIndex</a>.  <a href="class_i_pv_chunk_data.html#adbcfcc0ab9ccdff61a55739356e8e5ad">More...</a><br /></td></tr>
<tr class="separator:adbcfcc0ab9ccdff61a55739356e8e5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2019db32a8ae41a6709b3bb050be23"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#a6a2019db32a8ae41a6709b3bb050be23">GetChunkSizeByIndex</a> (uint32_t aIndex)=0</td></tr>
<tr class="memdesc:a6a2019db32a8ae41a6709b3bb050be23"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a7235900e888c98c167c41db82ac54ac6" title="Returns the size in bytes of the data chunk at zero-based aIndex.">PvBuffer::GetChunkSizeByIndex</a>.  <a href="class_i_pv_chunk_data.html#a6a2019db32a8ae41a6709b3bb050be23">More...</a><br /></td></tr>
<tr class="separator:a6a2019db32a8ae41a6709b3bb050be23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50a5624a81cd3ceca82f9e6c798c89e"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#aa50a5624a81cd3ceca82f9e6c798c89e">GetChunkSizeByID</a> (uint32_t aID)=0</td></tr>
<tr class="memdesc:aa50a5624a81cd3ceca82f9e6c798c89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#ae96371f3d9f3728cd17ecf663b9af7ec" title="Returns the size in bytes of the data chunk identified by aID.">PvBuffer::GetChunkSizeByID</a>.  <a href="class_i_pv_chunk_data.html#aa50a5624a81cd3ceca82f9e6c798c89e">More...</a><br /></td></tr>
<tr class="separator:aa50a5624a81cd3ceca82f9e6c798c89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e159b890b58b5dfa3ce44c5c92cacbe"><td class="memItemLeft" align="right" valign="top">virtual const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#a6e159b890b58b5dfa3ce44c5c92cacbe">GetChunkRawDataByIndex</a> (uint32_t aIndex)=0</td></tr>
<tr class="memdesc:a6e159b890b58b5dfa3ce44c5c92cacbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#afffd2ac9e5755b95263be72b331e5176" title="Returns a const pointer to the data chunk at zero-based aIndex.">PvBuffer::GetChunkRawDataByIndex</a>.  <a href="class_i_pv_chunk_data.html#a6e159b890b58b5dfa3ce44c5c92cacbe">More...</a><br /></td></tr>
<tr class="separator:a6e159b890b58b5dfa3ce44c5c92cacbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac016035ce32928e7ec56ea72d8513fa"><td class="memItemLeft" align="right" valign="top">virtual const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#aac016035ce32928e7ec56ea72d8513fa">GetChunkRawDataByID</a> (uint32_t aID)=0</td></tr>
<tr class="memdesc:aac016035ce32928e7ec56ea72d8513fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a1a00dd94c912ff14e487debf9599f7ae" title="Returns a const pointer to the data chunk with its ID matching aID.">PvBuffer::GetChunkRawDataByID</a>.  <a href="class_i_pv_chunk_data.html#aac016035ce32928e7ec56ea72d8513fa">More...</a><br /></td></tr>
<tr class="separator:aac016035ce32928e7ec56ea72d8513fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5907bd3acebd3b00e920861b4e6184f"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#ac5907bd3acebd3b00e920861b4e6184f">GetChunkLayoutID</a> ()=0</td></tr>
<tr class="memdesc:ac5907bd3acebd3b00e920861b4e6184f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chunk data layout ID.  <a href="class_i_pv_chunk_data.html#ac5907bd3acebd3b00e920861b4e6184f">More...</a><br /></td></tr>
<tr class="separator:ac5907bd3acebd3b00e920861b4e6184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40c6ecf3525a265319b30b8a385c2c6"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#ae40c6ecf3525a265319b30b8a385c2c6">GetChunkDataSize</a> () const =0</td></tr>
<tr class="memdesc:ae40c6ecf3525a265319b30b8a385c2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current chunk data size.  <a href="class_i_pv_chunk_data.html#ae40c6ecf3525a265319b30b8a385c2c6">More...</a><br /></td></tr>
<tr class="separator:ae40c6ecf3525a265319b30b8a385c2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9a7830547d36777fe6e8a4884aaf0f"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#aab9a7830547d36777fe6e8a4884aaf0f">GetChunkDataCapacity</a> () const =0</td></tr>
<tr class="memdesc:aab9a7830547d36777fe6e8a4884aaf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current chunk data capacity.  <a href="class_i_pv_chunk_data.html#aab9a7830547d36777fe6e8a4884aaf0f">More...</a><br /></td></tr>
<tr class="separator:aab9a7830547d36777fe6e8a4884aaf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic chunk data interface. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a925f91bdf279a04768a20f6666323d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925f91bdf279a04768a20f6666323d82">&#9670;&nbsp;</a></span>AddChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvChunkData::AddChunk </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>aData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#a67ba6363162024610a5c52c63b4750ec" title="Add chunk data to the buffer.">PvBuffer::AddChunk</a>. </p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>Chunk data ID for aIndex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aData</td><td>Payload data of the chunk data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aLength</td><td>Length of the payload data of the chunk, in bytes. Must be a multiple of 4 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_pv_result.html" title="Result information.">PvResult</a> is used to capture the success or failure of the operation:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca37cf2b6eb84b2f3286393bc9108cfab4">PvResult::Code::BUFFER_TOO_SMALL</a> There is not enough space in the buffer to add the chunk data.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> One of the input arguments is invalid. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_pv_buffer.html#a67ba6363162024610a5c52c63b4750ec">PvBuffer</a>.</p>

</div>
</div>
<a id="ad1e09c02b3cb16cbab36a93b25c2bbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e09c02b3cb16cbab36a93b25c2bbe5">&#9670;&nbsp;</a></span>GetChunkCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IPvChunkData::GetChunkCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#ac8586236cfce7b6149a0aeba5530616c" title="Returns the number of data chunks in the PvBuffer.">PvBuffer::GetChunkCount</a>. </p>
<p>See <a class="el" href="class_pv_buffer.html#ac8586236cfce7b6149a0aeba5530616c" title="Returns the number of data chunks in the PvBuffer.">PvBuffer::GetChunkCount</a>.</p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="section return"><dt>Returns</dt><dd>Data chunks count. 0 if no chunks are available. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_buffer.html#ac8586236cfce7b6149a0aeba5530616c">PvBuffer</a>.</p>

</div>
</div>
<a id="aab9a7830547d36777fe6e8a4884aaf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9a7830547d36777fe6e8a4884aaf0f">&#9670;&nbsp;</a></span>GetChunkDataCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t IPvChunkData::GetChunkDataCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current chunk data capacity. </p>
<p>In a transmission context where you create the buffer, memory is allocated for chunks. This method returns how many bytes can still be added as chunk data.</p>
<p>One chunk is always made of 8-bytes of headers plus the chunk data length. You also need to reserve another 8-bytes for the main chunk (typically the image) unless you buffer only contains chunk data.</p>
<p>This method has no use in a reception context where the data receiver delivers the buffer. Use either the direct chunk access methods or the GenApi interface of the device to access chunk data.</p>
<dl class="section return"><dt>Returns</dt><dd>Chunk data capacity. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_buffer.html#aeb3e5e475344222ae30f1a043a12c234">PvBuffer</a>.</p>

</div>
</div>
<a id="ae40c6ecf3525a265319b30b8a385c2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40c6ecf3525a265319b30b8a385c2c6">&#9670;&nbsp;</a></span>GetChunkDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t IPvChunkData::GetChunkDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current chunk data size. </p>
<p>In a transmission context this method returns how many bytes are used for extra chunk data. It includes the chunk headers for all chunk data and if applicable the chunk header for the main chunk (typically the image).</p>
<p>This method has no use in a reception context where the data receiver delivers the buffer. Use either the direct chunk access methods or the GenApi interface of the device to access chunk data.</p>
<dl class="section return"><dt>Returns</dt><dd>Chunk data size in bytes. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_buffer.html#a1aebdfa906085d5b0a344c329c8580a4">PvBuffer</a>.</p>

</div>
</div>
<a id="adbcfcc0ab9ccdff61a55739356e8e5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcfcc0ab9ccdff61a55739356e8e5ad">&#9670;&nbsp;</a></span>GetChunkIDByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvChunkData::GetChunkIDByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#a8377362f7f1f734dc2c013d280a5937a" title="Returns the ID of a chunk based on its index.">PvBuffer::GetChunkIDByIndex</a>. </p>
<p>See <a class="el" href="class_pv_buffer.html#a8377362f7f1f734dc2c013d280a5937a" title="Returns the ID of a chunk based on its index.">PvBuffer::GetChunkIDByIndex</a>.</p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aID</td><td>Data chunk ID for aIndex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_pv_result.html" title="Result information.">PvResult</a> is used to captured the success or failure of the operation as 0 can be a valid chunk ID:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa4357271e02951867594e0cc932c12f8">PvResult::Code::NOT_FOUND</a> if the index is out of range or the buffer does not have any chunks </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_pv_buffer.html#a8377362f7f1f734dc2c013d280a5937a">PvBuffer</a>.</p>

</div>
</div>
<a id="ac5907bd3acebd3b00e920861b4e6184f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5907bd3acebd3b00e920861b4e6184f">&#9670;&nbsp;</a></span>GetChunkLayoutID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IPvChunkData::GetChunkLayoutID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the chunk data layout ID. </p>
<dl class="section return"><dt>Returns</dt><dd>The current chunk data layout ID. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_buffer.html#a060941455775fc8a712ae9af82709f95">PvBuffer</a>.</p>

</div>
</div>
<a id="aac016035ce32928e7ec56ea72d8513fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac016035ce32928e7ec56ea72d8513fa">&#9670;&nbsp;</a></span>GetChunkRawDataByID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * IPvChunkData::GetChunkRawDataByID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#a1a00dd94c912ff14e487debf9599f7ae" title="Returns a const pointer to the data chunk with its ID matching aID.">PvBuffer::GetChunkRawDataByID</a>. </p>
<p>See <a class="el" href="class_pv_buffer.html#a1a00dd94c912ff14e487debf9599f7ae" title="Returns a const pointer to the data chunk with its ID matching aID.">PvBuffer::GetChunkRawDataByID</a>.</p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>Data chunk ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to chunk data. NULL if the chunk ID is not found. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_buffer.html#a1a00dd94c912ff14e487debf9599f7ae">PvBuffer</a>.</p>

</div>
</div>
<a id="a6e159b890b58b5dfa3ce44c5c92cacbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e159b890b58b5dfa3ce44c5c92cacbe">&#9670;&nbsp;</a></span>GetChunkRawDataByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * IPvChunkData::GetChunkRawDataByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#afffd2ac9e5755b95263be72b331e5176" title="Returns a const pointer to the data chunk at zero-based aIndex.">PvBuffer::GetChunkRawDataByIndex</a>. </p>
<p>See <a class="el" href="class_pv_buffer.html#afffd2ac9e5755b95263be72b331e5176" title="Returns a const pointer to the data chunk at zero-based aIndex.">PvBuffer::GetChunkRawDataByIndex</a>.</p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to chunk data. NULL if the index is out of range. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_buffer.html#afffd2ac9e5755b95263be72b331e5176">PvBuffer</a>.</p>

</div>
</div>
<a id="aa50a5624a81cd3ceca82f9e6c798c89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50a5624a81cd3ceca82f9e6c798c89e">&#9670;&nbsp;</a></span>GetChunkSizeByID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IPvChunkData::GetChunkSizeByID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#ae96371f3d9f3728cd17ecf663b9af7ec" title="Returns the size in bytes of the data chunk identified by aID.">PvBuffer::GetChunkSizeByID</a>. </p>
<p>See <a class="el" href="class_pv_buffer.html#ae96371f3d9f3728cd17ecf663b9af7ec" title="Returns the size in bytes of the data chunk identified by aID.">PvBuffer::GetChunkSizeByID</a>.</p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>Data chunk ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data chunk size. 0 if the chunk ID is not found. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_buffer.html#ae96371f3d9f3728cd17ecf663b9af7ec">PvBuffer</a>.</p>

</div>
</div>
<a id="a6a2019db32a8ae41a6709b3bb050be23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2019db32a8ae41a6709b3bb050be23">&#9670;&nbsp;</a></span>GetChunkSizeByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IPvChunkData::GetChunkSizeByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#a7235900e888c98c167c41db82ac54ac6" title="Returns the size in bytes of the data chunk at zero-based aIndex.">PvBuffer::GetChunkSizeByIndex</a>. </p>
<p>See <a class="el" href="class_pv_buffer.html#a7235900e888c98c167c41db82ac54ac6" title="Returns the size in bytes of the data chunk at zero-based aIndex.">PvBuffer::GetChunkSizeByIndex</a>.</p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> equivalent. Provided with this interface for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data chunk size. 0 if the index is out of range. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_buffer.html#a7235900e888c98c167c41db82ac54ac6">PvBuffer</a>.</p>

</div>
</div>
<a id="af6d7d3b304116a7bfa1a16d89b973c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d7d3b304116a7bfa1a16d89b973c37">&#9670;&nbsp;</a></span>HasChunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IPvChunkData::HasChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the buffer has data chunks. </p>
<p>Unlike GetChunkCount, chunks do not need to be parsed or resolved with this method.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the buffer holds data chunks, false if not. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_buffer.html#a49759bffd9f1ee0ccb584b6000afb28e">PvBuffer</a>.</p>

</div>
</div>
<a id="aaf2aa453fdc92066e4a491f8f52dda38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2aa453fdc92066e4a491f8f52dda38">&#9670;&nbsp;</a></span>ResetChunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IPvChunkData::ResetChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="class_pv_buffer.html#aa85ffe3e0c299debda560f22112f98ec" title="Resets the internal chunk state.">PvBuffer::ResetChunks</a>. </p>
<p>Same as <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> equivalent. Provided with this interface for convenience. </p>

<p>Implemented in <a class="el" href="class_pv_buffer.html#aa85ffe3e0c299debda560f22112f98ec">PvBuffer</a>.</p>

</div>
</div>
<a id="a0ea33b069bc01272e029d59c73f3a301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea33b069bc01272e029d59c73f3a301">&#9670;&nbsp;</a></span>SetChunkLayoutID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IPvChunkData::SetChunkLayoutID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aChunkLayoutID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the chunk data layout ID. </p>
<p>See <a class="el" href="class_pv_buffer.html#a67ba6363162024610a5c52c63b4750ec" title="Add chunk data to the buffer.">PvBuffer::AddChunk</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aChunkLayoutID</td><td>Chunk data layout ID.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the chunk data layout ID. </p>

<p>Implemented in <a class="el" href="class_pv_buffer.html#a258bbd9d4acd4ed054dc42ad8b9e71c2">PvBuffer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_chunk_data_8h_source.html">PvChunkData.h</a></li>
<li>PvChunkData.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2024 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
