<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>IPvStreamingChannelSource Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v6.4.0.6670 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_i_pv_streaming_channel_source.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_i_pv_streaming_channel_source-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IPvStreamingChannelSource Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface that is used by <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to query and report information from a streaming source implemented by your application.  
 <a href="class_i_pv_streaming_channel_source.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_pv_soft_device_g_e_v_interfaces_8h_source.html">PvSoftDeviceGEVInterfaces.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a009f9d92de5d8dab161f319be1e1b073"><td class="memItemLeft" align="right" valign="top"><a id="a009f9d92de5d8dab161f319be1e1b073"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a009f9d92de5d8dab161f319be1e1b073">~IPvStreamingChannelSource</a> ()</td></tr>
<tr class="memdesc:a009f9d92de5d8dab161f319be1e1b073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a009f9d92de5d8dab161f319be1e1b073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e48b02b47d569fa6813cdae708366d"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a75e48b02b47d569fa6813cdae708366d">GetWidth</a> () const =0</td></tr>
<tr class="memdesc:a75e48b02b47d569fa6813cdae708366d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image width.  <a href="class_i_pv_streaming_channel_source.html#a75e48b02b47d569fa6813cdae708366d">More...</a><br /></td></tr>
<tr class="separator:a75e48b02b47d569fa6813cdae708366d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e7a77219e025d7dfecf087cb0dcd0f"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a98e7a77219e025d7dfecf087cb0dcd0f">GetHeight</a> () const =0</td></tr>
<tr class="memdesc:a98e7a77219e025d7dfecf087cb0dcd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image height.  <a href="class_i_pv_streaming_channel_source.html#a98e7a77219e025d7dfecf087cb0dcd0f">More...</a><br /></td></tr>
<tr class="separator:a98e7a77219e025d7dfecf087cb0dcd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be122cd1c15190f9e48b2fa9f53f48a"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a1be122cd1c15190f9e48b2fa9f53f48a">GetOffsetX</a> () const =0</td></tr>
<tr class="memdesc:a1be122cd1c15190f9e48b2fa9f53f48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image offset X.  <a href="class_i_pv_streaming_channel_source.html#a1be122cd1c15190f9e48b2fa9f53f48a">More...</a><br /></td></tr>
<tr class="separator:a1be122cd1c15190f9e48b2fa9f53f48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb4f731aa43007400f746d127973f03"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#abcb4f731aa43007400f746d127973f03">GetOffsetY</a> () const =0</td></tr>
<tr class="memdesc:abcb4f731aa43007400f746d127973f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image offset Y.  <a href="class_i_pv_streaming_channel_source.html#abcb4f731aa43007400f746d127973f03">More...</a><br /></td></tr>
<tr class="separator:abcb4f731aa43007400f746d127973f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0288e5a39738308217e6404a5e84cfba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a0288e5a39738308217e6404a5e84cfba">GetPixelType</a> () const =0</td></tr>
<tr class="memdesc:a0288e5a39738308217e6404a5e84cfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current pixel type.  <a href="class_i_pv_streaming_channel_source.html#a0288e5a39738308217e6404a5e84cfba">More...</a><br /></td></tr>
<tr class="separator:a0288e5a39738308217e6404a5e84cfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541f29284aa630980adb8e136f409082"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a541f29284aa630980adb8e136f409082">GetWidthInfo</a> (uint32_t &amp;aMin, uint32_t &amp;aMax, uint32_t &amp;aInc) const =0</td></tr>
<tr class="memdesc:a541f29284aa630980adb8e136f409082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stream channel width attributes.  <a href="class_i_pv_streaming_channel_source.html#a541f29284aa630980adb8e136f409082">More...</a><br /></td></tr>
<tr class="separator:a541f29284aa630980adb8e136f409082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7064bbf89cc93c94f1d38f3266210d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#ac7064bbf89cc93c94f1d38f3266210d7">GetHeightInfo</a> (uint32_t &amp;aMin, uint32_t &amp;aMax, uint32_t &amp;aInc) const =0</td></tr>
<tr class="memdesc:ac7064bbf89cc93c94f1d38f3266210d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stream channel height attributes.  <a href="class_i_pv_streaming_channel_source.html#ac7064bbf89cc93c94f1d38f3266210d7">More...</a><br /></td></tr>
<tr class="separator:ac7064bbf89cc93c94f1d38f3266210d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdea1aa87836d12f8dfc731a7bc2c8be"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#abdea1aa87836d12f8dfc731a7bc2c8be">GetChunksSize</a> () const =0</td></tr>
<tr class="memdesc:abdea1aa87836d12f8dfc731a7bc2c8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stream channel chunk size attributes.  <a href="class_i_pv_streaming_channel_source.html#abdea1aa87836d12f8dfc731a7bc2c8be">More...</a><br /></td></tr>
<tr class="separator:abdea1aa87836d12f8dfc731a7bc2c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acea878109ed0aa518dbb620af0493c"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a2acea878109ed0aa518dbb620af0493c">GetPayloadSize</a> () const =0</td></tr>
<tr class="memdesc:a2acea878109ed0aa518dbb620af0493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream channel payload size in bytes. Return zero to have it inferred from width, height and pixel format.  <a href="class_i_pv_streaming_channel_source.html#a2acea878109ed0aa518dbb620af0493c">More...</a><br /></td></tr>
<tr class="separator:a2acea878109ed0aa518dbb620af0493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9101f68e3fa8d30114bdbb1b4eb4d481"><td class="memItemLeft" align="right" valign="top">virtual PvScanType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a9101f68e3fa8d30114bdbb1b4eb4d481">GetScanType</a> () const =0</td></tr>
<tr class="memdesc:a9101f68e3fa8d30114bdbb1b4eb4d481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scan type that is used by the streaming source.  <a href="class_i_pv_streaming_channel_source.html#a9101f68e3fa8d30114bdbb1b4eb4d481">More...</a><br /></td></tr>
<tr class="separator:a9101f68e3fa8d30114bdbb1b4eb4d481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4b27f1c6ac46d738ea90be800a14e1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#afb4b27f1c6ac46d738ea90be800a14e1">GetChunkModeActive</a> () const =0</td></tr>
<tr class="memdesc:afb4b27f1c6ac46d738ea90be800a14e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the current master chunk mode is active.  <a href="class_i_pv_streaming_channel_source.html#afb4b27f1c6ac46d738ea90be800a14e1">More...</a><br /></td></tr>
<tr class="separator:afb4b27f1c6ac46d738ea90be800a14e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cfdc32bd4ba2ce0fa7b7663e9a682c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#ac1cfdc32bd4ba2ce0fa7b7663e9a682c">GetChunkEnable</a> (uint32_t aChunkID) const =0</td></tr>
<tr class="memdesc:ac1cfdc32bd4ba2ce0fa7b7663e9a682c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current chunk enabled state.  <a href="class_i_pv_streaming_channel_source.html#ac1cfdc32bd4ba2ce0fa7b7663e9a682c">More...</a><br /></td></tr>
<tr class="separator:ac1cfdc32bd4ba2ce0fa7b7663e9a682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c82aa29f3c8beef373155074f657df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#aa7c82aa29f3c8beef373155074f657df">GetSupportedPixelType</a> (int aIndex, <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> &amp;aPixelType) const =0</td></tr>
<tr class="memdesc:aa7c82aa29f3c8beef373155074f657df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains an index of supported pixel types. Used at <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> time to create the GenICam XML of the device.  <a href="class_i_pv_streaming_channel_source.html#aa7c82aa29f3c8beef373155074f657df">More...</a><br /></td></tr>
<tr class="separator:aa7c82aa29f3c8beef373155074f657df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1747831496274d6e0b38c6c78e8491"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a5d1747831496274d6e0b38c6c78e8491">GetSupportedChunk</a> (int aIndex, uint32_t &amp;aID, <a class="el" href="class_pv_string.html">PvString</a> &amp;aName) const =0</td></tr>
<tr class="memdesc:a5d1747831496274d6e0b38c6c78e8491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indexed supported chunk type. Used at <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> time to create the GenICam XML of the device.  <a href="class_i_pv_streaming_channel_source.html#a5d1747831496274d6e0b38c6c78e8491">More...</a><br /></td></tr>
<tr class="separator:a5d1747831496274d6e0b38c6c78e8491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d0aaf4828da15f77fd4e3f221f000f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a44d0aaf4828da15f77fd4e3f221f000f">SetWidth</a> (uint32_t aWidth)=0</td></tr>
<tr class="memdesc:a44d0aaf4828da15f77fd4e3f221f000f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image width.  <a href="class_i_pv_streaming_channel_source.html#a44d0aaf4828da15f77fd4e3f221f000f">More...</a><br /></td></tr>
<tr class="separator:a44d0aaf4828da15f77fd4e3f221f000f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878cb7d39d9f4c7034a95f14947535d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a878cb7d39d9f4c7034a95f14947535d0">SetHeight</a> (uint32_t aHeight)=0</td></tr>
<tr class="memdesc:a878cb7d39d9f4c7034a95f14947535d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image height.  <a href="class_i_pv_streaming_channel_source.html#a878cb7d39d9f4c7034a95f14947535d0">More...</a><br /></td></tr>
<tr class="separator:a878cb7d39d9f4c7034a95f14947535d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4572d298d03100c8dcd4d92de9eee6c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a4572d298d03100c8dcd4d92de9eee6c1">SetOffsetX</a> (uint32_t aOffsetX)=0</td></tr>
<tr class="memdesc:a4572d298d03100c8dcd4d92de9eee6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image offset X.  <a href="class_i_pv_streaming_channel_source.html#a4572d298d03100c8dcd4d92de9eee6c1">More...</a><br /></td></tr>
<tr class="separator:a4572d298d03100c8dcd4d92de9eee6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955f86fae157bb97cf1ad4289b18b52f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a955f86fae157bb97cf1ad4289b18b52f">SetOffsetY</a> (uint32_t aOffsetY)=0</td></tr>
<tr class="memdesc:a955f86fae157bb97cf1ad4289b18b52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image offset Y.  <a href="class_i_pv_streaming_channel_source.html#a955f86fae157bb97cf1ad4289b18b52f">More...</a><br /></td></tr>
<tr class="separator:a955f86fae157bb97cf1ad4289b18b52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d437dc2bebce465562dc36a1287c056"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a7d437dc2bebce465562dc36a1287c056">SetPixelType</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)=0</td></tr>
<tr class="memdesc:a7d437dc2bebce465562dc36a1287c056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image pixel type.  <a href="class_i_pv_streaming_channel_source.html#a7d437dc2bebce465562dc36a1287c056">More...</a><br /></td></tr>
<tr class="separator:a7d437dc2bebce465562dc36a1287c056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69946f8085eccd27ee06bb75b1d55b74"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a69946f8085eccd27ee06bb75b1d55b74">SetChunkModeActive</a> (bool aEnabled)=0</td></tr>
<tr class="memdesc:a69946f8085eccd27ee06bb75b1d55b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the master chunk mode active state.  <a href="class_i_pv_streaming_channel_source.html#a69946f8085eccd27ee06bb75b1d55b74">More...</a><br /></td></tr>
<tr class="separator:a69946f8085eccd27ee06bb75b1d55b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8adf8e1bd0b86e990c8a441b41b5447"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#ad8adf8e1bd0b86e990c8a441b41b5447">SetChunkEnable</a> (uint32_t aChunkID, bool aEnabled)=0</td></tr>
<tr class="memdesc:ad8adf8e1bd0b86e990c8a441b41b5447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the chunk enabled state for a specific chunk type.  <a href="class_i_pv_streaming_channel_source.html#ad8adf8e1bd0b86e990c8a441b41b5447">More...</a><br /></td></tr>
<tr class="separator:ad8adf8e1bd0b86e990c8a441b41b5447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bf48ef40df3b27f5362fa161cc593b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a64bf48ef40df3b27f5362fa161cc593b">OnOpen</a> (const <a class="el" href="class_pv_string.html">PvString</a> &amp;aDestIP, uint16_t aDestPort)=0</td></tr>
<tr class="memdesc:a64bf48ef40df3b27f5362fa161cc593b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> that this streaming channel has been opened.  <a href="class_i_pv_streaming_channel_source.html#a64bf48ef40df3b27f5362fa161cc593b">More...</a><br /></td></tr>
<tr class="separator:a64bf48ef40df3b27f5362fa161cc593b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17eea70aae262021077dce4ecc22013"><td class="memItemLeft" align="right" valign="top"><a id="af17eea70aae262021077dce4ecc22013"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#af17eea70aae262021077dce4ecc22013">OnClose</a> ()=0</td></tr>
<tr class="memdesc:af17eea70aae262021077dce4ecc22013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> that this streaming channel has been closed. <br /></td></tr>
<tr class="separator:af17eea70aae262021077dce4ecc22013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ce2f5067a95b5687906a2bbe79e239"><td class="memItemLeft" align="right" valign="top"><a id="a71ce2f5067a95b5687906a2bbe79e239"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a71ce2f5067a95b5687906a2bbe79e239">OnStreamingStart</a> ()=0</td></tr>
<tr class="memdesc:a71ce2f5067a95b5687906a2bbe79e239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that the GigE Vision controller has requested that the device start streaming on this channel. <br /></td></tr>
<tr class="separator:a71ce2f5067a95b5687906a2bbe79e239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb0d738487d4131aa8898fd209218b9"><td class="memItemLeft" align="right" valign="top"><a id="aadb0d738487d4131aa8898fd209218b9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#aadb0d738487d4131aa8898fd209218b9">OnStreamingStop</a> ()=0</td></tr>
<tr class="memdesc:aadb0d738487d4131aa8898fd209218b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that the GigE Vision controller has requested that the device stop streaming on this channel. <br /></td></tr>
<tr class="separator:aadb0d738487d4131aa8898fd209218b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd95b0fe165ef567dc903ce78f952cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a7bd95b0fe165ef567dc903ce78f952cb">AllocBuffer</a> ()=0</td></tr>
<tr class="memdesc:a7bd95b0fe165ef567dc903ce78f952cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to allocate a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>.  <a href="class_i_pv_streaming_channel_source.html#a7bd95b0fe165ef567dc903ce78f952cb">More...</a><br /></td></tr>
<tr class="separator:a7bd95b0fe165ef567dc903ce78f952cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b95fe82221d67ddfa76e7bdb714d78e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a0b95fe82221d67ddfa76e7bdb714d78e">FreeBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)=0</td></tr>
<tr class="memdesc:a0b95fe82221d67ddfa76e7bdb714d78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to free or release a buffer allocated with AllocBuffer.  <a href="class_i_pv_streaming_channel_source.html#a0b95fe82221d67ddfa76e7bdb714d78e">More...</a><br /></td></tr>
<tr class="separator:a0b95fe82221d67ddfa76e7bdb714d78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b5caefc101c6c43b6a6aafe5ca28d6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#ab3b5caefc101c6c43b6a6aafe5ca28d6">QueueBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)=0</td></tr>
<tr class="memdesc:ab3b5caefc101c6c43b6a6aafe5ca28d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to queue a buffer for acquisition.  <a href="class_i_pv_streaming_channel_source.html#ab3b5caefc101c6c43b6a6aafe5ca28d6">More...</a><br /></td></tr>
<tr class="separator:ab3b5caefc101c6c43b6a6aafe5ca28d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147f8770bee5d78e47780d3ba19dfe6b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a147f8770bee5d78e47780d3ba19dfe6b">PreQueueBufferProc</a> ()</td></tr>
<tr class="separator:a147f8770bee5d78e47780d3ba19dfe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd138aa4e4b471ea13ff8597f3c0d4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a1bd138aa4e4b471ea13ff8597f3c0d4a">PostRetrieveBufferProc</a> ()</td></tr>
<tr class="separator:a1bd138aa4e4b471ea13ff8597f3c0d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d9014976bf5911124fa042d2b0cb7a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a76d9014976bf5911124fa042d2b0cb7a">RetrieveBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffer)=0</td></tr>
<tr class="memdesc:a76d9014976bf5911124fa042d2b0cb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to retrieve a buffer from the streaming source.  <a href="class_i_pv_streaming_channel_source.html#a76d9014976bf5911124fa042d2b0cb7a">More...</a><br /></td></tr>
<tr class="separator:a76d9014976bf5911124fa042d2b0cb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d6d94e883f928107a61b019f15f1bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#ac8d6d94e883f928107a61b019f15f1bf">AbortQueuedBuffers</a> ()=0</td></tr>
<tr class="memdesc:ac8d6d94e883f928107a61b019f15f1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to abort all buffers queued for acquisition.  <a href="class_i_pv_streaming_channel_source.html#ac8d6d94e883f928107a61b019f15f1bf">More...</a><br /></td></tr>
<tr class="separator:ac8d6d94e883f928107a61b019f15f1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1eb6d88bcfc0c3b40f24493ec6df37"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a4d1eb6d88bcfc0c3b40f24493ec6df37">CreateRegisters</a> (<a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *aRegisterMap, <a class="el" href="class_i_pv_register_factory.html">IPvRegisterFactory</a> *aFactory)</td></tr>
<tr class="memdesc:a4d1eb6d88bcfc0c3b40f24493ec6df37"><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, the streaming channel source should create its custom registers if they are needed.  <a href="class_i_pv_streaming_channel_source.html#a4d1eb6d88bcfc0c3b40f24493ec6df37">More...</a><br /></td></tr>
<tr class="separator:a4d1eb6d88bcfc0c3b40f24493ec6df37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53b1fc8526c801f3cf097e7528a21f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#aa53b1fc8526c801f3cf097e7528a21f3">CreateGenApiFeatures</a> (<a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *aRegisterMap, <a class="el" href="class_i_pv_gen_api_factory.html">IPvGenApiFactory</a> *aFactory)</td></tr>
<tr class="memdesc:aa53b1fc8526c801f3cf097e7528a21f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, the streaming channel source should create its custom GenApi parameters if they are needed.  <a href="class_i_pv_streaming_channel_source.html#aa53b1fc8526c801f3cf097e7528a21f3">More...</a><br /></td></tr>
<tr class="separator:aa53b1fc8526c801f3cf097e7528a21f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfb312228bb1cb68a06245294df54eb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#aebfb312228bb1cb68a06245294df54eb">IsPayloadTypeSupported</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType)</td></tr>
<tr class="memdesc:aebfb312228bb1cb68a06245294df54eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, the streaming source has to return whether the specificed payload type is supported or not.  <a href="class_i_pv_streaming_channel_source.html#aebfb312228bb1cb68a06245294df54eb">More...</a><br /></td></tr>
<tr class="separator:aebfb312228bb1cb68a06245294df54eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021da3f3c44e1ae2f4a92674566897c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a021da3f3c44e1ae2f4a92674566897c0">SetMultiPartAllowed</a> (bool aAllowed)</td></tr>
<tr class="memdesc:a021da3f3c44e1ae2f4a92674566897c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the streaming source is allowed or not, but not forced, to transmit multi-part data.  <a href="class_i_pv_streaming_channel_source.html#a021da3f3c44e1ae2f4a92674566897c0">More...</a><br /></td></tr>
<tr class="separator:a021da3f3c44e1ae2f4a92674566897c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072c52233051fabb3f5ca3e9237dc8b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a072c52233051fabb3f5ca3e9237dc8b7">SetLargeLeaderTrailerEnabled</a> (bool aEnabled, uint32_t aMaxMultiPartCount)</td></tr>
<tr class="memdesc:a072c52233051fabb3f5ca3e9237dc8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the streaming source which transmit multi-part data uses large data leader and trailer packets.  <a href="class_i_pv_streaming_channel_source.html#a072c52233051fabb3f5ca3e9237dc8b7">More...</a><br /></td></tr>
<tr class="separator:a072c52233051fabb3f5ca3e9237dc8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aabac21df5f952506eda964976d4b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a01aabac21df5f952506eda964976d4b3">SetTestPayloadFormatMode</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType)</td></tr>
<tr class="memdesc:a01aabac21df5f952506eda964976d4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, the streaming source has to ensure it can stream buffers of the specified payload type.  <a href="class_i_pv_streaming_channel_source.html#a01aabac21df5f952506eda964976d4b3">More...</a><br /></td></tr>
<tr class="separator:a01aabac21df5f952506eda964976d4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface that is used by <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to query and report information from a streaming source implemented by your application. </p>
<p>For the application to provide a streaming source to your software-based GigE Vision Device, inherit one of your classes from <a class="el" href="class_i_pv_streaming_channel_source.html" title="Interface that is used by PvSoftDeviceGEV to query and report information from a streaming source imp...">IPvStreamingChannelSource</a>, implement all of the methods, instantiate an object from your class, and pass a pointer to your class to <a class="el" href="class_pv_soft_device_g_e_v.html#a933f4730b0f2735c89ebfff639829c27" title="Adds a new stream to the PvSoftDeviceGEV.">PvSoftDeviceGEV::AddStream</a>.</p>
<p>The GigE Vision Device will use this interface to query the application about stream capabilities and to report streaming events, such as acquisition start and stop. The GigE Vision Device also uses this interface to manage streaming data.</p>
<p>To properly report the PayloadSize GenApi parameter, your application must provide the GigE Vision Device with the width, height, pixel format, and data chunk size values using the GetWidth, GetHeight, GetPixelFormat, and GetChunksSize methods.</p>
<p>You can hardcode the supported chunk size by returning the required chunk size using GetChunksSize. You could also provide more information about the supported chunk types using GetSupportedChunk. Doing so will allow the GigE Vision Device to properly populate the ChunkSelector of its GenApi interface to let the user decide which chunks it should support. The streaming source should decide whether or not to append a specific chunk type by looking at whether the master chunk active mode is enabled AND that the specific chunk type is enabled.</p>
<p>It is possible to create streaming channel source custom registers and GenApi parameters. See <a class="el" href="class_i_pv_streaming_channel_source.html#aa53b1fc8526c801f3cf097e7528a21f3" title="When called, the streaming channel source should create its custom GenApi parameters if they are need...">IPvStreamingChannelSource::CreateGenApiFeatures</a> and <a class="el" href="class_i_pv_streaming_channel_source.html#a4d1eb6d88bcfc0c3b40f24493ec6df37" title="When called, the streaming channel source should create its custom registers if they are needed.">IPvStreamingChannelSource::CreateRegisters</a> for more information. You should create streaming channel source GenApi feature and registers for source-specific features like deinterlacing, gain, exposure time. Look at <a class="el" href="class_i_pv_soft_device_g_e_v_event_sink.html#aafd4855c64128c26ebd756aa05a04522" title="Notification that the PvSoftDeviceGEV should create its custom registers, if they are needed.">IPvSoftDeviceGEVEventSink::OnCreateCustomRegisters</a> and <a class="el" href="class_i_pv_soft_device_g_e_v_event_sink.html#a1ee4c97ef5f3fe2d24ceef3770481696" title="Notification that the PvSoftDeviceGEV should create its custom GenApi parameters, if they are needed.">IPvSoftDeviceGEVEventSink::OnCreateCustomGenApiFeatures</a> to create device-scope features. Note that chunks and messaging channel GenApi parameters should always be created from <a class="el" href="class_i_pv_soft_device_g_e_v_event_sink.html" title="Interface that is used by PvSoftDeviceGEV to report internal events.">IPvSoftDeviceGEVEventSink</a> and be at the device-scope.</p>
<p>Here is what a typical streaming session would look like when it comes to buffer management:</p><ul>
<li>A <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> object is instantiated by your application</li>
<li>A MySource object that implements the <a class="el" href="class_i_pv_streaming_channel_source.html" title="Interface that is used by PvSoftDeviceGEV to query and report information from a streaming source imp...">IPvStreamingChannelSource</a> interface is instantiated by your application</li>
<li><a class="el" href="class_pv_soft_device_g_e_v.html#a933f4730b0f2735c89ebfff639829c27" title="Adds a new stream to the PvSoftDeviceGEV.">PvSoftDeviceGEV::AddStream</a> is called by your application with a pointer to MySource</li>
<li><a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> is called by your application<ul>
<li><a class="el" href="class_i_pv_streaming_channel_source.html#a7bd95b0fe165ef567dc903ce78f952cb" title="Request by the PvSoftDeviceGEV to allocate a PvBuffer.">AllocBuffer</a> is called to allow your application to allocate streaming buffers until NULL is returned or the maximum number of buffers is reached</li>
<li><a class="el" href="class_i_pv_streaming_channel_source.html#a541f29284aa630980adb8e136f409082" title="Returns the stream channel width attributes.">GetWidthInfo</a>, <a class="el" href="class_i_pv_streaming_channel_source.html#ac7064bbf89cc93c94f1d38f3266210d7" title="Returns the stream channel height attributes.">GetHeightInfo</a>, and <a class="el" href="class_i_pv_streaming_channel_source.html#aa7c82aa29f3c8beef373155074f657df" title="Obtains an index of supported pixel types. Used at PvSoftDeviceGEV::Start time to create the GenICam ...">GetSupportedPixelType</a> are called on MySource to inquire about the image attributes supported by MySource</li>
<li><a class="el" href="class_i_pv_streaming_channel_source.html#a64bf48ef40df3b27f5362fa161cc593b" title="Notification from the PvSoftDeviceGEV that this streaming channel has been opened.">OnOpen</a> is called on MySource when the streaming channel is opened (when a GigE Vision controller connects to your GigE Vision Device)<ul>
<li><a class="el" href="class_i_pv_streaming_channel_source.html#a71ce2f5067a95b5687906a2bbe79e239" title="Notification that the GigE Vision controller has requested that the device start streaming on this ch...">OnStreamingStart</a> is called on MySource to notify the application that streaming is starting (when the GigE Vision controller calls AcquisitionStart)<ul>
<li>Internal acquisition loop run from a GigE Vision Device thread:<ul>
<li>Calls <a class="el" href="class_i_pv_streaming_channel_source.html#ab3b5caefc101c6c43b6a6aafe5ca28d6" title="Request by the PvSoftDeviceGEV to queue a buffer for acquisition.">QueueBuffer</a> on MySource until it fails to provide MySource with buffers to fill with image data</li>
<li>Calls <a class="el" href="class_i_pv_streaming_channel_source.html#a76d9014976bf5911124fa042d2b0cb7a" title="Request by the PvSoftDeviceGEV to retrieve a buffer from the streaming source.">RetrieveBuffer</a> on MySource until it fails to retrieve all MySource filled buffers that are ready for transmission</li>
<li>End of acquisition loop</li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="class_i_pv_streaming_channel_source.html#aadb0d738487d4131aa8898fd209218b9" title="Notification that the GigE Vision controller has requested that the device stop streaming on this cha...">OnStreamingStop</a> is called on MySource to notify the application that streaming is stopping (when the GigE Vision controller calls AcquisitionStop)<ul>
<li><a class="el" href="class_i_pv_streaming_channel_source.html#ac8d6d94e883f928107a61b019f15f1bf" title="Request by the PvSoftDeviceGEV to abort all buffers queued for acquisition.">AbortQueuedBuffers</a> is called on MySource</li>
<li><a class="el" href="class_i_pv_streaming_channel_source.html#a76d9014976bf5911124fa042d2b0cb7a" title="Request by the PvSoftDeviceGEV to retrieve a buffer from the streaming source.">RetrieveBuffer</a> is called on MySource until it fails to retrieve all MySource buffers, whether they were acquired or aborted</li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="class_i_pv_streaming_channel_source.html#af17eea70aae262021077dce4ecc22013" title="Notification from the PvSoftDeviceGEV that this streaming channel has been closed.">OnClose</a> is called on MySource when the streaming channel is closed (when the GigE Vision controller disconnects from the GigE Vision Device)</li>
</ul>
</li>
<li><a class="el" href="class_pv_soft_device_g_e_v.html#accf2d25422086df4c3a993f5cebac5e5" title="Stops the PvSoftDeviceGEV.">PvSoftDeviceGEV::Stop</a> is called explicitly by your application or by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> destructor </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac8d6d94e883f928107a61b019f15f1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d6d94e883f928107a61b019f15f1bf">&#9670;&nbsp;</a></span>AbortQueuedBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IPvStreamingChannelSource::AbortQueuedBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to abort all buffers queued for acquisition. </p>
<p>This method should block until acquisition has been aborted or canceled for all buffers provided by QueueBuffer that have not yet been retrieved with RetrievedBuffer.</p>
<p>When this method returns, it should be possible to call RetrieveBuffer for all aborted buffers. </p>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a16629a202f89f098209c11f98a3d25e7">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a7bd95b0fe165ef567dc903ce78f952cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd95b0fe165ef567dc903ce78f952cb">&#9670;&nbsp;</a></span>AllocBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_buffer.html">PvBuffer</a>* IPvStreamingChannelSource::AllocBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to allocate a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>. </p>
<p>On initialization, the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will call this method, asking the application to allocate buffers that will be used for image acquisition and transmission. The application should return buffers until it has reached the desired number of buffers it wants to use for streaming and then return NULL.</p>
<p>The more buffers you use, the more buffers you can have queued in the application for image acquisition and the more buffers you can leave in the transmission output queue for packet resend. The downside of using more buffers is increased memory usage.</p>
<p>Buffers returned on AllocBuffer calls should be unique: you should not return the same buffer more than once.</p>
<p>A maximum of 64 buffers can be used by one streaming channel of the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a>. If your application does not return NULL on the 64th buffer, AllocBuffer will not be called a 64th time.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a new <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> that can be used by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a>'s acquisition manager. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a044333e2f8dfec6eff15fceb049d4f38">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="aa53b1fc8526c801f3cf097e7528a21f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53b1fc8526c801f3cf097e7528a21f3">&#9670;&nbsp;</a></span>CreateGenApiFeatures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IPvStreamingChannelSource::CreateGenApiFeatures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *&#160;</td>
          <td class="paramname"><em>aRegisterMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv_gen_api_factory.html">IPvGenApiFactory</a> *&#160;</td>
          <td class="paramname"><em>aFactory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When called, the streaming channel source should create its custom GenApi parameters if they are needed. </p>
<p>Create GenApi features from this callback if the feature is associated with a streaming channel source. For global-device, non streaming channel source features use <a class="el" href="class_i_pv_soft_device_g_e_v_event_sink.html#a1ee4c97ef5f3fe2d24ceef3770481696" title="Notification that the PvSoftDeviceGEV should create its custom GenApi parameters, if they are needed.">IPvSoftDeviceGEVEventSink::OnCreateCustomGenApiFeatures</a> instead.</p>
<p>In a multi-source application, GenApi features created by a streaming channel source will only be available when the SourceSelector is set to the streaming channel source that created the feature.</p>
<p>If FeatureXYX is created by Source0 and Source1 but not by Source2, the feature will only be available in the GenApi interface when SourceSelector is set to Source0 or Source1. </p><pre class="fragment">- MySource0 has Feature0, Feature1, Feature2
- MySource1 has Feature0, Feature3, Feature4
- In a GenApi browser with SourceSelector=Source0, Feature0, Feature1, Feature2 are available. Feature3 and Feature4 are disabled.
- In a GenApi browser with SourceSelector=Source1, Feature0, Feature3, Feature4 are available. Feature1 and Feature2 are disabled.
</pre><p> If integers with the same name are created for more than one source but with source-specific minimum, maximum and increment attributes, these attributes will be handled by GenICam SwissKnife operators in the GenICam XML so they are dynamically adjusted based on the value of SourceSelector. The same applies to float maximum and minimum. </p><pre class="fragment">- MyInteger is created for Source0 with min:0 max:100 increment:4
- MyInteger is created for Source1 with min:4 max:200 increment:1
- In a GenApi browser, MyInteger will report min:0 max:100 increment:4 with Source0 is selected
- In a GenApi browser, MyInteger will report min:4 max:200 increment:1 with Source1 is selected
</pre><p> If enumerations with the same name are created for more than one source but with different enum entries, they will be added to the GenICam XML file of the device in way that the correct enum entries should be available for the enum features based on the current SourceSelector value: </p><pre class="fragment">- MyEnum is created with EE0, EE1, EE2 for Source0
- MyEnum is created with EE0, EE3, EE4 for Source1
- In a GenApi browser with SourceSelector=Source0, you would see EE0, EE1, EE2 in the combo box
- In a GenApi browser with SourceSelector=Source1, you would see EE0, EE3, EE4 in the combo box
</pre><p> Creating features of the same name but different types is not supported. Attempting to do so should have the <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> call failing with an appropriate error description.</p>
<p>GenApi features created for a streaming channel source should use registers unique to this streaming channel source. If you have a source class MySource that creates registers and features, it should still create unique register having their own unique addresses. They should however use the same parameter name. The GenApi parameters created by MySource should use the right register for the source instance. The complexity of overlapping per-source feature name is handled by <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> when creating the GenICam XML file from <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a>. </p><pre class="fragment">- For Source0:
    - MySource creates MySourceRegister0 @ 0x20000000 + 0x1000 * source index + 0
    - MySource creates MySourceParameter named "MySourceParameter" for Source0 using MySourceRegister0
- For Source1:
    - MySource creates MySourceRegister1 @ 0x20000000 + 0x1000 * source index + 4
    - MySource creates MySourceParameter named "MySourceParameter" for Source1 using MySourceRegister1
</pre><p> The exception to this rule is selectors: if selectors are created at the streaming source level they must all use the same register, sharing the same register address.</p>
<p>Custom source-specific GenApi features creation occurs AFTER custom source-specific registers creation, inside the <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRegisterMap</td><td>The register map of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFactory</td><td>GenApi factory used to create the new GenApi features. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_pv_streaming_channel_source_trigger.html#a877af6a22b84ddf36ebc3bb050f4936e">PvStreamingChannelSourceTrigger</a>, and <a class="el" href="class_pv_streaming_channel_source_default.html#ae43951777d20df72f768423d543a7aea">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a4d1eb6d88bcfc0c3b40f24493ec6df37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1eb6d88bcfc0c3b40f24493ec6df37">&#9670;&nbsp;</a></span>CreateRegisters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IPvStreamingChannelSource::CreateRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *&#160;</td>
          <td class="paramname"><em>aRegisterMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv_register_factory.html">IPvRegisterFactory</a> *&#160;</td>
          <td class="paramname"><em>aFactory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When called, the streaming channel source should create its custom registers if they are needed. </p>
<p>To create source-specific custom registers in your application, implement the CreateRegisters method of the <a class="el" href="class_i_pv_streaming_channel_source.html" title="Interface that is used by PvSoftDeviceGEV to query and report information from a streaming source imp...">IPvStreamingChannelSource</a> interface.</p>
<p>Custom source-specific register creation occurs BEFORE custom source-specific GenApi features creation, inside the <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> call.</p>
<p>If more than one streaming channel source is created from the same class, you must make sure its registers are still unique: RegisterXYZ in Source0 and Source1 should not have the same address. It is also recommended to assign them unique names like RegisterXYZ0 and RegisterXYZ1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRegisterMap</td><td>The register map of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFactory</td><td>Register factory used to create the new registers. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_pv_streaming_channel_source_trigger.html#af408c53d2bd2c04141fe994fe6a06e4c">PvStreamingChannelSourceTrigger</a>, and <a class="el" href="class_pv_streaming_channel_source_default.html#a8e33958fd4f5327ef7e88d1588d17134">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a0b95fe82221d67ddfa76e7bdb714d78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b95fe82221d67ddfa76e7bdb714d78e">&#9670;&nbsp;</a></span>FreeBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IPvStreamingChannelSource::FreeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td>
          <td class="paramname"><em>aBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to free or release a buffer allocated with AllocBuffer. </p>
<p>You should not delete or free any <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> provided by the AllocBuffer method. FreeBuffer will be called for each buffer created with AllocBuffer when <a class="el" href="class_pv_soft_device_g_e_v.html#accf2d25422086df4c3a993f5cebac5e5" title="Stops the PvSoftDeviceGEV.">PvSoftDeviceGEV::Stop</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffer</td><td>Buffer to free. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a37ef37733a9a3a5c5a5fc8af67614411">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="ac1cfdc32bd4ba2ce0fa7b7663e9a682c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cfdc32bd4ba2ce0fa7b7663e9a682c">&#9670;&nbsp;</a></span>GetChunkEnable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IPvStreamingChannelSource::GetChunkEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aChunkID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current chunk enabled state. </p>
<p>The application must implement this method and return the current chunk enabled state for the specified chunk ID. The streaming source should maintain an enabled/disabled state for each chunk type that it supports.</p>
<p>The application should append the chunk represented by the specified chunk ID if it is enabled and if the master chunk mode (see <a class="el" href="class_i_pv_streaming_channel_source.html#afb4b27f1c6ac46d738ea90be800a14e1" title="Indicates whether the current master chunk mode is active.">GetChunkModeActive</a>) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aChunkID</td><td>Chunk ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the chunk specified by aChunk ID is enabled for this streaming source. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a9bef1c3d7bedad5bc6ccad1255133b7e">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="afb4b27f1c6ac46d738ea90be800a14e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4b27f1c6ac46d738ea90be800a14e1">&#9670;&nbsp;</a></span>GetChunkModeActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IPvStreamingChannelSource::GetChunkModeActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the current master chunk mode is active. </p>
<p>The application must implement this method and return the current master chunk mode state. Return false as a hardcoded value if chunks are not supported by the streaming source.</p>
<dl class="section return"><dt>Returns</dt><dd>True if chunk mode is enabled for this streaming source. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a74de031d7095986ed0a27dffba6079e3">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="abdea1aa87836d12f8dfc731a7bc2c8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdea1aa87836d12f8dfc731a7bc2c8be">&#9670;&nbsp;</a></span>GetChunksSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t IPvStreamingChannelSource::GetChunksSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the stream channel chunk size attributes. </p>
<p>When using data chunks, it is important to report the chunk data size when queried through this method.</p>
<p>The chunk data size needs to be taken into account when reporting the PayloadSize GenICam parameter to the GigE Vision controller, so it can properly allocate its buffer for streaming without forced buffer re-allocation.</p>
<p>The size reported must for each chunk adds 4 bytes for the chunk ID and another 4 bytes for the chunk length fields. If you have a chunk that is 64 bytes long and it is your only data chunk, you need to report 64 + 4 + 4 (72 bytes) when GetChunksSize is called.</p>
<dl class="section return"><dt>Returns</dt><dd>Chunk data size as currently configured. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a54cfef902c082f5ff890d9f40dd708c8">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a98e7a77219e025d7dfecf087cb0dcd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e7a77219e025d7dfecf087cb0dcd0f">&#9670;&nbsp;</a></span>GetHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t IPvStreamingChannelSource::GetHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current image height. </p>
<p>Your application must implement this method and return the current image height when invoked.</p>
<dl class="section return"><dt>Returns</dt><dd>Current image height. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a296f588bf019422e7207d7d19f659a60">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="ac7064bbf89cc93c94f1d38f3266210d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7064bbf89cc93c94f1d38f3266210d7">&#9670;&nbsp;</a></span>GetHeightInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IPvStreamingChannelSource::GetHeightInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aInc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stream channel height attributes. </p>
<p>When using the GigE Vision Device as a transmitter, the Height parameter is automatically added to the device's GenICam XML file. This method is used to query the minimum, maximum, and increment attributes for the Height parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aMin</td><td>Height minimum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aMax</td><td>Height maximum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aInc</td><td>Height increment. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#ab9d00526a08bae38c584ecdc708b2a91">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a1be122cd1c15190f9e48b2fa9f53f48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be122cd1c15190f9e48b2fa9f53f48a">&#9670;&nbsp;</a></span>GetOffsetX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t IPvStreamingChannelSource::GetOffsetX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current image offset X. </p>
<p>Your application must implement this method and return the current image offset X when invoked.</p>
<dl class="section return"><dt>Returns</dt><dd>Current image offset X. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a4b7f6c0a8cf998578d47833f795ec9da">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="abcb4f731aa43007400f746d127973f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb4f731aa43007400f746d127973f03">&#9670;&nbsp;</a></span>GetOffsetY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t IPvStreamingChannelSource::GetOffsetY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current image offset Y. </p>
<p>Your application must implement this method and return the current image offset Y when invoked.</p>
<dl class="section return"><dt>Returns</dt><dd>Current image offset Y. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#aaf5c27a707218299385a234ec672efd4">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a2acea878109ed0aa518dbb620af0493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acea878109ed0aa518dbb620af0493c">&#9670;&nbsp;</a></span>GetPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t IPvStreamingChannelSource::GetPayloadSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream channel payload size in bytes. Return zero to have it inferred from width, height and pixel format. </p>
<p>If not using image streams (raw data, multi-part, etc.) use implement the GetPayloadSize method and return the payload size for the current streaming channel source configuration. If GetPayloadSize returns 0 the payload size will be inferred from the width, height, pixel format and data chunk size.</p>
<p>When using multi-part, return the sum of the maximum size of all parts plus data chunk.</p>
<p>When payload size is not zero, the payload size value is simply used as provided. Nothing is added to it, not even data chunk size.</p>
<dl class="section return"><dt>Returns</dt><dd>Payload size to use or 0. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a01d4ecc06a0498940b7128aebd5e658a">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a0288e5a39738308217e6404a5e84cfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0288e5a39738308217e6404a5e84cfba">&#9670;&nbsp;</a></span>GetPixelType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> IPvStreamingChannelSource::GetPixelType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current pixel type. </p>
<p>Your application must implement this method and return the current image pixel type when invoked.</p>
<dl class="section return"><dt>Returns</dt><dd>Current pixel type. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a51dfc6c257c578d69b87100663ceb456">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a9101f68e3fa8d30114bdbb1b4eb4d481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9101f68e3fa8d30114bdbb1b4eb4d481">&#9670;&nbsp;</a></span>GetScanType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PvScanType IPvStreamingChannelSource::GetScanType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the scan type that is used by the streaming source. </p>
<p>Return PvScanTypeArea if your image source is areascan or PvScanTypeLine if your image source is linescan.</p>
<dl class="section return"><dt>Returns</dt><dd>Scan type of the streaming source. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#ab71879e84222ed755be1b34196a7c9ac">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a5d1747831496274d6e0b38c6c78e8491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1747831496274d6e0b38c6c78e8491">&#9670;&nbsp;</a></span>GetSupportedChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::GetSupportedChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pv_string.html">PvString</a> &amp;&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the indexed supported chunk type. Used at <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> time to create the GenICam XML of the device. </p>
<p>This method is used by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to query the application about the supported chunk types for this streaming channel.</p>
<p>The <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will query the application through this stream interface for all supported chunk types. It will start at index 0 and then increase until something other than <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> is returned.</p>
<p>The information retrieved through this method is used to populate the chunk selector, allowing the GigE Vision controller to enable or disable each chunk type individually.</p>
<p>If the application supports ChunkSample (ID 0x4001) and ChunkHistogram (ID 0x4002) it needs to handle request to GetSupportedChunk as follows:</p><ul>
<li>GetSupportedChunk( 0 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a>, aID = 0x4001, aName = "ChunkSample"</li>
<li>GetSupportedChunk( 1 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a>, aID = 0x4002, aName = "ChunkHistogram"</li>
<li>GetSupportedChunk( 2 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Index of the chunk type to return. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aID</td><td>ID of the chunk type requested by aIndex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aName</td><td>Name of the chunk type requested by aIndex. Should always use the "Chunk" prefix for GenICam SFNC compliance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if aIndex represents a valid index and aPixelType has been set.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> or any other error code if aIndex is not valid. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a94811fb695c7193ccf96de0aa5241419">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="aa7c82aa29f3c8beef373155074f657df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c82aa29f3c8beef373155074f657df">&#9670;&nbsp;</a></span>GetSupportedPixelType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::GetSupportedPixelType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> &amp;&#160;</td>
          <td class="paramname"><em>aPixelType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains an index of supported pixel types. Used at <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> time to create the GenICam XML of the device. </p>
<p>This method is used by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to query the application about the supported pixel types for the streaming channel.</p>
<p>The <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will query the application using this stream interface for all supported pixel types. It will start at index 0 and then increase until something other than <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> is returned.</p>
<p>If the application supports Mono8, BayerRG8, and RGBa8 it needs to handle the request to GetSupportedPixelType, as follows:</p><ul>
<li>GetSupportedPixelType( 0 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a>, PvPixelMono8</li>
<li>GetSupportedPixelType( 1 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a>, PvPixelBayerRG8</li>
<li>GetSupportedPixelType( 2 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a>, PvPixelRGBa8</li>
<li>GetSupportedPixelType( 3 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Index of the pixel type to return. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aPixelType</td><td>PvPixelType requested by aIndex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if aIndex represents a valid index and aPixelType has been set.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> or any other error code if aIndex is not valid. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a1c3aa9f372b02d3841f318e3307e0b10">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a75e48b02b47d569fa6813cdae708366d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e48b02b47d569fa6813cdae708366d">&#9670;&nbsp;</a></span>GetWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t IPvStreamingChannelSource::GetWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current image width. </p>
<p>Your application must implement this method and return the current image width when invoked.</p>
<dl class="section return"><dt>Returns</dt><dd>Current image width. </dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a640c6e2f9442c7e4e7c8e41bad997839">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a541f29284aa630980adb8e136f409082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541f29284aa630980adb8e136f409082">&#9670;&nbsp;</a></span>GetWidthInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IPvStreamingChannelSource::GetWidthInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aInc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stream channel width attributes. </p>
<p>When using the GigE Vision Device as a transmitter, the Width parameter is automatically added to the device's GenICam XML file. This method is used to query the minimum, maximum, and increment attributes for the Width parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aMin</td><td>Width minimum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aMax</td><td>Width maximum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aInc</td><td>Width increment. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#aebcff358601af0d7a102667906a9a57b">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="aebfb312228bb1cb68a06245294df54eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfb312228bb1cb68a06245294df54eb">&#9670;&nbsp;</a></span>IsPayloadTypeSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IPvStreamingChannelSource::IsPayloadTypeSupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&#160;</td>
          <td class="paramname"><em>aPayloadType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When called, the streaming source has to return whether the specificed payload type is supported or not. </p>
<p>Return true if the streaming source exlusively or non-exclusively can stream buffers of the specified payload type. A default implementation is provided for this method which returns false.</p>
<p>This method must be implemented and returning true for aPayloadType being equal to PvPayloadTypeMultiPart when multi-part is supported by the streaming source.</p>
<p>See <a class="el" href="class_i_pv_streaming_channel_source.html#a01aabac21df5f952506eda964976d4b3" title="When called, the streaming source has to ensure it can stream buffers of the specified payload type.">SetTestPayloadFormatMode</a> and <a class="el" href="class_i_pv_streaming_channel_source.html#a021da3f3c44e1ae2f4a92674566897c0" title="Sets whether the streaming source is allowed or not, but not forced, to transmit multi-part data.">SetMultiPartAllowed</a> for more information on propertly supporting the multi-part payload type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aPayloadType</td><td>[in] The payload type for which support is queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the payload type is supported, false if not. </dd></dl>

<p>Reimplemented in <a class="el" href="class_pv_streaming_channel_source_default.html#aad994685d489751052217b91639544db">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a64bf48ef40df3b27f5362fa161cc593b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bf48ef40df3b27f5362fa161cc593b">&#9670;&nbsp;</a></span>OnOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IPvStreamingChannelSource::OnOpen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pv_string.html">PvString</a> &amp;&#160;</td>
          <td class="paramname"><em>aDestIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aDestPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notification from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> that this streaming channel has been opened. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aDestIP</td><td>IP address of the stream destination as a string in the "192.168.138.115" format (SCDA). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aDestPort</td><td>UDP port of the stream destination (SCP). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a19d497d3e7dff403c99ddea060070c87">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a1bd138aa4e4b471ea13ff8597f3c0d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd138aa4e4b471ea13ff8597f3c0d4a">&#9670;&nbsp;</a></span>PostRetrieveBufferProc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IPvStreamingChannelSource::PostRetrieveBufferProc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an advanced feature used mostly internally. For expert users only. It is higly recommended to not override but use the default implementation. </p>

<p>Reimplemented in <a class="el" href="class_pv_streaming_channel_source_trigger.html#a7b13db31fa1c6321b72ec1cf62ffce09">PvStreamingChannelSourceTrigger</a>.</p>

</div>
</div>
<a id="a147f8770bee5d78e47780d3ba19dfe6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147f8770bee5d78e47780d3ba19dfe6b">&#9670;&nbsp;</a></span>PreQueueBufferProc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IPvStreamingChannelSource::PreQueueBufferProc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an advanced feature used mostly internally. For expert users only. It is higly recommended to not override but use the default implementation.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the processing loop can proceed with queueing/retrieving next buffer. </dd></dl>

<p>Reimplemented in <a class="el" href="class_pv_streaming_channel_source_trigger.html#acca0ce45493ec5c0ad37fd09c3e8636f">PvStreamingChannelSourceTrigger</a>.</p>

</div>
</div>
<a id="ab3b5caefc101c6c43b6a6aafe5ca28d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b5caefc101c6c43b6a6aafe5ca28d6">&#9670;&nbsp;</a></span>QueueBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::QueueBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td>
          <td class="paramname"><em>aBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to queue a buffer for acquisition. </p>
<p>If the application can accept the buffer and queue it for image acquisition, it returns success. If the acquisition queue or pipeline is full, return a <a class="el" href="class_pv_result.html" title="Result information.">PvResult</a> error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffer</td><td>Buffer to queue for image acquisition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> to accept the buffer.</li>
<li>Any error code to refuse the buffer. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a76d9014976bf5911124fa042d2b0cb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d9014976bf5911124fa042d2b0cb7a">&#9670;&nbsp;</a></span>RetrieveBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::RetrieveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> **&#160;</td>
          <td class="paramname"><em>aBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to retrieve a buffer from the streaming source. </p>
<p>During acquisition, buffers retrieved with this method will contain valid image data and are going to be transmitted using the GVSP protocol. This method is also used to retrieve queued buffers after calling AbortQueuedBuffers.</p>
<p>If no image is immediately available, we recommend that you wait until an image is available in this method to allow the acquisition thread to wait efficiently for a new image. If getting a new image can take a long time, your application should wait small chunks of time (10, 20, or 50 ms) to prevent deadlocking the acquisition thread and to allow the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to stop streaming gracefully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffer</td><td>A pointer to a pointer to a buffer: set to a pointer to the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> being retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if a buffer has been retrieved.</li>
<li>Any error code if there are currently no buffers available. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad8adf8e1bd0b86e990c8a441b41b5447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8adf8e1bd0b86e990c8a441b41b5447">&#9670;&nbsp;</a></span>SetChunkEnable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::SetChunkEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aChunkID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the chunk enabled state for a specific chunk type. </p>
<p>The streaming source should append a specific chunk type to its streaming data when both the <a class="el" href="class_i_pv_streaming_channel_source.html#afb4b27f1c6ac46d738ea90be800a14e1" title="Indicates whether the current master chunk mode is active.">GetChunkModeActive</a> (master chunk mode) and <a class="el" href="class_i_pv_streaming_channel_source.html#ac1cfdc32bd4ba2ce0fa7b7663e9a682c" title="Returns the current chunk enabled state.">GetChunkEnable</a> for this specific chunk type are true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aChunkID</td><td>Chunk ID of the chunk type to enable or disable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aEnabled</td><td>True to enable the chunk type, false to disable it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> to accept the new setting.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new setting. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a6eade8a2b75a510f1be6486c9d07c677">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a69946f8085eccd27ee06bb75b1d55b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69946f8085eccd27ee06bb75b1d55b74">&#9670;&nbsp;</a></span>SetChunkModeActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::SetChunkModeActive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the master chunk mode active state. </p>
<p>The streaming source should append a specific chunk type to its streaming data when both the <a class="el" href="class_i_pv_streaming_channel_source.html#afb4b27f1c6ac46d738ea90be800a14e1" title="Indicates whether the current master chunk mode is active.">GetChunkModeActive</a> (master chunk mode) and <a class="el" href="class_i_pv_streaming_channel_source.html#ac1cfdc32bd4ba2ce0fa7b7663e9a682c" title="Returns the current chunk enabled state.">GetChunkEnable</a> for this specific chunk type are true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEnabled</td><td>True to enable chunk mode for this streaming channel, false to disable it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> to accept the new setting.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new setting. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#ac81d11f179930d0b364f13921d4f0204">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a878cb7d39d9f4c7034a95f14947535d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878cb7d39d9f4c7034a95f14947535d0">&#9670;&nbsp;</a></span>SetHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::SetHeight </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aHeight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image height. </p>
<p>The <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will call SetHeight when the Height GenApi parameter or the underlying register is changed by the GigE Vision controller.</p>
<p>To accept the new height, return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> and update your streaming code to use the new height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aHeight</td><td>New image height.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> when accepting the new height.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new height. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#abaf06b8d153b80910d7b7dc9139aaca5">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a072c52233051fabb3f5ca3e9237dc8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072c52233051fabb3f5ca3e9237dc8b7">&#9670;&nbsp;</a></span>SetLargeLeaderTrailerEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IPvStreamingChannelSource::SetLargeLeaderTrailerEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMaxMultiPartCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the streaming source which transmit multi-part data uses large data leader and trailer packets. </p>
<p>Streaming sources using multi-part data transmission without large data leader and trailer enabled only supports up to 10 multi-parts due to the data leader and trailer packet size limitation. Large data leader and data trailer packets can be enabled by configuring the GevSCCFGLargeLeaderTrailerEnabled GenApi parameter to allow more than 10 parts. The large leader and trailer packet size is then set to the value allowed by the SCPSx register.</p>
<p>The GevSCCFGLargeLeaderTrailerEnabled GenApi parameter is automatically added to the GenICam XML file of a <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> device when <a class="el" href="class_i_pv_streaming_channel_source.html#aebfb312228bb1cb68a06245294df54eb" title="When called, the streaming source has to return whether the specificed payload type is supported or n...">IsPayloadTypeSupported</a> returns true when prompted with PvPayloadTypeMultiPart. This parameter will only be available when GevSCCFGMultiPartEnabled is set to true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aEnabled</td><td>[in] True if Large Leader Trailer is enabled. </td></tr>
    <tr><td class="paramname">aMaxMultiPartCount</td><td>[in] The number of maximum allowed Multi parts calculated from the value allowed by the SCPSx register. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_pv_streaming_channel_source_default.html#af358c744ce052bca6548fa066eea8c82">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a021da3f3c44e1ae2f4a92674566897c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021da3f3c44e1ae2f4a92674566897c0">&#9670;&nbsp;</a></span>SetMultiPartAllowed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IPvStreamingChannelSource::SetMultiPartAllowed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aAllowed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the streaming source is allowed or not, but not forced, to transmit multi-part data. </p>
<p>Streaming sources supporting multi-part data transmission must support non-multi-part streaming by default. All devices starting in a mode where multi-part is not allowed. The GigE Vision controller must unlock the multi-part capability of a GVSP streaming channel using either the SCCx and SCCFGx bootstrap registers or the GevSCCFGMultiPartEnabled GenApi parameter.</p>
<p>The GevSCCFGMultiPartEnabled GenApi parameter is automatically added to the GenICam XML file of a <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> device when <a class="el" href="class_i_pv_streaming_channel_source.html#aebfb312228bb1cb68a06245294df54eb" title="When called, the streaming source has to return whether the specificed payload type is supported or n...">IsPayloadTypeSupported</a> returns true when prompted with PvPayloadTypeMultiPart.</p>
<p>See <a class="el" href="class_i_pv_streaming_channel_source.html#aebfb312228bb1cb68a06245294df54eb" title="When called, the streaming source has to return whether the specificed payload type is supported or n...">IsPayloadTypeSupported</a> and <a class="el" href="class_i_pv_streaming_channel_source.html#a01aabac21df5f952506eda964976d4b3" title="When called, the streaming source has to ensure it can stream buffers of the specified payload type.">SetTestPayloadFormatMode</a> for more information on propertly supporting the multi-part payload type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aAllowed</td><td>[in] True if multi-part is allowed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a880d3269ee3dfd9827306382cfcc6790">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a4572d298d03100c8dcd4d92de9eee6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4572d298d03100c8dcd4d92de9eee6c1">&#9670;&nbsp;</a></span>SetOffsetX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::SetOffsetX </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aOffsetX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image offset X. </p>
<p>To accept the new offset X, return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> and update your streaming code to use the new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aOffsetX</td><td>New image offset X.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> when accepting the new value.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new value. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a01d3bb9c6434e169041e2cbc52305635">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a955f86fae157bb97cf1ad4289b18b52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955f86fae157bb97cf1ad4289b18b52f">&#9670;&nbsp;</a></span>SetOffsetY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::SetOffsetY </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aOffsetY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image offset Y. </p>
<p>To accept the new offset Y, return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> and update your streaming code to use the new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aOffsetY</td><td>New image offset Y.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> when accepting the new value.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new value. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#aa16d968e0486c7e9e6b8ada39462e560">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a7d437dc2bebce465562dc36a1287c056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d437dc2bebce465562dc36a1287c056">&#9670;&nbsp;</a></span>SetPixelType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::SetPixelType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image pixel type. </p>
<p>The <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will call SetPixelType when the PixelType GenApi parameter or the underlying register is changed by the GigE Vision controller.</p>
<p>To accept the new pixel type, return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> and update your streaming code to use the new pixel type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>New image pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> when accepting the new pixel type.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new pixel type. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#a268d9e3ebc7a676f87eb5c6ade9c6477">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a01aabac21df5f952506eda964976d4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01aabac21df5f952506eda964976d4b3">&#9670;&nbsp;</a></span>SetTestPayloadFormatMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::SetTestPayloadFormatMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&#160;</td>
          <td class="paramname"><em>aPayloadType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When called, the streaming source has to ensure it can stream buffers of the specified payload type. </p>
<p>The GigE Vision Validation Framework has to be able to set the device in a functional streaming mode for some payload types (currently only multi-part with more to come) in order to properly validate the device.</p>
<p>This method must be implemented and for aPayloadType being PvPayloadTypeMultiPart when multi-part is supported by the streaming source. The streaming source must be able to configure itself in a mode where it will be able to stream data for certification with the GigE Vision Validation Framework.</p>
<p>Of course, this method will only be called on a streaming source for payload type that have been reported as supported with <a class="el" href="class_i_pv_streaming_channel_source.html#aebfb312228bb1cb68a06245294df54eb" title="When called, the streaming source has to return whether the specificed payload type is supported or n...">IsPayloadTypeSupported</a>.</p>
<p>How to prepare your multi-source device source for GigE Vision Validation Framework validation: </p><pre class="fragment">- Implement #IsPayloadTypeSupported and return true if aPayloadType is PvPayloadTypeMultiPart.
- Implement #SetTestPayloadFormatMode
    - If aPayloadType is PvPayloadTypeMultiPart 
        - Setup your streaming source for autonomous multi-part streaming if needed
        - Return #PvResult::Code::OK
    - Else if aPayloadType is PvPayloadTypeNone
        - Disable test mode, go back to streaming source normal operation mode
        - Return #PvResult::Code::OK
    - Else
        - Return any #PvResult error code like #PvResult::Code::NOT_SUPPORTED
</pre><p> See the SoftDeviceGEVMultiPart C++ sample for an example of how to implement this method, <a class="el" href="class_i_pv_streaming_channel_source.html#a021da3f3c44e1ae2f4a92674566897c0" title="Sets whether the streaming source is allowed or not, but not forced, to transmit multi-part data.">SetMultiPartAllowed</a>, and <a class="el" href="class_i_pv_streaming_channel_source.html#aebfb312228bb1cb68a06245294df54eb" title="When called, the streaming source has to return whether the specificed payload type is supported or n...">IsPayloadTypeSupported</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPayloadType</td><td>Payload type to prepare test for. PvPayloadTypeNone sets the device back in normal operation mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li>Any error code can be returned to indicate failure. </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="class_pv_streaming_channel_source_default.html#aaa80d4b9887a22cf82f523be975e7bb4">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<a id="a44d0aaf4828da15f77fd4e3f221f000f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d0aaf4828da15f77fd4e3f221f000f">&#9670;&nbsp;</a></span>SetWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pv_result.html">PvResult</a> IPvStreamingChannelSource::SetWidth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image width. </p>
<p>The <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will call SetWidth when the Width GenApi parameter or the underlying register is changed by the GigE Vision controller.</p>
<p>To accept the new width, return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> and update your streaming code to use the new width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aWidth</td><td>New image width.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> when accepting the new width.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new width. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_pv_streaming_channel_source_default.html#ab76a34be2080f3f8990b032968457f97">PvStreamingChannelSourceDefault</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_pv_soft_device_g_e_v_interfaces_8h_source.html">PvSoftDeviceGEVInterfaces.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2024 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
