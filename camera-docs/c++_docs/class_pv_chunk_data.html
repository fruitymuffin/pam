<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvChunkData Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v6.4.0.6670 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_pv_chunk_data.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_pv_chunk_data-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvChunkData Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Raw data interface to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>.  
 <a href="class_pv_chunk_data.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_pv_chunk_data_8h_source.html">PvChunkData.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aade5dcc4a91532e896a594a14b207512"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#aade5dcc4a91532e896a594a14b207512">GetChunkDataPayloadLength</a> () const =0</td></tr>
<tr class="memdesc:aade5dcc4a91532e896a594a14b207512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chunk data payload length specified in the trailer information of this block.  <a href="class_pv_chunk_data.html#aade5dcc4a91532e896a594a14b207512">More...</a><br /></td></tr>
<tr class="separator:aade5dcc4a91532e896a594a14b207512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa502f1ca427bb7b8c94e971461f7681d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#aa502f1ca427bb7b8c94e971461f7681d">Alloc</a> (uint32_t aMaximumChunkLength)=0</td></tr>
<tr class="memdesc:aa502f1ca427bb7b8c94e971461f7681d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for this <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a>.  <a href="class_pv_chunk_data.html#aa502f1ca427bb7b8c94e971461f7681d">More...</a><br /></td></tr>
<tr class="separator:aa502f1ca427bb7b8c94e971461f7681d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0556fed13922b66374ae9d55047fd020"><td class="memItemLeft" align="right" valign="top"><a id="a0556fed13922b66374ae9d55047fd020"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#a0556fed13922b66374ae9d55047fd020">Free</a> ()=0</td></tr>
<tr class="memdesc:a0556fed13922b66374ae9d55047fd020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees (de-allocates) the buffer's internal memory. <br /></td></tr>
<tr class="separator:a0556fed13922b66374ae9d55047fd020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183c5ba0c5d80edf313143d8f8ef42f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#a183c5ba0c5d80edf313143d8f8ef42f3">Attach</a> (void *aRawBuffer, uint32_t aMaximumChunkLength)=0</td></tr>
<tr class="memdesc:a183c5ba0c5d80edf313143d8f8ef42f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach this <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> to an external memory buffer.  <a href="class_pv_chunk_data.html#a183c5ba0c5d80edf313143d8f8ef42f3">More...</a><br /></td></tr>
<tr class="separator:a183c5ba0c5d80edf313143d8f8ef42f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc06c1e83b2b3163d2a0671dc00a634f"><td class="memItemLeft" align="right" valign="top">virtual uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_chunk_data.html#afc06c1e83b2b3163d2a0671dc00a634f">Detach</a> ()=0</td></tr>
<tr class="memdesc:afc06c1e83b2b3163d2a0671dc00a634f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attached memory buffer.  <a href="class_pv_chunk_data.html#afc06c1e83b2b3163d2a0671dc00a634f">More...</a><br /></td></tr>
<tr class="separator:afc06c1e83b2b3163d2a0671dc00a634f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_pv_chunk_data"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_pv_chunk_data')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_pv_chunk_data.html">IPvChunkData</a></td></tr>
<tr class="memitem:aaf2aa453fdc92066e4a491f8f52dda38 inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#aaf2aa453fdc92066e4a491f8f52dda38">ResetChunks</a> ()=0</td></tr>
<tr class="memdesc:aaf2aa453fdc92066e4a491f8f52dda38 inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#aa85ffe3e0c299debda560f22112f98ec" title="Resets the internal chunk state.">PvBuffer::ResetChunks</a>.  <a href="class_i_pv_chunk_data.html#aaf2aa453fdc92066e4a491f8f52dda38">More...</a><br /></td></tr>
<tr class="separator:aaf2aa453fdc92066e4a491f8f52dda38 inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f91bdf279a04768a20f6666323d82 inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#a925f91bdf279a04768a20f6666323d82">AddChunk</a> (uint32_t aID, const uint8_t *aData, uint32_t aLength)=0</td></tr>
<tr class="memdesc:a925f91bdf279a04768a20f6666323d82 inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a67ba6363162024610a5c52c63b4750ec" title="Add chunk data to the buffer.">PvBuffer::AddChunk</a>.  <a href="class_i_pv_chunk_data.html#a925f91bdf279a04768a20f6666323d82">More...</a><br /></td></tr>
<tr class="separator:a925f91bdf279a04768a20f6666323d82 inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea33b069bc01272e029d59c73f3a301 inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#a0ea33b069bc01272e029d59c73f3a301">SetChunkLayoutID</a> (uint32_t aChunkLayoutID)=0</td></tr>
<tr class="memdesc:a0ea33b069bc01272e029d59c73f3a301 inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the chunk data layout ID.  <a href="class_i_pv_chunk_data.html#a0ea33b069bc01272e029d59c73f3a301">More...</a><br /></td></tr>
<tr class="separator:a0ea33b069bc01272e029d59c73f3a301 inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d7d3b304116a7bfa1a16d89b973c37 inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#af6d7d3b304116a7bfa1a16d89b973c37">HasChunks</a> () const =0</td></tr>
<tr class="memdesc:af6d7d3b304116a7bfa1a16d89b973c37 inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the buffer has data chunks.  <a href="class_i_pv_chunk_data.html#af6d7d3b304116a7bfa1a16d89b973c37">More...</a><br /></td></tr>
<tr class="separator:af6d7d3b304116a7bfa1a16d89b973c37 inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e09c02b3cb16cbab36a93b25c2bbe5 inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#ad1e09c02b3cb16cbab36a93b25c2bbe5">GetChunkCount</a> ()=0</td></tr>
<tr class="memdesc:ad1e09c02b3cb16cbab36a93b25c2bbe5 inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#ac8586236cfce7b6149a0aeba5530616c" title="Returns the number of data chunks in the PvBuffer.">PvBuffer::GetChunkCount</a>.  <a href="class_i_pv_chunk_data.html#ad1e09c02b3cb16cbab36a93b25c2bbe5">More...</a><br /></td></tr>
<tr class="separator:ad1e09c02b3cb16cbab36a93b25c2bbe5 inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcfcc0ab9ccdff61a55739356e8e5ad inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#adbcfcc0ab9ccdff61a55739356e8e5ad">GetChunkIDByIndex</a> (uint32_t aIndex, uint32_t &amp;aID)=0</td></tr>
<tr class="memdesc:adbcfcc0ab9ccdff61a55739356e8e5ad inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a8377362f7f1f734dc2c013d280a5937a" title="Returns the ID of a chunk based on its index.">PvBuffer::GetChunkIDByIndex</a>.  <a href="class_i_pv_chunk_data.html#adbcfcc0ab9ccdff61a55739356e8e5ad">More...</a><br /></td></tr>
<tr class="separator:adbcfcc0ab9ccdff61a55739356e8e5ad inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2019db32a8ae41a6709b3bb050be23 inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#a6a2019db32a8ae41a6709b3bb050be23">GetChunkSizeByIndex</a> (uint32_t aIndex)=0</td></tr>
<tr class="memdesc:a6a2019db32a8ae41a6709b3bb050be23 inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a7235900e888c98c167c41db82ac54ac6" title="Returns the size in bytes of the data chunk at zero-based aIndex.">PvBuffer::GetChunkSizeByIndex</a>.  <a href="class_i_pv_chunk_data.html#a6a2019db32a8ae41a6709b3bb050be23">More...</a><br /></td></tr>
<tr class="separator:a6a2019db32a8ae41a6709b3bb050be23 inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50a5624a81cd3ceca82f9e6c798c89e inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#aa50a5624a81cd3ceca82f9e6c798c89e">GetChunkSizeByID</a> (uint32_t aID)=0</td></tr>
<tr class="memdesc:aa50a5624a81cd3ceca82f9e6c798c89e inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#ae96371f3d9f3728cd17ecf663b9af7ec" title="Returns the size in bytes of the data chunk identified by aID.">PvBuffer::GetChunkSizeByID</a>.  <a href="class_i_pv_chunk_data.html#aa50a5624a81cd3ceca82f9e6c798c89e">More...</a><br /></td></tr>
<tr class="separator:aa50a5624a81cd3ceca82f9e6c798c89e inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e159b890b58b5dfa3ce44c5c92cacbe inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#a6e159b890b58b5dfa3ce44c5c92cacbe">GetChunkRawDataByIndex</a> (uint32_t aIndex)=0</td></tr>
<tr class="memdesc:a6e159b890b58b5dfa3ce44c5c92cacbe inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#afffd2ac9e5755b95263be72b331e5176" title="Returns a const pointer to the data chunk at zero-based aIndex.">PvBuffer::GetChunkRawDataByIndex</a>.  <a href="class_i_pv_chunk_data.html#a6e159b890b58b5dfa3ce44c5c92cacbe">More...</a><br /></td></tr>
<tr class="separator:a6e159b890b58b5dfa3ce44c5c92cacbe inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac016035ce32928e7ec56ea72d8513fa inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#aac016035ce32928e7ec56ea72d8513fa">GetChunkRawDataByID</a> (uint32_t aID)=0</td></tr>
<tr class="memdesc:aac016035ce32928e7ec56ea72d8513fa inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="class_pv_buffer.html#a1a00dd94c912ff14e487debf9599f7ae" title="Returns a const pointer to the data chunk with its ID matching aID.">PvBuffer::GetChunkRawDataByID</a>.  <a href="class_i_pv_chunk_data.html#aac016035ce32928e7ec56ea72d8513fa">More...</a><br /></td></tr>
<tr class="separator:aac016035ce32928e7ec56ea72d8513fa inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5907bd3acebd3b00e920861b4e6184f inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#ac5907bd3acebd3b00e920861b4e6184f">GetChunkLayoutID</a> ()=0</td></tr>
<tr class="memdesc:ac5907bd3acebd3b00e920861b4e6184f inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chunk data layout ID.  <a href="class_i_pv_chunk_data.html#ac5907bd3acebd3b00e920861b4e6184f">More...</a><br /></td></tr>
<tr class="separator:ac5907bd3acebd3b00e920861b4e6184f inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40c6ecf3525a265319b30b8a385c2c6 inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#ae40c6ecf3525a265319b30b8a385c2c6">GetChunkDataSize</a> () const =0</td></tr>
<tr class="memdesc:ae40c6ecf3525a265319b30b8a385c2c6 inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current chunk data size.  <a href="class_i_pv_chunk_data.html#ae40c6ecf3525a265319b30b8a385c2c6">More...</a><br /></td></tr>
<tr class="separator:ae40c6ecf3525a265319b30b8a385c2c6 inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9a7830547d36777fe6e8a4884aaf0f inherit pub_methods_class_i_pv_chunk_data"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_chunk_data.html#aab9a7830547d36777fe6e8a4884aaf0f">GetChunkDataCapacity</a> () const =0</td></tr>
<tr class="memdesc:aab9a7830547d36777fe6e8a4884aaf0f inherit pub_methods_class_i_pv_chunk_data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current chunk data capacity.  <a href="class_i_pv_chunk_data.html#aab9a7830547d36777fe6e8a4884aaf0f">More...</a><br /></td></tr>
<tr class="separator:aab9a7830547d36777fe6e8a4884aaf0f inherit pub_methods_class_i_pv_chunk_data"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Raw data interface to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>. </p>
<p>A <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> represents a generic buffer with no specific payload type. If the payload type is chunk data, the user can obtain a pointer to a <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> buffer interface through <a class="el" href="class_pv_buffer.html#a1223464a644a765f10a387a4576298bb" title="Returns the PvChunkData interface to the buffer.">PvBuffer::GetChunkData</a>.</p>
<p>This <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> exists.</p>
<p>To use in a receiver context, retrieve <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> from <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter.">PvStream</a> or <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter.">PvPipeline</a> and when <a class="el" href="class_pv_buffer.html#a0da48cd0feb9f44fa354e30cd06ec748" title="Returns the payload type currently used by the buffer.">PvBuffer::GetPayloadType</a> is PvPayloadChunkData use <a class="el" href="class_pv_buffer.html#a1223464a644a765f10a387a4576298bb" title="Returns the PvChunkData interface to the buffer.">PvBuffer::GetChunkData</a> to retrieve a pointer to this interface. Use the various chunk methods in this class to access the chunk data by ID or index or alternatively attach the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> to the GenApi interface of the transmitter with <a class="el" href="class_pv_gen_parameter_array.html#ab3cbd1ab39d7d2bd8796ef501f88e86b" title="Attaches a payload containing data chunks to a GenICam node map.">PvGenParameterArray::AttachDataChunks</a> to access the chunk data using GenApi.</p>
<p>To use in a transmitter context, create a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>, set its payload type to PvPayloadChunkData with SetPayloadType, use <a class="el" href="class_pv_buffer.html#a1223464a644a765f10a387a4576298bb" title="Returns the PvChunkData interface to the buffer.">PvBuffer::GetChunkData</a> to retrieve a point to this interface, use <a class="el" href="class_pv_chunk_data.html#aa502f1ca427bb7b8c94e971461f7681d" title="Allocates memory for this PvChunkData.">PvChunkData::Alloc</a> to allocate enough memory for all chunks and their headers (64 bytes per chunk for the headers) and then add chunks to the buffer using <a class="el" href="class_i_pv_chunk_data.html#a925f91bdf279a04768a20f6666323d82" title="See PvBuffer::AddChunk.">PvChunkData::AddChunk</a>. Use <a class="el" href="class_pv_transmitter_g_e_v.html" title="Class for transmitting blocks using the GigE Vision streaming protocol.">PvTransmitterGEV</a> to transmit the buffer. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa502f1ca427bb7b8c94e971461f7681d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa502f1ca427bb7b8c94e971461f7681d">&#9670;&nbsp;</a></span>Alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvChunkData::Alloc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMaximumChunkLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for this <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a>. </p>
<p>Allocs a <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> of specific payload length. No extra data can or need to be priovisioned for chunks as the whole payload is made of chunks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aMaximumChunkLength</td><td>Maximum size in bytes to store chunk data (must include extra 64 bits for each chunk header).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cac194e39fb420655ac75525f53714bc2c">PvResult::Code::NOT_ENOUGH_MEMORY</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a183c5ba0c5d80edf313143d8f8ef42f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183c5ba0c5d80edf313143d8f8ef42f3">&#9670;&nbsp;</a></span>Attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvChunkData::Attach </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aRawBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMaximumChunkLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach this <a class="el" href="class_pv_chunk_data.html" title="Raw data interface to a PvBuffer.">PvChunkData</a> to an external memory buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRawBuffer</td><td>A pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aMaximumChunkLength</td><td>Attached buffer size: chunk length sum + 64 bits for each chunk header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afc06c1e83b2b3163d2a0671dc00a634f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc06c1e83b2b3163d2a0671dc00a634f">&#9670;&nbsp;</a></span>Detach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * PvChunkData::Detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases an attached memory buffer. </p>
<p>Does nothing other then resetting the memory buffer pointer to NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's location in memory. </dd></dl>

</div>
</div>
<a id="aade5dcc4a91532e896a594a14b207512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade5dcc4a91532e896a594a14b207512">&#9670;&nbsp;</a></span>GetChunkDataPayloadLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvChunkData::GetChunkDataPayloadLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the chunk data payload length specified in the trailer information of this block. </p>
<dl class="section return"><dt>Returns</dt><dd>The payload length specified in the trailer information of this block. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_chunk_data_8h_source.html">PvChunkData.h</a></li>
<li>PvChunkData.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2024 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
