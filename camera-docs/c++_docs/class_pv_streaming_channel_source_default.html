<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvStreamingChannelSourceDefault Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v6.4.0.6670 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_pv_streaming_channel_source_default.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_pv_streaming_channel_source_default-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvStreamingChannelSourceDefault Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A default implementation for the IPvStreamingSourceChannelSource interface.  
 <a href="class_pv_streaming_channel_source_default.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_pv_streaming_channel_source_default_8h_source.html">PvStreamingChannelSourceDefault.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6030d2133913e6bef717fdd4fb59cc4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a6030d2133913e6bef717fdd4fb59cc4f">PvStreamingChannelSourceDefault</a> (uint32_t aWidth=640, uint32_t aHeight=480, <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType=<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9a6801cb7bf7663796c860aa5e9c712e82">PvPixelMono8</a>, size_t aBufferCount=16)</td></tr>
<tr class="memdesc:a6030d2133913e6bef717fdd4fb59cc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_pv_streaming_channel_source_default.html#a6030d2133913e6bef717fdd4fb59cc4f">More...</a><br /></td></tr>
<tr class="separator:a6030d2133913e6bef717fdd4fb59cc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5948c0dde5e69fb0f882346f6b907e"><td class="memItemLeft" align="right" valign="top"><a id="a8d5948c0dde5e69fb0f882346f6b907e"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a8d5948c0dde5e69fb0f882346f6b907e">~PvStreamingChannelSourceDefault</a> ()</td></tr>
<tr class="memdesc:a8d5948c0dde5e69fb0f882346f6b907e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a8d5948c0dde5e69fb0f882346f6b907e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640c6e2f9442c7e4e7c8e41bad997839"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a640c6e2f9442c7e4e7c8e41bad997839">GetWidth</a> () const</td></tr>
<tr class="memdesc:a640c6e2f9442c7e4e7c8e41bad997839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image width.  <a href="class_pv_streaming_channel_source_default.html#a640c6e2f9442c7e4e7c8e41bad997839">More...</a><br /></td></tr>
<tr class="separator:a640c6e2f9442c7e4e7c8e41bad997839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296f588bf019422e7207d7d19f659a60"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a296f588bf019422e7207d7d19f659a60">GetHeight</a> () const</td></tr>
<tr class="memdesc:a296f588bf019422e7207d7d19f659a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image height.  <a href="class_pv_streaming_channel_source_default.html#a296f588bf019422e7207d7d19f659a60">More...</a><br /></td></tr>
<tr class="separator:a296f588bf019422e7207d7d19f659a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7f6c0a8cf998578d47833f795ec9da"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a4b7f6c0a8cf998578d47833f795ec9da">GetOffsetX</a> () const</td></tr>
<tr class="memdesc:a4b7f6c0a8cf998578d47833f795ec9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image offset X.  <a href="class_pv_streaming_channel_source_default.html#a4b7f6c0a8cf998578d47833f795ec9da">More...</a><br /></td></tr>
<tr class="separator:a4b7f6c0a8cf998578d47833f795ec9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5c27a707218299385a234ec672efd4"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#aaf5c27a707218299385a234ec672efd4">GetOffsetY</a> () const</td></tr>
<tr class="memdesc:aaf5c27a707218299385a234ec672efd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current image offset Y.  <a href="class_pv_streaming_channel_source_default.html#aaf5c27a707218299385a234ec672efd4">More...</a><br /></td></tr>
<tr class="separator:aaf5c27a707218299385a234ec672efd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dfc6c257c578d69b87100663ceb456"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a51dfc6c257c578d69b87100663ceb456">GetPixelType</a> () const</td></tr>
<tr class="memdesc:a51dfc6c257c578d69b87100663ceb456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current pixel type.  <a href="class_pv_streaming_channel_source_default.html#a51dfc6c257c578d69b87100663ceb456">More...</a><br /></td></tr>
<tr class="separator:a51dfc6c257c578d69b87100663ceb456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcff358601af0d7a102667906a9a57b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#aebcff358601af0d7a102667906a9a57b">GetWidthInfo</a> (uint32_t &amp;aMin, uint32_t &amp;aMax, uint32_t &amp;aInc) const</td></tr>
<tr class="memdesc:aebcff358601af0d7a102667906a9a57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stream channel width attributes.  <a href="class_pv_streaming_channel_source_default.html#aebcff358601af0d7a102667906a9a57b">More...</a><br /></td></tr>
<tr class="separator:aebcff358601af0d7a102667906a9a57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d00526a08bae38c584ecdc708b2a91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#ab9d00526a08bae38c584ecdc708b2a91">GetHeightInfo</a> (uint32_t &amp;aMin, uint32_t &amp;aMax, uint32_t &amp;aInc) const</td></tr>
<tr class="memdesc:ab9d00526a08bae38c584ecdc708b2a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stream channel height attributes.  <a href="class_pv_streaming_channel_source_default.html#ab9d00526a08bae38c584ecdc708b2a91">More...</a><br /></td></tr>
<tr class="separator:ab9d00526a08bae38c584ecdc708b2a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cfef902c082f5ff890d9f40dd708c8"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a54cfef902c082f5ff890d9f40dd708c8">GetChunksSize</a> () const</td></tr>
<tr class="memdesc:a54cfef902c082f5ff890d9f40dd708c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stream channel chunk size attributes.  <a href="class_pv_streaming_channel_source_default.html#a54cfef902c082f5ff890d9f40dd708c8">More...</a><br /></td></tr>
<tr class="separator:a54cfef902c082f5ff890d9f40dd708c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d4ecc06a0498940b7128aebd5e658a"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a01d4ecc06a0498940b7128aebd5e658a">GetPayloadSize</a> () const</td></tr>
<tr class="memdesc:a01d4ecc06a0498940b7128aebd5e658a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream channel payload size in bytes. Return zero to have it inferred from width, height and pixel format.  <a href="class_pv_streaming_channel_source_default.html#a01d4ecc06a0498940b7128aebd5e658a">More...</a><br /></td></tr>
<tr class="separator:a01d4ecc06a0498940b7128aebd5e658a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71879e84222ed755be1b34196a7c9ac"><td class="memItemLeft" align="right" valign="top">virtual PvScanType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#ab71879e84222ed755be1b34196a7c9ac">GetScanType</a> () const</td></tr>
<tr class="memdesc:ab71879e84222ed755be1b34196a7c9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scan type that is used by the streaming source.  <a href="class_pv_streaming_channel_source_default.html#ab71879e84222ed755be1b34196a7c9ac">More...</a><br /></td></tr>
<tr class="separator:ab71879e84222ed755be1b34196a7c9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74de031d7095986ed0a27dffba6079e3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a74de031d7095986ed0a27dffba6079e3">GetChunkModeActive</a> () const</td></tr>
<tr class="memdesc:a74de031d7095986ed0a27dffba6079e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the current master chunk mode is active.  <a href="class_pv_streaming_channel_source_default.html#a74de031d7095986ed0a27dffba6079e3">More...</a><br /></td></tr>
<tr class="separator:a74de031d7095986ed0a27dffba6079e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bef1c3d7bedad5bc6ccad1255133b7e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a9bef1c3d7bedad5bc6ccad1255133b7e">GetChunkEnable</a> (uint32_t aChunkID) const</td></tr>
<tr class="memdesc:a9bef1c3d7bedad5bc6ccad1255133b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current chunk enabled state.  <a href="class_pv_streaming_channel_source_default.html#a9bef1c3d7bedad5bc6ccad1255133b7e">More...</a><br /></td></tr>
<tr class="separator:a9bef1c3d7bedad5bc6ccad1255133b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3aa9f372b02d3841f318e3307e0b10"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a1c3aa9f372b02d3841f318e3307e0b10">GetSupportedPixelType</a> (int aIndex, <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> &amp;aPixelType) const</td></tr>
<tr class="memdesc:a1c3aa9f372b02d3841f318e3307e0b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains an index of supported pixel types. Used at <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> time to create the GenICam XML of the device.  <a href="class_pv_streaming_channel_source_default.html#a1c3aa9f372b02d3841f318e3307e0b10">More...</a><br /></td></tr>
<tr class="separator:a1c3aa9f372b02d3841f318e3307e0b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94811fb695c7193ccf96de0aa5241419"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a94811fb695c7193ccf96de0aa5241419">GetSupportedChunk</a> (int aIndex, uint32_t &amp;aID, <a class="el" href="class_pv_string.html">PvString</a> &amp;aName) const</td></tr>
<tr class="memdesc:a94811fb695c7193ccf96de0aa5241419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indexed supported chunk type. Used at <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> time to create the GenICam XML of the device.  <a href="class_pv_streaming_channel_source_default.html#a94811fb695c7193ccf96de0aa5241419">More...</a><br /></td></tr>
<tr class="separator:a94811fb695c7193ccf96de0aa5241419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76a34be2080f3f8990b032968457f97"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#ab76a34be2080f3f8990b032968457f97">SetWidth</a> (uint32_t aWidth)</td></tr>
<tr class="memdesc:ab76a34be2080f3f8990b032968457f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image width.  <a href="class_pv_streaming_channel_source_default.html#ab76a34be2080f3f8990b032968457f97">More...</a><br /></td></tr>
<tr class="separator:ab76a34be2080f3f8990b032968457f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf06b8d153b80910d7b7dc9139aaca5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#abaf06b8d153b80910d7b7dc9139aaca5">SetHeight</a> (uint32_t aHeight)</td></tr>
<tr class="memdesc:abaf06b8d153b80910d7b7dc9139aaca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image height.  <a href="class_pv_streaming_channel_source_default.html#abaf06b8d153b80910d7b7dc9139aaca5">More...</a><br /></td></tr>
<tr class="separator:abaf06b8d153b80910d7b7dc9139aaca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d3bb9c6434e169041e2cbc52305635"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a01d3bb9c6434e169041e2cbc52305635">SetOffsetX</a> (uint32_t aOffsetX)</td></tr>
<tr class="memdesc:a01d3bb9c6434e169041e2cbc52305635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image offset X.  <a href="class_pv_streaming_channel_source_default.html#a01d3bb9c6434e169041e2cbc52305635">More...</a><br /></td></tr>
<tr class="separator:a01d3bb9c6434e169041e2cbc52305635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16d968e0486c7e9e6b8ada39462e560"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#aa16d968e0486c7e9e6b8ada39462e560">SetOffsetY</a> (uint32_t aOffsetY)</td></tr>
<tr class="memdesc:aa16d968e0486c7e9e6b8ada39462e560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image offset Y.  <a href="class_pv_streaming_channel_source_default.html#aa16d968e0486c7e9e6b8ada39462e560">More...</a><br /></td></tr>
<tr class="separator:aa16d968e0486c7e9e6b8ada39462e560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268d9e3ebc7a676f87eb5c6ade9c6477"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a268d9e3ebc7a676f87eb5c6ade9c6477">SetPixelType</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)</td></tr>
<tr class="memdesc:a268d9e3ebc7a676f87eb5c6ade9c6477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image pixel type.  <a href="class_pv_streaming_channel_source_default.html#a268d9e3ebc7a676f87eb5c6ade9c6477">More...</a><br /></td></tr>
<tr class="separator:a268d9e3ebc7a676f87eb5c6ade9c6477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81d11f179930d0b364f13921d4f0204"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#ac81d11f179930d0b364f13921d4f0204">SetChunkModeActive</a> (bool aEnabled)</td></tr>
<tr class="memdesc:ac81d11f179930d0b364f13921d4f0204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the master chunk mode active state.  <a href="class_pv_streaming_channel_source_default.html#ac81d11f179930d0b364f13921d4f0204">More...</a><br /></td></tr>
<tr class="separator:ac81d11f179930d0b364f13921d4f0204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eade8a2b75a510f1be6486c9d07c677"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a6eade8a2b75a510f1be6486c9d07c677">SetChunkEnable</a> (uint32_t aChunkID, bool aEnabled)</td></tr>
<tr class="memdesc:a6eade8a2b75a510f1be6486c9d07c677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the chunk enabled state for a specific chunk type.  <a href="class_pv_streaming_channel_source_default.html#a6eade8a2b75a510f1be6486c9d07c677">More...</a><br /></td></tr>
<tr class="separator:a6eade8a2b75a510f1be6486c9d07c677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d497d3e7dff403c99ddea060070c87"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a19d497d3e7dff403c99ddea060070c87">OnOpen</a> (const <a class="el" href="class_pv_string.html">PvString</a> &amp;aDestIP, uint16_t aDestPort)</td></tr>
<tr class="memdesc:a19d497d3e7dff403c99ddea060070c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> that this streaming channel has been opened.  <a href="class_pv_streaming_channel_source_default.html#a19d497d3e7dff403c99ddea060070c87">More...</a><br /></td></tr>
<tr class="separator:a19d497d3e7dff403c99ddea060070c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f51c8cd22771ac2c4da06e7af737fe"><td class="memItemLeft" align="right" valign="top"><a id="ae9f51c8cd22771ac2c4da06e7af737fe"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#ae9f51c8cd22771ac2c4da06e7af737fe">OnClose</a> ()</td></tr>
<tr class="memdesc:ae9f51c8cd22771ac2c4da06e7af737fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> that this streaming channel has been closed. <br /></td></tr>
<tr class="separator:ae9f51c8cd22771ac2c4da06e7af737fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077db6dd583eafcc1d9ede211cece09b"><td class="memItemLeft" align="right" valign="top"><a id="a077db6dd583eafcc1d9ede211cece09b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a077db6dd583eafcc1d9ede211cece09b">OnStreamingStart</a> ()</td></tr>
<tr class="memdesc:a077db6dd583eafcc1d9ede211cece09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that the GigE Vision controller has requested that the device start streaming on this channel. <br /></td></tr>
<tr class="separator:a077db6dd583eafcc1d9ede211cece09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba783dac1c496b8ef5e003abfef117f"><td class="memItemLeft" align="right" valign="top"><a id="a7ba783dac1c496b8ef5e003abfef117f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a7ba783dac1c496b8ef5e003abfef117f">OnStreamingStop</a> ()</td></tr>
<tr class="memdesc:a7ba783dac1c496b8ef5e003abfef117f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that the GigE Vision controller has requested that the device stop streaming on this channel. <br /></td></tr>
<tr class="separator:a7ba783dac1c496b8ef5e003abfef117f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044333e2f8dfec6eff15fceb049d4f38"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a044333e2f8dfec6eff15fceb049d4f38">AllocBuffer</a> ()</td></tr>
<tr class="memdesc:a044333e2f8dfec6eff15fceb049d4f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to allocate a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>.  <a href="class_pv_streaming_channel_source_default.html#a044333e2f8dfec6eff15fceb049d4f38">More...</a><br /></td></tr>
<tr class="separator:a044333e2f8dfec6eff15fceb049d4f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ef37733a9a3a5c5a5fc8af67614411"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a37ef37733a9a3a5c5a5fc8af67614411">FreeBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)</td></tr>
<tr class="memdesc:a37ef37733a9a3a5c5a5fc8af67614411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to free or release a buffer allocated with AllocBuffer.  <a href="class_pv_streaming_channel_source_default.html#a37ef37733a9a3a5c5a5fc8af67614411">More...</a><br /></td></tr>
<tr class="separator:a37ef37733a9a3a5c5a5fc8af67614411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16629a202f89f098209c11f98a3d25e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a16629a202f89f098209c11f98a3d25e7">AbortQueuedBuffers</a> ()</td></tr>
<tr class="memdesc:a16629a202f89f098209c11f98a3d25e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to abort all buffers queued for acquisition.  <a href="class_pv_streaming_channel_source_default.html#a16629a202f89f098209c11f98a3d25e7">More...</a><br /></td></tr>
<tr class="separator:a16629a202f89f098209c11f98a3d25e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e33958fd4f5327ef7e88d1588d17134"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a8e33958fd4f5327ef7e88d1588d17134">CreateRegisters</a> (<a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *aRegisterMap, <a class="el" href="class_i_pv_register_factory.html">IPvRegisterFactory</a> *aFactory)</td></tr>
<tr class="memdesc:a8e33958fd4f5327ef7e88d1588d17134"><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, the streaming channel source should create its custom registers if they are needed.  <a href="class_pv_streaming_channel_source_default.html#a8e33958fd4f5327ef7e88d1588d17134">More...</a><br /></td></tr>
<tr class="separator:a8e33958fd4f5327ef7e88d1588d17134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43951777d20df72f768423d543a7aea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#ae43951777d20df72f768423d543a7aea">CreateGenApiFeatures</a> (<a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *aRegisterMap, <a class="el" href="class_i_pv_gen_api_factory.html">IPvGenApiFactory</a> *aFactory)</td></tr>
<tr class="memdesc:ae43951777d20df72f768423d543a7aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, the streaming channel source should create its custom GenApi parameters if they are needed.  <a href="class_pv_streaming_channel_source_default.html#ae43951777d20df72f768423d543a7aea">More...</a><br /></td></tr>
<tr class="separator:ae43951777d20df72f768423d543a7aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad994685d489751052217b91639544db"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#aad994685d489751052217b91639544db">IsPayloadTypeSupported</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType)</td></tr>
<tr class="memdesc:aad994685d489751052217b91639544db"><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, the streaming source has to return whether the specificed payload type is supported or not.  <a href="class_pv_streaming_channel_source_default.html#aad994685d489751052217b91639544db">More...</a><br /></td></tr>
<tr class="separator:aad994685d489751052217b91639544db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880d3269ee3dfd9827306382cfcc6790"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#a880d3269ee3dfd9827306382cfcc6790">SetMultiPartAllowed</a> (bool aAllowed)</td></tr>
<tr class="memdesc:a880d3269ee3dfd9827306382cfcc6790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the streaming source is allowed or not, but not forced, to transmit multi-part data.  <a href="class_pv_streaming_channel_source_default.html#a880d3269ee3dfd9827306382cfcc6790">More...</a><br /></td></tr>
<tr class="separator:a880d3269ee3dfd9827306382cfcc6790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af358c744ce052bca6548fa066eea8c82"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#af358c744ce052bca6548fa066eea8c82">SetLargeLeaderTrailerEnabled</a> (bool aEnabled, uint32_t aMaxMultiPartCount)</td></tr>
<tr class="memdesc:af358c744ce052bca6548fa066eea8c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the streaming source which transmit multi-part data uses large data leader and trailer packets.  <a href="class_pv_streaming_channel_source_default.html#af358c744ce052bca6548fa066eea8c82">More...</a><br /></td></tr>
<tr class="separator:af358c744ce052bca6548fa066eea8c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa80d4b9887a22cf82f523be975e7bb4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_streaming_channel_source_default.html#aaa80d4b9887a22cf82f523be975e7bb4">SetTestPayloadFormatMode</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType)</td></tr>
<tr class="memdesc:aaa80d4b9887a22cf82f523be975e7bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">When called, the streaming source has to ensure it can stream buffers of the specified payload type.  <a href="class_pv_streaming_channel_source_default.html#aaa80d4b9887a22cf82f523be975e7bb4">More...</a><br /></td></tr>
<tr class="separator:aaa80d4b9887a22cf82f523be975e7bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_pv_streaming_channel_source"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_pv_streaming_channel_source')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_pv_streaming_channel_source.html">IPvStreamingChannelSource</a></td></tr>
<tr class="memitem:a009f9d92de5d8dab161f319be1e1b073 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top"><a id="a009f9d92de5d8dab161f319be1e1b073"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a009f9d92de5d8dab161f319be1e1b073">~IPvStreamingChannelSource</a> ()</td></tr>
<tr class="memdesc:a009f9d92de5d8dab161f319be1e1b073 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a009f9d92de5d8dab161f319be1e1b073 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b5caefc101c6c43b6a6aafe5ca28d6 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#ab3b5caefc101c6c43b6a6aafe5ca28d6">QueueBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)=0</td></tr>
<tr class="memdesc:ab3b5caefc101c6c43b6a6aafe5ca28d6 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to queue a buffer for acquisition.  <a href="class_i_pv_streaming_channel_source.html#ab3b5caefc101c6c43b6a6aafe5ca28d6">More...</a><br /></td></tr>
<tr class="separator:ab3b5caefc101c6c43b6a6aafe5ca28d6 inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147f8770bee5d78e47780d3ba19dfe6b inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a147f8770bee5d78e47780d3ba19dfe6b">PreQueueBufferProc</a> ()</td></tr>
<tr class="separator:a147f8770bee5d78e47780d3ba19dfe6b inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd138aa4e4b471ea13ff8597f3c0d4a inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a1bd138aa4e4b471ea13ff8597f3c0d4a">PostRetrieveBufferProc</a> ()</td></tr>
<tr class="separator:a1bd138aa4e4b471ea13ff8597f3c0d4a inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d9014976bf5911124fa042d2b0cb7a inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_streaming_channel_source.html#a76d9014976bf5911124fa042d2b0cb7a">RetrieveBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffer)=0</td></tr>
<tr class="memdesc:a76d9014976bf5911124fa042d2b0cb7a inherit pub_methods_class_i_pv_streaming_channel_source"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to retrieve a buffer from the streaming source.  <a href="class_i_pv_streaming_channel_source.html#a76d9014976bf5911124fa042d2b0cb7a">More...</a><br /></td></tr>
<tr class="separator:a76d9014976bf5911124fa042d2b0cb7a inherit pub_methods_class_i_pv_streaming_channel_source"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A default implementation for the IPvStreamingSourceChannelSource interface. </p>
<p>While it is recommended to build your Software GigE Vision Device application with the IPvStreamingSourceChannelSource interface, simple use cases could benefit from using <a class="el" href="class_pv_streaming_channel_source_default.html" title="A default implementation for the IPvStreamingSourceChannelSource interface.">PvStreamingChannelSourceDefault</a> as a starting point.</p>
<p><a class="el" href="class_pv_streaming_channel_source_default.html" title="A default implementation for the IPvStreamingSourceChannelSource interface.">PvStreamingChannelSourceDefault</a> enforces constant width, height, pixel format, no offset X/Y, no data chunk support, etc.</p>
<p>If you have a simple use case that would only require changing width and height, you could always use <a class="el" href="class_pv_streaming_channel_source_default.html" title="A default implementation for the IPvStreamingSourceChannelSource interface.">PvStreamingChannelSourceDefault</a> as a starting point and only override the width and height methods. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6030d2133913e6bef717fdd4fb59cc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6030d2133913e6bef717fdd4fb59cc4f">&#9670;&nbsp;</a></span>PvStreamingChannelSourceDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvStreamingChannelSourceDefault::PvStreamingChannelSourceDefault </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aWidth</em> = <code>640</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aHeight</em> = <code>480</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em> = <code><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9a6801cb7bf7663796c860aa5e9c712e82">PvPixelMono8</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>aBufferCount</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aWidth</td><td>Default width of the image source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aHeight</td><td>Default height of the image source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>Default pixel type of the image source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aBufferCount</td><td>Number of buffers to allocate for streaming. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a16629a202f89f098209c11f98a3d25e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16629a202f89f098209c11f98a3d25e7">&#9670;&nbsp;</a></span>AbortQueuedBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceDefault::AbortQueuedBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to abort all buffers queued for acquisition. </p>
<p>This method should block until acquisition has been aborted or canceled for all buffers provided by QueueBuffer that have not yet been retrieved with RetrievedBuffer.</p>
<p>When this method returns, it should be possible to call RetrieveBuffer for all aborted buffers. </p>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#ac8d6d94e883f928107a61b019f15f1bf">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a044333e2f8dfec6eff15fceb049d4f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044333e2f8dfec6eff15fceb049d4f38">&#9670;&nbsp;</a></span>AllocBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_buffer.html">PvBuffer</a> * PvStreamingChannelSourceDefault::AllocBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to allocate a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a>. </p>
<p>On initialization, the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will call this method, asking the application to allocate buffers that will be used for image acquisition and transmission. The application should return buffers until it has reached the desired number of buffers it wants to use for streaming and then return NULL.</p>
<p>The more buffers you use, the more buffers you can have queued in the application for image acquisition and the more buffers you can leave in the transmission output queue for packet resend. The downside of using more buffers is increased memory usage.</p>
<p>Buffers returned on AllocBuffer calls should be unique: you should not return the same buffer more than once.</p>
<p>A maximum of 64 buffers can be used by one streaming channel of the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a>. If your application does not return NULL on the 64th buffer, AllocBuffer will not be called a 64th time.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a new <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> that can be used by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a>'s acquisition manager. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a7bd95b0fe165ef567dc903ce78f952cb">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="ae43951777d20df72f768423d543a7aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43951777d20df72f768423d543a7aea">&#9670;&nbsp;</a></span>CreateGenApiFeatures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceDefault::CreateGenApiFeatures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *&#160;</td>
          <td class="paramname"><em>aRegisterMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv_gen_api_factory.html">IPvGenApiFactory</a> *&#160;</td>
          <td class="paramname"><em>aFactory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When called, the streaming channel source should create its custom GenApi parameters if they are needed. </p>
<p>Create GenApi features from this callback if the feature is associated with a streaming channel source. For global-device, non streaming channel source features use <a class="el" href="class_i_pv_soft_device_g_e_v_event_sink.html#a1ee4c97ef5f3fe2d24ceef3770481696" title="Notification that the PvSoftDeviceGEV should create its custom GenApi parameters, if they are needed.">IPvSoftDeviceGEVEventSink::OnCreateCustomGenApiFeatures</a> instead.</p>
<p>In a multi-source application, GenApi features created by a streaming channel source will only be available when the SourceSelector is set to the streaming channel source that created the feature.</p>
<p>If FeatureXYX is created by Source0 and Source1 but not by Source2, the feature will only be available in the GenApi interface when SourceSelector is set to Source0 or Source1. </p><pre class="fragment">- MySource0 has Feature0, Feature1, Feature2
- MySource1 has Feature0, Feature3, Feature4
- In a GenApi browser with SourceSelector=Source0, Feature0, Feature1, Feature2 are available. Feature3 and Feature4 are disabled.
- In a GenApi browser with SourceSelector=Source1, Feature0, Feature3, Feature4 are available. Feature1 and Feature2 are disabled.
</pre><p> If integers with the same name are created for more than one source but with source-specific minimum, maximum and increment attributes, these attributes will be handled by GenICam SwissKnife operators in the GenICam XML so they are dynamically adjusted based on the value of SourceSelector. The same applies to float maximum and minimum. </p><pre class="fragment">- MyInteger is created for Source0 with min:0 max:100 increment:4
- MyInteger is created for Source1 with min:4 max:200 increment:1
- In a GenApi browser, MyInteger will report min:0 max:100 increment:4 with Source0 is selected
- In a GenApi browser, MyInteger will report min:4 max:200 increment:1 with Source1 is selected
</pre><p> If enumerations with the same name are created for more than one source but with different enum entries, they will be added to the GenICam XML file of the device in way that the correct enum entries should be available for the enum features based on the current SourceSelector value: </p><pre class="fragment">- MyEnum is created with EE0, EE1, EE2 for Source0
- MyEnum is created with EE0, EE3, EE4 for Source1
- In a GenApi browser with SourceSelector=Source0, you would see EE0, EE1, EE2 in the combo box
- In a GenApi browser with SourceSelector=Source1, you would see EE0, EE3, EE4 in the combo box
</pre><p> Creating features of the same name but different types is not supported. Attempting to do so should have the <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> call failing with an appropriate error description.</p>
<p>GenApi features created for a streaming channel source should use registers unique to this streaming channel source. If you have a source class MySource that creates registers and features, it should still create unique register having their own unique addresses. They should however use the same parameter name. The GenApi parameters created by MySource should use the right register for the source instance. The complexity of overlapping per-source feature name is handled by <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> when creating the GenICam XML file from <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a>. </p><pre class="fragment">- For Source0:
    - MySource creates MySourceRegister0 @ 0x20000000 + 0x1000 * source index + 0
    - MySource creates MySourceParameter named "MySourceParameter" for Source0 using MySourceRegister0
- For Source1:
    - MySource creates MySourceRegister1 @ 0x20000000 + 0x1000 * source index + 4
    - MySource creates MySourceParameter named "MySourceParameter" for Source1 using MySourceRegister1
</pre><p> The exception to this rule is selectors: if selectors are created at the streaming source level they must all use the same register, sharing the same register address.</p>
<p>Custom source-specific GenApi features creation occurs AFTER custom source-specific registers creation, inside the <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRegisterMap</td><td>The register map of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFactory</td><td>GenApi factory used to create the new GenApi features. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_i_pv_streaming_channel_source.html#aa53b1fc8526c801f3cf097e7528a21f3">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a8e33958fd4f5327ef7e88d1588d17134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e33958fd4f5327ef7e88d1588d17134">&#9670;&nbsp;</a></span>CreateRegisters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceDefault::CreateRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv_register_map.html">IPvRegisterMap</a> *&#160;</td>
          <td class="paramname"><em>aRegisterMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_pv_register_factory.html">IPvRegisterFactory</a> *&#160;</td>
          <td class="paramname"><em>aFactory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When called, the streaming channel source should create its custom registers if they are needed. </p>
<p>To create source-specific custom registers in your application, implement the CreateRegisters method of the <a class="el" href="class_i_pv_streaming_channel_source.html" title="Interface that is used by PvSoftDeviceGEV to query and report information from a streaming source imp...">IPvStreamingChannelSource</a> interface.</p>
<p>Custom source-specific register creation occurs BEFORE custom source-specific GenApi features creation, inside the <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> call.</p>
<p>If more than one streaming channel source is created from the same class, you must make sure its registers are still unique: RegisterXYZ in Source0 and Source1 should not have the same address. It is also recommended to assign them unique names like RegisterXYZ0 and RegisterXYZ1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRegisterMap</td><td>The register map of the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFactory</td><td>Register factory used to create the new registers. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_i_pv_streaming_channel_source.html#a4d1eb6d88bcfc0c3b40f24493ec6df37">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a37ef37733a9a3a5c5a5fc8af67614411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ef37733a9a3a5c5a5fc8af67614411">&#9670;&nbsp;</a></span>FreeBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceDefault::FreeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td>
          <td class="paramname"><em>aBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to free or release a buffer allocated with AllocBuffer. </p>
<p>You should not delete or free any <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> provided by the AllocBuffer method. FreeBuffer will be called for each buffer created with AllocBuffer when <a class="el" href="class_pv_soft_device_g_e_v.html#accf2d25422086df4c3a993f5cebac5e5" title="Stops the PvSoftDeviceGEV.">PvSoftDeviceGEV::Stop</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffer</td><td>Buffer to free. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a0b95fe82221d67ddfa76e7bdb714d78e">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a9bef1c3d7bedad5bc6ccad1255133b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bef1c3d7bedad5bc6ccad1255133b7e">&#9670;&nbsp;</a></span>GetChunkEnable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvStreamingChannelSourceDefault::GetChunkEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aChunkID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current chunk enabled state. </p>
<p>The application must implement this method and return the current chunk enabled state for the specified chunk ID. The streaming source should maintain an enabled/disabled state for each chunk type that it supports.</p>
<p>The application should append the chunk represented by the specified chunk ID if it is enabled and if the master chunk mode (see <a class="el" href="class_pv_streaming_channel_source_default.html#a74de031d7095986ed0a27dffba6079e3" title="Indicates whether the current master chunk mode is active.">GetChunkModeActive</a>) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aChunkID</td><td>Chunk ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the chunk specified by aChunk ID is enabled for this streaming source. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#ac1cfdc32bd4ba2ce0fa7b7663e9a682c">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a74de031d7095986ed0a27dffba6079e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74de031d7095986ed0a27dffba6079e3">&#9670;&nbsp;</a></span>GetChunkModeActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvStreamingChannelSourceDefault::GetChunkModeActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the current master chunk mode is active. </p>
<p>The application must implement this method and return the current master chunk mode state. Return false as a hardcoded value if chunks are not supported by the streaming source.</p>
<dl class="section return"><dt>Returns</dt><dd>True if chunk mode is enabled for this streaming source. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#afb4b27f1c6ac46d738ea90be800a14e1">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a54cfef902c082f5ff890d9f40dd708c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cfef902c082f5ff890d9f40dd708c8">&#9670;&nbsp;</a></span>GetChunksSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvStreamingChannelSourceDefault::GetChunksSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the stream channel chunk size attributes. </p>
<p>When using data chunks, it is important to report the chunk data size when queried through this method.</p>
<p>The chunk data size needs to be taken into account when reporting the PayloadSize GenICam parameter to the GigE Vision controller, so it can properly allocate its buffer for streaming without forced buffer re-allocation.</p>
<p>The size reported must for each chunk adds 4 bytes for the chunk ID and another 4 bytes for the chunk length fields. If you have a chunk that is 64 bytes long and it is your only data chunk, you need to report 64 + 4 + 4 (72 bytes) when GetChunksSize is called.</p>
<dl class="section return"><dt>Returns</dt><dd>Chunk data size as currently configured. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#abdea1aa87836d12f8dfc731a7bc2c8be">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a296f588bf019422e7207d7d19f659a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296f588bf019422e7207d7d19f659a60">&#9670;&nbsp;</a></span>GetHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvStreamingChannelSourceDefault::GetHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current image height. </p>
<p>Your application must implement this method and return the current image height when invoked.</p>
<dl class="section return"><dt>Returns</dt><dd>Current image height. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a98e7a77219e025d7dfecf087cb0dcd0f">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="ab9d00526a08bae38c584ecdc708b2a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d00526a08bae38c584ecdc708b2a91">&#9670;&nbsp;</a></span>GetHeightInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceDefault::GetHeightInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aInc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stream channel height attributes. </p>
<p>When using the GigE Vision Device as a transmitter, the Height parameter is automatically added to the device's GenICam XML file. This method is used to query the minimum, maximum, and increment attributes for the Height parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aMin</td><td>Height minimum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aMax</td><td>Height maximum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aInc</td><td>Height increment. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#ac7064bbf89cc93c94f1d38f3266210d7">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a4b7f6c0a8cf998578d47833f795ec9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7f6c0a8cf998578d47833f795ec9da">&#9670;&nbsp;</a></span>GetOffsetX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvStreamingChannelSourceDefault::GetOffsetX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current image offset X. </p>
<p>Your application must implement this method and return the current image offset X when invoked.</p>
<dl class="section return"><dt>Returns</dt><dd>Current image offset X. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a1be122cd1c15190f9e48b2fa9f53f48a">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="aaf5c27a707218299385a234ec672efd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5c27a707218299385a234ec672efd4">&#9670;&nbsp;</a></span>GetOffsetY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvStreamingChannelSourceDefault::GetOffsetY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current image offset Y. </p>
<p>Your application must implement this method and return the current image offset Y when invoked.</p>
<dl class="section return"><dt>Returns</dt><dd>Current image offset Y. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#abcb4f731aa43007400f746d127973f03">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a01d4ecc06a0498940b7128aebd5e658a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d4ecc06a0498940b7128aebd5e658a">&#9670;&nbsp;</a></span>GetPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvStreamingChannelSourceDefault::GetPayloadSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream channel payload size in bytes. Return zero to have it inferred from width, height and pixel format. </p>
<p>If not using image streams (raw data, multi-part, etc.) use implement the GetPayloadSize method and return the payload size for the current streaming channel source configuration. If GetPayloadSize returns 0 the payload size will be inferred from the width, height, pixel format and data chunk size.</p>
<p>When using multi-part, return the sum of the maximum size of all parts plus data chunk.</p>
<p>When payload size is not zero, the payload size value is simply used as provided. Nothing is added to it, not even data chunk size.</p>
<dl class="section return"><dt>Returns</dt><dd>Payload size to use or 0. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a2acea878109ed0aa518dbb620af0493c">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a51dfc6c257c578d69b87100663ceb456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51dfc6c257c578d69b87100663ceb456">&#9670;&nbsp;</a></span>GetPixelType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> PvStreamingChannelSourceDefault::GetPixelType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current pixel type. </p>
<p>Your application must implement this method and return the current image pixel type when invoked.</p>
<dl class="section return"><dt>Returns</dt><dd>Current pixel type. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a0288e5a39738308217e6404a5e84cfba">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="ab71879e84222ed755be1b34196a7c9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71879e84222ed755be1b34196a7c9ac">&#9670;&nbsp;</a></span>GetScanType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PvScanType PvStreamingChannelSourceDefault::GetScanType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the scan type that is used by the streaming source. </p>
<p>Return PvScanTypeArea if your image source is areascan or PvScanTypeLine if your image source is linescan.</p>
<dl class="section return"><dt>Returns</dt><dd>Scan type of the streaming source. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a9101f68e3fa8d30114bdbb1b4eb4d481">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a94811fb695c7193ccf96de0aa5241419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94811fb695c7193ccf96de0aa5241419">&#9670;&nbsp;</a></span>GetSupportedChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceDefault::GetSupportedChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pv_string.html">PvString</a> &amp;&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the indexed supported chunk type. Used at <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> time to create the GenICam XML of the device. </p>
<p>This method is used by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to query the application about the supported chunk types for this streaming channel.</p>
<p>The <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will query the application through this stream interface for all supported chunk types. It will start at index 0 and then increase until something other than <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> is returned.</p>
<p>The information retrieved through this method is used to populate the chunk selector, allowing the GigE Vision controller to enable or disable each chunk type individually.</p>
<p>If the application supports ChunkSample (ID 0x4001) and ChunkHistogram (ID 0x4002) it needs to handle request to GetSupportedChunk as follows:</p><ul>
<li>GetSupportedChunk( 0 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a>, aID = 0x4001, aName = "ChunkSample"</li>
<li>GetSupportedChunk( 1 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a>, aID = 0x4002, aName = "ChunkHistogram"</li>
<li>GetSupportedChunk( 2 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Index of the chunk type to return. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aID</td><td>ID of the chunk type requested by aIndex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aName</td><td>Name of the chunk type requested by aIndex. Should always use the "Chunk" prefix for GenICam SFNC compliance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if aIndex represents a valid index and aPixelType has been set.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> or any other error code if aIndex is not valid. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a5d1747831496274d6e0b38c6c78e8491">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a1c3aa9f372b02d3841f318e3307e0b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3aa9f372b02d3841f318e3307e0b10">&#9670;&nbsp;</a></span>GetSupportedPixelType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceDefault::GetSupportedPixelType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> &amp;&#160;</td>
          <td class="paramname"><em>aPixelType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains an index of supported pixel types. Used at <a class="el" href="class_pv_soft_device_g_e_v.html#af5d9e5ec2245d4a18216eef9ecd9649a" title="Starts the PvSoftDeviceGEV.">PvSoftDeviceGEV::Start</a> time to create the GenICam XML of the device. </p>
<p>This method is used by the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to query the application about the supported pixel types for the streaming channel.</p>
<p>The <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will query the application using this stream interface for all supported pixel types. It will start at index 0 and then increase until something other than <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> is returned.</p>
<p>If the application supports Mono8, BayerRG8, and RGBa8 it needs to handle the request to GetSupportedPixelType, as follows:</p><ul>
<li>GetSupportedPixelType( 0 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a>, PvPixelMono8</li>
<li>GetSupportedPixelType( 1 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a>, PvPixelBayerRG8</li>
<li>GetSupportedPixelType( 2 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a>, PvPixelRGBa8</li>
<li>GetSupportedPixelType( 3 ) -&gt; <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Index of the pixel type to return. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aPixelType</td><td>PvPixelType requested by aIndex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if aIndex represents a valid index and aPixelType has been set.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> or any other error code if aIndex is not valid. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#aa7c82aa29f3c8beef373155074f657df">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a640c6e2f9442c7e4e7c8e41bad997839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640c6e2f9442c7e4e7c8e41bad997839">&#9670;&nbsp;</a></span>GetWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvStreamingChannelSourceDefault::GetWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current image width. </p>
<p>Your application must implement this method and return the current image width when invoked.</p>
<dl class="section return"><dt>Returns</dt><dd>Current image width. </dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a75e48b02b47d569fa6813cdae708366d">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="aebcff358601af0d7a102667906a9a57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcff358601af0d7a102667906a9a57b">&#9670;&nbsp;</a></span>GetWidthInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceDefault::GetWidthInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aInc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stream channel width attributes. </p>
<p>When using the GigE Vision Device as a transmitter, the Width parameter is automatically added to the device's GenICam XML file. This method is used to query the minimum, maximum, and increment attributes for the Width parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aMin</td><td>Width minimum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aMax</td><td>Width maximum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aInc</td><td>Width increment. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a541f29284aa630980adb8e136f409082">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="aad994685d489751052217b91639544db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad994685d489751052217b91639544db">&#9670;&nbsp;</a></span>IsPayloadTypeSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvStreamingChannelSourceDefault::IsPayloadTypeSupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&#160;</td>
          <td class="paramname"><em>aPayloadType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When called, the streaming source has to return whether the specificed payload type is supported or not. </p>
<p>Return true if the streaming source exlusively or non-exclusively can stream buffers of the specified payload type. A default implementation is provided for this method which returns false.</p>
<p>This method must be implemented and returning true for aPayloadType being equal to PvPayloadTypeMultiPart when multi-part is supported by the streaming source.</p>
<p>See <a class="el" href="class_pv_streaming_channel_source_default.html#aaa80d4b9887a22cf82f523be975e7bb4" title="When called, the streaming source has to ensure it can stream buffers of the specified payload type.">SetTestPayloadFormatMode</a> and <a class="el" href="class_pv_streaming_channel_source_default.html#a880d3269ee3dfd9827306382cfcc6790" title="Sets whether the streaming source is allowed or not, but not forced, to transmit multi-part data.">SetMultiPartAllowed</a> for more information on propertly supporting the multi-part payload type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aPayloadType</td><td>[in] The payload type for which support is queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the payload type is supported, false if not. </dd></dl>

<p>Reimplemented from <a class="el" href="class_i_pv_streaming_channel_source.html#aebfb312228bb1cb68a06245294df54eb">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a19d497d3e7dff403c99ddea060070c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d497d3e7dff403c99ddea060070c87">&#9670;&nbsp;</a></span>OnOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceDefault::OnOpen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pv_string.html">PvString</a> &amp;&#160;</td>
          <td class="paramname"><em>aDestIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aDestPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notification from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> that this streaming channel has been opened. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aDestIP</td><td>IP address of the stream destination as a string in the "192.168.138.115" format (SCDA). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aDestPort</td><td>UDP port of the stream destination (SCP). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a64bf48ef40df3b27f5362fa161cc593b">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a6eade8a2b75a510f1be6486c9d07c677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eade8a2b75a510f1be6486c9d07c677">&#9670;&nbsp;</a></span>SetChunkEnable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceDefault::SetChunkEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aChunkID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the chunk enabled state for a specific chunk type. </p>
<p>The streaming source should append a specific chunk type to its streaming data when both the <a class="el" href="class_pv_streaming_channel_source_default.html#a74de031d7095986ed0a27dffba6079e3" title="Indicates whether the current master chunk mode is active.">GetChunkModeActive</a> (master chunk mode) and <a class="el" href="class_pv_streaming_channel_source_default.html#a9bef1c3d7bedad5bc6ccad1255133b7e" title="Returns the current chunk enabled state.">GetChunkEnable</a> for this specific chunk type are true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aChunkID</td><td>Chunk ID of the chunk type to enable or disable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aEnabled</td><td>True to enable the chunk type, false to disable it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> to accept the new setting.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new setting. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#ad8adf8e1bd0b86e990c8a441b41b5447">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="ac81d11f179930d0b364f13921d4f0204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81d11f179930d0b364f13921d4f0204">&#9670;&nbsp;</a></span>SetChunkModeActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceDefault::SetChunkModeActive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the master chunk mode active state. </p>
<p>The streaming source should append a specific chunk type to its streaming data when both the <a class="el" href="class_pv_streaming_channel_source_default.html#a74de031d7095986ed0a27dffba6079e3" title="Indicates whether the current master chunk mode is active.">GetChunkModeActive</a> (master chunk mode) and <a class="el" href="class_pv_streaming_channel_source_default.html#a9bef1c3d7bedad5bc6ccad1255133b7e" title="Returns the current chunk enabled state.">GetChunkEnable</a> for this specific chunk type are true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEnabled</td><td>True to enable chunk mode for this streaming channel, false to disable it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> to accept the new setting.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new setting. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a69946f8085eccd27ee06bb75b1d55b74">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="abaf06b8d153b80910d7b7dc9139aaca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf06b8d153b80910d7b7dc9139aaca5">&#9670;&nbsp;</a></span>SetHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceDefault::SetHeight </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aHeight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image height. </p>
<p>The <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will call SetHeight when the Height GenApi parameter or the underlying register is changed by the GigE Vision controller.</p>
<p>To accept the new height, return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> and update your streaming code to use the new height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aHeight</td><td>New image height.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> when accepting the new height.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new height. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a878cb7d39d9f4c7034a95f14947535d0">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="af358c744ce052bca6548fa066eea8c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af358c744ce052bca6548fa066eea8c82">&#9670;&nbsp;</a></span>SetLargeLeaderTrailerEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceDefault::SetLargeLeaderTrailerEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMaxMultiPartCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the streaming source which transmit multi-part data uses large data leader and trailer packets. </p>
<p>Streaming sources using multi-part data transmission without large data leader and trailer enabled only supports up to 10 multi-parts due to the data leader and trailer packet size limitation. Large data leader and data trailer packets can be enabled by configuring the GevSCCFGLargeLeaderTrailerEnabled GenApi parameter to allow more than 10 parts. The large leader and trailer packet size is then set to the value allowed by the SCPSx register.</p>
<p>The GevSCCFGLargeLeaderTrailerEnabled GenApi parameter is automatically added to the GenICam XML file of a <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> device when <a class="el" href="class_pv_streaming_channel_source_default.html#aad994685d489751052217b91639544db" title="When called, the streaming source has to return whether the specificed payload type is supported or n...">IsPayloadTypeSupported</a> returns true when prompted with PvPayloadTypeMultiPart. This parameter will only be available when GevSCCFGMultiPartEnabled is set to true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aEnabled</td><td>[in] True if Large Leader Trailer is enabled. </td></tr>
    <tr><td class="paramname">aMaxMultiPartCount</td><td>[in] The number of maximum allowed Multi parts calculated from the value allowed by the SCPSx register. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_i_pv_streaming_channel_source.html#a072c52233051fabb3f5ca3e9237dc8b7">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a880d3269ee3dfd9827306382cfcc6790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880d3269ee3dfd9827306382cfcc6790">&#9670;&nbsp;</a></span>SetMultiPartAllowed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStreamingChannelSourceDefault::SetMultiPartAllowed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aAllowed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the streaming source is allowed or not, but not forced, to transmit multi-part data. </p>
<p>Streaming sources supporting multi-part data transmission must support non-multi-part streaming by default. All devices starting in a mode where multi-part is not allowed. The GigE Vision controller must unlock the multi-part capability of a GVSP streaming channel using either the SCCx and SCCFGx bootstrap registers or the GevSCCFGMultiPartEnabled GenApi parameter.</p>
<p>The GevSCCFGMultiPartEnabled GenApi parameter is automatically added to the GenICam XML file of a <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> device when <a class="el" href="class_pv_streaming_channel_source_default.html#aad994685d489751052217b91639544db" title="When called, the streaming source has to return whether the specificed payload type is supported or n...">IsPayloadTypeSupported</a> returns true when prompted with PvPayloadTypeMultiPart.</p>
<p>See <a class="el" href="class_pv_streaming_channel_source_default.html#aad994685d489751052217b91639544db" title="When called, the streaming source has to return whether the specificed payload type is supported or n...">IsPayloadTypeSupported</a> and <a class="el" href="class_pv_streaming_channel_source_default.html#aaa80d4b9887a22cf82f523be975e7bb4" title="When called, the streaming source has to ensure it can stream buffers of the specified payload type.">SetTestPayloadFormatMode</a> for more information on propertly supporting the multi-part payload type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aAllowed</td><td>[in] True if multi-part is allowed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_i_pv_streaming_channel_source.html#a021da3f3c44e1ae2f4a92674566897c0">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a01d3bb9c6434e169041e2cbc52305635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d3bb9c6434e169041e2cbc52305635">&#9670;&nbsp;</a></span>SetOffsetX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceDefault::SetOffsetX </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aOffsetX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image offset X. </p>
<p>To accept the new offset X, return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> and update your streaming code to use the new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aOffsetX</td><td>New image offset X.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> when accepting the new value.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new value. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a4572d298d03100c8dcd4d92de9eee6c1">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="aa16d968e0486c7e9e6b8ada39462e560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16d968e0486c7e9e6b8ada39462e560">&#9670;&nbsp;</a></span>SetOffsetY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceDefault::SetOffsetY </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aOffsetY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image offset Y. </p>
<p>To accept the new offset Y, return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> and update your streaming code to use the new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aOffsetY</td><td>New image offset Y.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> when accepting the new value.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new value. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a955f86fae157bb97cf1ad4289b18b52f">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="a268d9e3ebc7a676f87eb5c6ade9c6477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268d9e3ebc7a676f87eb5c6ade9c6477">&#9670;&nbsp;</a></span>SetPixelType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceDefault::SetPixelType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image pixel type. </p>
<p>The <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will call SetPixelType when the PixelType GenApi parameter or the underlying register is changed by the GigE Vision controller.</p>
<p>To accept the new pixel type, return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> and update your streaming code to use the new pixel type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>New image pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> when accepting the new pixel type.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new pixel type. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a7d437dc2bebce465562dc36a1287c056">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="aaa80d4b9887a22cf82f523be975e7bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa80d4b9887a22cf82f523be975e7bb4">&#9670;&nbsp;</a></span>SetTestPayloadFormatMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceDefault::SetTestPayloadFormatMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&#160;</td>
          <td class="paramname"><em>aPayloadType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When called, the streaming source has to ensure it can stream buffers of the specified payload type. </p>
<p>The GigE Vision Validation Framework has to be able to set the device in a functional streaming mode for some payload types (currently only multi-part with more to come) in order to properly validate the device.</p>
<p>This method must be implemented and for aPayloadType being PvPayloadTypeMultiPart when multi-part is supported by the streaming source. The streaming source must be able to configure itself in a mode where it will be able to stream data for certification with the GigE Vision Validation Framework.</p>
<p>Of course, this method will only be called on a streaming source for payload type that have been reported as supported with <a class="el" href="class_pv_streaming_channel_source_default.html#aad994685d489751052217b91639544db" title="When called, the streaming source has to return whether the specificed payload type is supported or n...">IsPayloadTypeSupported</a>.</p>
<p>How to prepare your multi-source device source for GigE Vision Validation Framework validation:</p><ul>
<li>Implement <a class="el" href="class_pv_streaming_channel_source_default.html#aad994685d489751052217b91639544db" title="When called, the streaming source has to return whether the specificed payload type is supported or n...">IsPayloadTypeSupported</a> and return true if aPayloadType is PvPayloadTypeMultiPart.</li>
<li>Implement <a class="el" href="class_pv_streaming_channel_source_default.html#aaa80d4b9887a22cf82f523be975e7bb4" title="When called, the streaming source has to ensure it can stream buffers of the specified payload type.">SetTestPayloadFormatMode</a><ul>
<li>If aPayloadType is PvPayloadTypeMultiPart<ul>
<li>Setup your streaming source for autonomous multi-part streaming if needed</li>
<li>Return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
</ul>
</li>
<li>Else if aPayloadType is PvPayloadTypeNone<ul>
<li>Disable test mode, go back to streaming source normal operation mode</li>
<li>Return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
</ul>
</li>
<li>Else<ul>
<li>Return any <a class="el" href="class_pv_result.html" title="Result information.">PvResult</a> error code like <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca75f3849bb9840c5af2c3cf303983aac4">PvResult::Code::NOT_SUPPORTED</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>See the SoftDeviceGEVMultiPart C++ sample for an example of how to implement this method, <a class="el" href="class_pv_streaming_channel_source_default.html#a880d3269ee3dfd9827306382cfcc6790" title="Sets whether the streaming source is allowed or not, but not forced, to transmit multi-part data.">SetMultiPartAllowed</a>, and <a class="el" href="class_pv_streaming_channel_source_default.html#aad994685d489751052217b91639544db" title="When called, the streaming source has to return whether the specificed payload type is supported or n...">IsPayloadTypeSupported</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPayloadType</td><td>Payload type to prepare test for. PvPayloadTypeNone sets the device back in normal operation mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li>Any error code can be returned to indicate failure. </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_i_pv_streaming_channel_source.html#a01aabac21df5f952506eda964976d4b3">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<a id="ab76a34be2080f3f8990b032968457f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76a34be2080f3f8990b032968457f97">&#9670;&nbsp;</a></span>SetWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStreamingChannelSourceDefault::SetWidth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request from the <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> to change the image width. </p>
<p>The <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a> will call SetWidth when the Width GenApi parameter or the underlying register is changed by the GigE Vision controller.</p>
<p>To accept the new width, return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> and update your streaming code to use the new width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aWidth</td><td>New image width.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> when accepting the new width.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> or another error code to refuse the new width. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="class_i_pv_streaming_channel_source.html#a44d0aaf4828da15f77fd4e3f221f000f">IPvStreamingChannelSource</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_streaming_channel_source_default_8h_source.html">PvStreamingChannelSourceDefault.h</a></li>
<li>PvVirtualDevice/PvStreamingChannelSourceDefault.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2024 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
