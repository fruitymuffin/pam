<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>IPvMultiPartContainerWriter Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v6.4.0.6670 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_i_pv_multi_part_container_writer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_i_pv_multi_part_container_writer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IPvMultiPartContainerWriter Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface used to write to a multi-part container.  
 <a href="class_i_pv_multi_part_container_writer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_pv_multi_part_container_8h_source.html">PvMultiPartContainer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ad7bd958f22715170316e954dfc32b6"><td class="memItemLeft" align="right" valign="top"><a id="a4ad7bd958f22715170316e954dfc32b6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#a4ad7bd958f22715170316e954dfc32b6">Reset</a> ()=0</td></tr>
<tr class="memdesc:a4ad7bd958f22715170316e954dfc32b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the multi-part container index to empty - no parts. <br /></td></tr>
<tr class="separator:a4ad7bd958f22715170316e954dfc32b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39db67d1d299ba4b9b84c7059889f3c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#af39db67d1d299ba4b9b84c7059889f3c">AddImagePart</a> (PvMultiPartDataType aDataType, uint32_t aWidth, uint32_t aMaxHeight, <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType, uint32_t aOffsetX=0, uint32_t aOffsetY=0, uint16_t aPaddingX=0)=0</td></tr>
<tr class="memdesc:af39db67d1d299ba4b9b84c7059889f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an image part to the index of a multi-part container.  <a href="class_i_pv_multi_part_container_writer.html#af39db67d1d299ba4b9b84c7059889f3c">More...</a><br /></td></tr>
<tr class="separator:af39db67d1d299ba4b9b84c7059889f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c1faefda3d15aeb8757fa21ba9bfd0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#ac6c1faefda3d15aeb8757fa21ba9bfd0">AddJPEGPart</a> (PvMultiPartDataType aDataType, uint32_t aMaxLength, uint8_t aFlag, uint64_t aTimestampTickFrequency, uint32_t aDataFormat)=0</td></tr>
<tr class="memdesc:ac6c1faefda3d15aeb8757fa21ba9bfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a JPEG part to the index of a multi-part container.  <a href="class_i_pv_multi_part_container_writer.html#ac6c1faefda3d15aeb8757fa21ba9bfd0">More...</a><br /></td></tr>
<tr class="separator:ac6c1faefda3d15aeb8757fa21ba9bfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffb90b6b557a4ec54938be96d4a918d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#a6ffb90b6b557a4ec54938be96d4a918d">AddChunkPart</a> (uint32_t aMaxLength, uint32_t aChunkLayoutID)=0</td></tr>
<tr class="memdesc:a6ffb90b6b557a4ec54938be96d4a918d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a chunk data part to the index of a multi-part container.  <a href="class_i_pv_multi_part_container_writer.html#a6ffb90b6b557a4ec54938be96d4a918d">More...</a><br /></td></tr>
<tr class="separator:a6ffb90b6b557a4ec54938be96d4a918d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12f3ed0192479b498cc214539cc53da"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#ad12f3ed0192479b498cc214539cc53da">SetPartIDs</a> (uint32_t aIndex, uint32_t aSourceID, uint32_t aDataPurposeID, uint32_t aRegionID)=0</td></tr>
<tr class="memdesc:ad12f3ed0192479b498cc214539cc53da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the source, data purpose and region IDs of a part.  <a href="class_i_pv_multi_part_container_writer.html#ad12f3ed0192479b498cc214539cc53da">More...</a><br /></td></tr>
<tr class="separator:ad12f3ed0192479b498cc214539cc53da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d22130bd183110f89eb459e0efca48a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#a2d22130bd183110f89eb459e0efca48a">SetPartZoneInfo</a> (uint32_t aIndex, uint8_t aAdditionalZones, uint32_t aZoneDirectionMask)=0</td></tr>
<tr class="memdesc:a2d22130bd183110f89eb459e0efca48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the zone info of a part.  <a href="class_i_pv_multi_part_container_writer.html#a2d22130bd183110f89eb459e0efca48a">More...</a><br /></td></tr>
<tr class="separator:a2d22130bd183110f89eb459e0efca48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5406996f8a202f4a53d07917d58a904b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#a5406996f8a202f4a53d07917d58a904b">AllocAllParts</a> ()=0</td></tr>
<tr class="memdesc:a5406996f8a202f4a53d07917d58a904b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for all parts defined by the part index of the multi-part container.  <a href="class_i_pv_multi_part_container_writer.html#a5406996f8a202f4a53d07917d58a904b">More...</a><br /></td></tr>
<tr class="separator:a5406996f8a202f4a53d07917d58a904b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad426415c9b191773193fc1107813b222"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#ad426415c9b191773193fc1107813b222">AllocPart</a> (uint32_t aIndex)=0</td></tr>
<tr class="memdesc:ad426415c9b191773193fc1107813b222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for one of the parts as defined by the index of the part.  <a href="class_i_pv_multi_part_container_writer.html#ad426415c9b191773193fc1107813b222">More...</a><br /></td></tr>
<tr class="separator:ad426415c9b191773193fc1107813b222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe327b4e8dc80c86ccedb4f39e5473d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#afe327b4e8dc80c86ccedb4f39e5473d5">AttachPart</a> (uint32_t aIndex, uint8_t *aBuffer, uint64_t aLength)=0</td></tr>
<tr class="memdesc:afe327b4e8dc80c86ccedb4f39e5473d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a part to an external memory buffer.  <a href="class_i_pv_multi_part_container_writer.html#afe327b4e8dc80c86ccedb4f39e5473d5">More...</a><br /></td></tr>
<tr class="separator:afe327b4e8dc80c86ccedb4f39e5473d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ea1b9a6a1dcd1a92afca75b22835ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#a69ea1b9a6a1dcd1a92afca75b22835ee">SetPartFinalLength</a> (uint32_t aIndex, uint32_t aLength)=0</td></tr>
<tr class="memdesc:a69ea1b9a6a1dcd1a92afca75b22835ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the final length of a part.  <a href="class_i_pv_multi_part_container_writer.html#a69ea1b9a6a1dcd1a92afca75b22835ee">More...</a><br /></td></tr>
<tr class="separator:a69ea1b9a6a1dcd1a92afca75b22835ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462977971740bc05dce26c30ce105466"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#a462977971740bc05dce26c30ce105466">SetPartFinalImageHeight</a> (uint32_t aIndex, uint32_t aHeight)=0</td></tr>
<tr class="memdesc:a462977971740bc05dce26c30ce105466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the final height of an image part.  <a href="class_i_pv_multi_part_container_writer.html#a462977971740bc05dce26c30ce105466">More...</a><br /></td></tr>
<tr class="separator:a462977971740bc05dce26c30ce105466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a91d5d86412069e9c64dfb840aca2e2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_writer.html#a2a91d5d86412069e9c64dfb840aca2e2">Validate</a> ()=0</td></tr>
<tr class="memdesc:a2a91d5d86412069e9c64dfb840aca2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the part index and allocated/attached part memory.  <a href="class_i_pv_multi_part_container_writer.html#a2a91d5d86412069e9c64dfb840aca2e2">More...</a><br /></td></tr>
<tr class="separator:a2a91d5d86412069e9c64dfb840aca2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_pv_multi_part_container_reader"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_pv_multi_part_container_reader')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_pv_multi_part_container_reader.html">IPvMultiPartContainerReader</a></td></tr>
<tr class="memitem:a952e2197d8603982b94dfee3c5b8f647 inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_reader.html#a952e2197d8603982b94dfee3c5b8f647">GetPartCount</a> ()=0</td></tr>
<tr class="memdesc:a952e2197d8603982b94dfee3c5b8f647 inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part count of the multi-part container.  <a href="class_i_pv_multi_part_container_reader.html#a952e2197d8603982b94dfee3c5b8f647">More...</a><br /></td></tr>
<tr class="separator:a952e2197d8603982b94dfee3c5b8f647 inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f06b171d803bf483ab18e338c1adfa inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_i_pv_multi_part_section.html">IPvMultiPartSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_reader.html#ab2f06b171d803bf483ab18e338c1adfa">GetPart</a> (uint32_t aIndex) const =0</td></tr>
<tr class="memdesc:ab2f06b171d803bf483ab18e338c1adfa inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed part (section) const accessor.  <a href="class_i_pv_multi_part_container_reader.html#ab2f06b171d803bf483ab18e338c1adfa">More...</a><br /></td></tr>
<tr class="separator:ab2f06b171d803bf483ab18e338c1adfa inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cd50ab6df5cbf0efca17d41065908e inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv_multi_part_section.html">IPvMultiPartSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_reader.html#a50cd50ab6df5cbf0efca17d41065908e">GetPart</a> (uint32_t aIndex)=0</td></tr>
<tr class="memdesc:a50cd50ab6df5cbf0efca17d41065908e inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed part (section) accessor.  <a href="class_i_pv_multi_part_container_reader.html#a50cd50ab6df5cbf0efca17d41065908e">More...</a><br /></td></tr>
<tr class="separator:a50cd50ab6df5cbf0efca17d41065908e inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657d74a6fb30d69357b56cc4f06d4a5f inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_i_pv_multi_part_section.html">IPvMultiPartSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_reader.html#a657d74a6fb30d69357b56cc4f06d4a5f">operator[]</a> (uint32_t aIndex) const =0</td></tr>
<tr class="memdesc:a657d74a6fb30d69357b56cc4f06d4a5f inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed part (section) const accessor.  <a href="class_i_pv_multi_part_container_reader.html#a657d74a6fb30d69357b56cc4f06d4a5f">More...</a><br /></td></tr>
<tr class="separator:a657d74a6fb30d69357b56cc4f06d4a5f inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace91c8f6bd57db5e3f798a2208528157 inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_i_pv_multi_part_section.html">IPvMultiPartSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_pv_multi_part_container_reader.html#ace91c8f6bd57db5e3f798a2208528157">operator[]</a> (uint32_t aIndex)=0</td></tr>
<tr class="memdesc:ace91c8f6bd57db5e3f798a2208528157 inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed part (section) accessor.  <a href="class_i_pv_multi_part_container_reader.html#ace91c8f6bd57db5e3f798a2208528157">More...</a><br /></td></tr>
<tr class="separator:ace91c8f6bd57db5e3f798a2208528157 inherit pub_methods_class_i_pv_multi_part_container_reader"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface used to write to a multi-part container. </p>
<p>This interface is used to create a multi-part <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> than can be transmitted using <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a>.</p>
<p>A multi-part buffer would typically be prepared for transmission by:</p><ul>
<li>Creating a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> by specifying a payload type of PvPayloadTypeMultiPart to the constructor.</li>
<li>Retrieving the <a class="el" href="class_i_pv_multi_part_container_writer.html" title="Interface used to write to a multi-part container.">IPvMultiPartContainerWriter</a> interface using <a class="el" href="class_pv_buffer.html#a0adf6ff1a75e7431dac15d3f0fde2f08" title="Returns the PvChunkData interface to the buffer.">PvBuffer::GetMultiPartContainer</a>.</li>
<li>Defining the parts using the <a class="el" href="class_i_pv_multi_part_container_writer.html#af39db67d1d299ba4b9b84c7059889f3c" title="Adds an image part to the index of a multi-part container.">AddImagePart</a>, <a class="el" href="class_i_pv_multi_part_container_writer.html#ac6c1faefda3d15aeb8757fa21ba9bfd0" title="Adds a JPEG part to the index of a multi-part container.">AddJPEGPart</a> and <a class="el" href="class_i_pv_multi_part_container_writer.html#a6ffb90b6b557a4ec54938be96d4a918d" title="Adds a chunk data part to the index of a multi-part container.">AddChunkPart</a> methods.</li>
<li>Allocating/attaching memory using either <a class="el" href="class_i_pv_multi_part_container_writer.html#a5406996f8a202f4a53d07917d58a904b" title="Allocates memory for all parts defined by the part index of the multi-part container.">AllocAllParts</a> or a mix of <a class="el" href="class_i_pv_multi_part_container_writer.html#ad426415c9b191773193fc1107813b222" title="Allocates memory for one of the parts as defined by the index of the part.">AllocPart</a> and <a class="el" href="class_i_pv_multi_part_container_writer.html#afe327b4e8dc80c86ccedb4f39e5473d5" title="Attaches a part to an external memory buffer.">AttachPart</a>.</li>
<li>Filling the part data using <a class="el" href="class_i_pv_multi_part_container_reader.html" title="Interface used to read from a multi-part container.">IPvMultiPartContainerReader</a> and <a class="el" href="class_i_pv_multi_part_section.html" title="One section (part) of a multi-part container.">IPvMultiPartSection</a>.</li>
<li>Using the <a class="el" href="class_i_pv_multi_part_container_writer.html#a2a91d5d86412069e9c64dfb840aca2e2" title="Validates the part index and allocated/attached part memory.">Validate</a> method to make sure the multi-part container is valid.</li>
<li>Transmitting the part from a streaming source of <a class="el" href="class_pv_soft_device_g_e_v.html" title="Implements a software-based GigE Vision Device with full GVCP and GVSP support.">PvSoftDeviceGEV</a>.</li>
</ul>
<p>Adding parts with this interface only creates the part definition in the part index of the container. Memory then needs to be allocated or attached for all parts. Make sure to call <a class="el" href="class_i_pv_multi_part_container_writer.html#a2a91d5d86412069e9c64dfb840aca2e2" title="Validates the part index and allocated/attached part memory.">Validate</a> after defining the parts and allocating or attaching memory to make sure the multi-part container is properly setup.</p>
<p>You can either have no data chunk part of one chunk part and that part needs to be the last part. Use The <a class="el" href="class_i_pv_chunk_data.html" title="Generic chunk data interface.">IPvChunkData</a> interface to the section to define the chunk data and confirm the chunk length using <a class="el" href="class_i_pv_multi_part_container_writer.html#a69ea1b9a6a1dcd1a92afca75b22835ee" title="Sets the final length of a part.">SetPartFinalLength</a> to confirm the chunk data length.</p>
<p>See SoftGEVDeviceMultiPart C++ eBUS SDK sample for more information.</p>
<p>GigE Vision restricts the maximum part count to 10. This limitation comes from the part index size in the context of the maximum GVSP header size. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6ffb90b6b557a4ec54938be96d4a918d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffb90b6b557a4ec54938be96d4a918d">&#9670;&nbsp;</a></span>AddChunkPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvMultiPartContainerWriter::AddChunkPart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMaxLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aChunkLayoutID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a chunk data part to the index of a multi-part container. </p>
<p>The chunk data section is always last in a multi-part container. There can only be one chunk data section for a multi-part container. A chunk data section can contain one or more chunks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aMaxLength</td><td>Maximum length for chunk data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aChunkLayoutID</td><td>Chunk layoud ID for the chunk data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca75f3849bb9840c5af2c3cf303983aac4">PvResult::Code::NOT_SUPPORTED</a> if the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> accessed from this interfaced is not defined as a multi-part buffer.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca1ba59804e9bbb3c4c7523e2992221d57">PvResult::Code::ERR_OVERFLOW</a> if the maximum number of parts supported by the GigE Vision specification has already been reached.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca20b763c2ece588805c271b68bccb9134">PvResult::Code::STATE_ERROR</a> if the previously added part is of type chunk data which is only valid as the last part. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af39db67d1d299ba4b9b84c7059889f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39db67d1d299ba4b9b84c7059889f3c">&#9670;&nbsp;</a></span>AddImagePart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvMultiPartContainerWriter::AddImagePart </td>
          <td>(</td>
          <td class="paramtype">PvMultiPartDataType&#160;</td>
          <td class="paramname"><em>aDataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMaxHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aOffsetX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aOffsetY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aPaddingX</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an image part to the index of a multi-part container. </p>
<p>Calling this method only defines a new image in the multi-part container index. Memory needs to be allocated or attached using the AllocAllParts, AllocPart or AttachPart methods.</p>
<p>The height is initially defined as maximum height. It is possible to later call SetPartFinalImageHeight to confirm the effective height of the image, as long as the confirmed height is less or equal to the maximum height defined here. This allows linescan-like scenario where the final height of the image is not known when the image part is defined and its memory allocated or attached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aDataType</td><td>Image data type. Must be between PvMultiPart2DImage and PvMultiPartConfidenceMap, inclusive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aWidth</td><td>Width of the image, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aMaxHeight</td><td>Height of the image, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>Pixel type of the image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aOffsetX</td><td>Offset X of the image, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aOffsetY</td><td>Offset Y of the image, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPaddingX</td><td>Padding X of the image, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> aDataType does not represent an image, aWidth is zero or aHeight is zero.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca75f3849bb9840c5af2c3cf303983aac4">PvResult::Code::NOT_SUPPORTED</a> if the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> accessed from this interfaced is not defined as a multi-part buffer.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca1ba59804e9bbb3c4c7523e2992221d57">PvResult::Code::ERR_OVERFLOW</a> if the maximum number of parts supported by the GigE Vision specification has already been reached.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca20b763c2ece588805c271b68bccb9134">PvResult::Code::STATE_ERROR</a> if the previously added part is of type chunk data which is only valid as the last part. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac6c1faefda3d15aeb8757fa21ba9bfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c1faefda3d15aeb8757fa21ba9bfd0">&#9670;&nbsp;</a></span>AddJPEGPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvMultiPartContainerWriter::AddJPEGPart </td>
          <td>(</td>
          <td class="paramtype">PvMultiPartDataType&#160;</td>
          <td class="paramname"><em>aDataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aMaxLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>aFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>aTimestampTickFrequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aDataFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a JPEG part to the index of a multi-part container. </p>
<p>Calling this method only defines a new JPEG image in the multi-part container index. Memory needs to be allocated or attached using the AllocAllParts, AllocPart or AttachPart methods.</p>
<p>The length is initially defined as maximum length, in bytes. It is possible to later call SetPartFinalLength to confirm the effective length of the compressed image, as long as the confirmed length is less or equal to the maximum length defined here. This allows reserving memory for the worse-case compression scenario and defining the real compressed image length when putting the part together before transmission.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aDataType</td><td>Multi-part data type. Either PvMultiPartJPEGImage or PvMultiPartJPEG2000Image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aMaxLength</td><td>Maximum length for the compressed image. Defined here as worse-case compression, exact size later confirmed with SetPartFinalLength. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aFlag</td><td>JPEG flags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aTimestampTickFrequency</td><td>Timestamp tick frequency. Can be used with JPEG2000 to turn buffer timestamp into real time units. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aDataFormat</td><td>JPEG data format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca75f3849bb9840c5af2c3cf303983aac4">PvResult::Code::NOT_SUPPORTED</a> if the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> accessed from this interfaced is not defined as a multi-part buffer.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca1ba59804e9bbb3c4c7523e2992221d57">PvResult::Code::ERR_OVERFLOW</a> if the maximum number of parts supported by the GigE Vision specification has already been reached.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca20b763c2ece588805c271b68bccb9134">PvResult::Code::STATE_ERROR</a> if the previously added part is of type chunk data which is only valid as the last part. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5406996f8a202f4a53d07917d58a904b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5406996f8a202f4a53d07917d58a904b">&#9670;&nbsp;</a></span>AllocAllParts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvMultiPartContainerWriter::AllocAllParts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for all parts defined by the part index of the multi-part container. </p>
<p>With this method all parts are allocated as a single contiguous memory buffer.</p>
<p>Memory is allocated based on each parts definition: image size is inferred from width, max height, pixel format and padding X. JPEG from the maximum length. Chunk from the maximum chunk length.</p>
<p>If memory was allocated for all parts or individual parts, it is freed before being re-allocated. If memory was attached for any part, it is simply detached.</p>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca20b763c2ece588805c271b68bccb9134">PvResult::Code::STATE_ERROR</a> if no parts are currently defined.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca1ba59804e9bbb3c4c7523e2992221d57">PvResult::Code::ERR_OVERFLOW</a> if more memory is required than currently supported by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory.">PvBuffer</a> class. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad426415c9b191773193fc1107813b222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad426415c9b191773193fc1107813b222">&#9670;&nbsp;</a></span>AllocPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvMultiPartContainerWriter::AllocPart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for one of the parts as defined by the index of the part. </p>
<p>If memory has been previously allocated for all parts, new memory for this part alone is allocated and used instead. Unused memory for the part is still reserved in the contiguous buffer.</p>
<p>Memory is allocated based on each parts definition: image size is inferred from width, max height, pixel format and padding X. JPEG from the maximum length. Chunk from the maximum chunk length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>[in] Zero-based index of the part.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> if aIndex is out of range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afe327b4e8dc80c86ccedb4f39e5473d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe327b4e8dc80c86ccedb4f39e5473d5">&#9670;&nbsp;</a></span>AttachPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvMultiPartContainerWriter::AttachPart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>aLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a part to an external memory buffer. </p>
<p>If memory has been previously allocated for all parts, new memory for this part alone is attached and used instead. Unused memory for the part is still reserved in the contiguous buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>[in] Zero-based index of the part. </td></tr>
    <tr><td class="paramname">aBuffer</td><td>[in] Pointer to the external memory buffer. </td></tr>
    <tr><td class="paramname">aLength</td><td>[in] Length of the external memory buffer to attach.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> if aIndex is out of range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a462977971740bc05dce26c30ce105466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462977971740bc05dce26c30ce105466">&#9670;&nbsp;</a></span>SetPartFinalImageHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvMultiPartContainerWriter::SetPartFinalImageHeight </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the final height of an image part. </p>
<p>Used to confirm final height of image parts. If this method is not called, the image height is assumed to be the full maximum image height as defined in AddImagePart.</p>
<p>See AddImagePart for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>[in] Zero-based index of the part. </td></tr>
    <tr><td class="paramname">aHeight</td><td>[in] Final height of the part.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> if aIndex is out of range.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> if aIndex is out of range, aHeight is bigger than the maximum height for this part or the part is not an image. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a69ea1b9a6a1dcd1a92afca75b22835ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ea1b9a6a1dcd1a92afca75b22835ee">&#9670;&nbsp;</a></span>SetPartFinalLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvMultiPartContainerWriter::SetPartFinalLength </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the final length of a part. </p>
<p>Used to confirm final length of JPEG and chunk data parts. If this method is not called, the part length is assumed to be the full maximum part length as defined in AddJPEGPart or AddChunkPart.</p>
<p>See AddJPEGPart and AddChunkPart for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>[in] Zero-based index of the part. </td></tr>
    <tr><td class="paramname">aLength</td><td>[in] aLength Final length of the part.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> if aIndex is out of range, aLength is bigger than the maximum part length or the part is an image. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad12f3ed0192479b498cc214539cc53da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12f3ed0192479b498cc214539cc53da">&#9670;&nbsp;</a></span>SetPartIDs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvMultiPartContainerWriter::SetPartIDs </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSourceID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aDataPurposeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aRegionID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the source, data purpose and region IDs of a part. </p>
<p>See <a class="el" href="class_i_pv_multi_part_section.html" title="One section (part) of a multi-part container.">IPvMultiPartSection</a> for more information about these IDs.</p>
<p>If this method is not called after adding a part to the multi-part container index, all IDs are zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>[in] Zero-based index of the part. </td></tr>
    <tr><td class="paramname">aSourceID</td><td>[in] Source ID to assign to the part </td></tr>
    <tr><td class="paramname">aDataPurposeID</td><td>[in] Data purpose ID to assign to the part. </td></tr>
    <tr><td class="paramname">aRegionID</td><td>[in] Region ID to assign to the part.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa7ae611c1cc27c16e4eb3b05cf988dc6">PvResult::Code::INVALID_DATA_FORMAT</a> if the indexed part is chunk data (which does not have these IDs defined) or if the buffer is not defined as multi-part.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> if aIndex is out of range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2d22130bd183110f89eb459e0efca48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d22130bd183110f89eb459e0efca48a">&#9670;&nbsp;</a></span>SetPartZoneInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvMultiPartContainerWriter::SetPartZoneInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>aAdditionalZones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aZoneDirectionMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the zone info of a part. </p>
<p>See <a class="el" href="class_i_pv_multi_part_section.html" title="One section (part) of a multi-part container.">IPvMultiPartSection</a> for more information about zone info.</p>
<p>If this method is not called after adding a part to the multi-part container index, the number of additional zones and direction mask are both set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>[in] Zero-based index of the part. </td></tr>
    <tr><td class="paramname">aAdditionalZones</td><td>[in] Number of additional zones for this part. </td></tr>
    <tr><td class="paramname">aZoneDirectionMask</td><td>[in] Zone direction of for all zones of this part.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa7ae611c1cc27c16e4eb3b05cf988dc6">PvResult::Code::INVALID_DATA_FORMAT</a> if the indexed part is chunk data (which does not have these IDs defined) or if the buffer is not defined as multi-part.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> if aIndex is out of range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2a91d5d86412069e9c64dfb840aca2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a91d5d86412069e9c64dfb840aca2e2">&#9670;&nbsp;</a></span>Validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> IPvMultiPartContainerWriter::Validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates the part index and allocated/attached part memory. </p>
<p>This method goes through all parts defined in the part index of this container and makes sure that enough memory is allocated or attached to each individual part. It can also fail if not part has been defined.</p>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> on success.</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> if aIndex is out of range. </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_multi_part_container_8h_source.html">PvMultiPartContainer.h</a></li>
<li>PvMultiPartContainer.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2024 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
